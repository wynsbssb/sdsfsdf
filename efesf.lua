-- It's not necessarily "secure" but it gets the job done as Federal said he really didnt have any plans on fixing it

local RunService = game:GetService("RunService") do
	assert(RunService:IsServer() and RunService:IsStudio(), "MoonSec V3 Encrypted Dumper must be ran on the server/in studio")
	if not pcall(loadstring, "") then
		error("Loadstring must be enabled to dump MoonSec V3 Encrypted")
	end
end

local DataToCode do
	local DataToCode_request, DataToCode_source = pcall(function()
		return game:GetService("HttpService"):GetAsync("https://raw.githubusercontent.com/78n/Roblox/refs/heads/main/Lua/Libraries/DataToCode/DataToCode.luau")
	end)
	assert(DataToCode_request, "An error occured when retrieving the DataToCode source (try saving as a plugin): "..DataToCode_source)

	local CompiledDataToCode = loadstring(DataToCode_source, "DataToCode")
	DataToCode = CompiledDataToCode()
end

local Location = game:GetService("HttpService"):GenerateGUID(false)
local ScriptEditor = game:GetService("ScriptEditorService")
local shared = shared
shared[Location] = DataToCode

function DataToCode.output(tbl)
	shared[Location] = nil
	local Serialized = DataToCode.Convert(tbl, true)
	local DisplayScript = Instance.new("LocalScript", game)
	DisplayScript.Name = "Dumped_"..math.floor(os.clock())

	ScriptEditor:UpdateSourceAsync(DisplayScript, function()
		return Serialized
	end)

	ScriptEditor:OpenScriptDocumentAsync(DisplayScript)
end

local setfenv, error, loadstring, type, info = setfenv, error, loadstring, type, debug.info -- localizing so it doesnt retrieve it from the enviornment
local CClosures = {}

local function newcclosure(func)
	CClosures[func] = "C"

	return func
end

local function islclosure(func)
	return info(func, "l") ~= -1
end

local env = getfenv()

env.setfenv = newcclosure(function(func, ...)
	if type(func) == "function" then -- This is how they check if a function is a CClosure
		error("'setfenv' cannot change environment of given object")
	end

	return setfenv(func, ...)
end)

env.debug = (function()
	local newdebug = table.clone(debug) -- They retrieve it weird

	newdebug.getinfo = newcclosure(function(func) -- Encrypted only checks the 'what'
		return {
			what = CClosures[func] or islclosure(func) and "Lua" or "C"
		}
	end)

	return newdebug
end)()

env.loadstring = newcclosure(function(code : string, chunkname : string, ...)
	if type(code) == "string" then
		local Start,End,Pattern,Constants = code:find("([%a_][%w_]*%([%a_][%w_]*%((.)%)%))")

		if Constants then
			local Start, End, Reassign, Variable, full, Constants = code:find("([^%s]([%a_][%w_]*)[%s]*=[%s]*)([%a_][%w_]*%([%a_][%w_]*%((.)%)%)).-return %2%(%.%.%.%)")

			if not Start then
				Start, End, Reassign, Variable, full, Constants = code:find("(([%a_][%w_]*)[%s]*=[%s]*)([%a_][%w_]*%([%a_][%w_]*%((.)%)%)).-return %2%(%.%.%.%)") -- very lazy fix and I'm sorry :)
			end

			code = code:sub(1, Start-1+#Reassign)..`(shared["{Location}"].output({Constants}) or function() end)`..code:sub(Start+#full+3)
		end
	end

	return loadstring(code, chunkname, ...)
end);

-- Encrypted MoonSec V3 script here
-- PHASE_BOUNDARY:INIT ( [[This file was protected with MoonSec Vd]] ):gsub (' + ', (function (array ) _RYJeyvznmBKP = array; end ))  oAOubqoVugwJKkoY = _ENVzKSDDLiEsgHgyaJ ='QoUbAfeXp )} VwMsHbM
-- PHASE_BOUNDARY:INIT peAb / HsMX
-- PHASE_BOUNDARY:INIT Ae (UwHeV5A9Hfo )
-- PHASE_BOUNDARY:INIT pppUs )VfoAVApbXVosM {ssw5pAfmowse} 5b ^ sfF
-- PHASE_BOUNDARY:INIT XpXUM )} 5fUMbXeUpAeoMMw } pXAbsHMXAfHeoMUVwwebAfpU )) } XV
-- PHASE_BOUNDARY:INIT sXMbAnlww )eVApV5XUeHb5OHf
-- PHASE_BOUNDARY:INIT UVfbXdeo } pV5fXH * MsHsoe } UMfeUpswVppAAs;table
-- PHASE_BOUNDARY:INIT MXHXoH } VMUoVUXHApoAs!oHsM } eoUsf } pXAAK: } 5poHsHVwpeA
-- PHASE_BOUNDARY:INIT object } MHb } ?VM_
-- PHASE_BOUNDARY:INIT wepbUAsAMopsA } VXew } } )element;UwHpwUsMV
-- PHASE_BOUNDARY:INIT opVppXXHUUMAbespwf )lfwU } Hfw / pw5pUXHUpUfMopsAV?char } VMpAfoUeHpV
-- PHASE_BOUNDARY:INIT pUeoo )HpVoXVf
-- PHASE_BOUNDARY:INIT UAsVV } string .concat } sA } 4ewbpOUw5bHowUXwXXap
-- PHASE_BOUNDARY:INIT hVH } ssew5sfbMwVswe
-- PHASE_BOUNDARY:INIT M5wUpHAVspoLssXsfXbo )array
-- PHASE_BOUNDARY:INIT Vs )math .max } )owH5osHbVAp6AwoeAbbcs
-- PHASE_BOUNDARY:INIT we )AfoU } wVw5pfMsVVXAAukwMe
-- PHASE_BOUNDARY:INIT AbAsMHVpeUMfMwA } UwobfL } Uf } pe {pMTUsMHssw*Ae % UwHeVfAAo opV )5wXMHoVosoXfUVAew} }sswXf {VsoMwAXbebMMV} object } UDpHsbeppAoeVsAwAoo } }pbAL * wMp } Uem (5VNwpUwHMXsbtwofpvbUX } epe )} XXbiHwwp
-- PHASE_BOUNDARY:INIT U5eH = pVVfbp * Vowp } AsXMHoVosoXfUVAew } }sV } pefzowspVU } wAsUAsAVgXwAeXbUH
-- PHASE_BOUNDARY:INIT MooMoNo )5AVees } wsM } }VX bwapMU
-- PHASE_BOUNDARY:INIT o7ossHfeAUpe } Ao >=ww
-- PHASE_BOUNDARY:INIT peUUApV )op
-- PHASE_BOUNDARY:INIT HbwXsVpMUwfXH#string.sub
-- PHASE_BOUNDARY:INIT wU )VfpUAH!table } Mp } HXVA } oXXfa + wUMwAAUebswd
-- PHASE_BOUNDARY:INIT wVU )5ApoAsu } }HeVU
-- PHASE_BOUNDARY:INIT AA )UXHbVopwAMoAVeXXAboosAVoXpAoobM )} }XbAfd )) } X5bgHwwp
-- PHASE_BOUNDARY:INIT UfUV } }wVXbeswoV
-- PHASE_BOUNDARY:INIT AXAXsswsXsofpUo )} UUHzVppA5i
-- PHASE_BOUNDARY:INIT jeoUAsfAsU )sAV&XwAe7eeseieVs } }NwseXUpbo
-- PHASE_BOUNDARY:INIT Mp ))5ofHEAsMe } VewbpxAwsoAsb } oXvAVopsU } 5XebV
-- PHASE_BOUNDARY:INIT eeMUwHpwAps } ) )peAowH
-- PHASE_BOUNDARY:INIT Me )oebb } HfM# )AsswLpAf#owseobHowweXfHUssMA } UAsq } wXpAU >UpoeUe
-- PHASE_BOUNDARY:INIT wwVUw )bMHMUMwoXX
-- PHASE_BOUNDARY:INIT UoeH } ieMX
-- PHASE_BOUNDARY:INIT wepbAHsVMeUosUoV )pf
-- PHASE_BOUNDARY:INIT eewUwHpwApsV! )MeAbospMe
-- PHASE_BOUNDARY:INIT 5e )boi
-- PHASE_BOUNDARY:INIT wMUUHoVppAf?object } 5VUoH
-- PHASE_BOUNDARY:INIT VMo } ssV9XwApoUMbfUbUbp } KpU )} owHpKssV } AX {bwvewefV * XUpwpfw oH5MbH5eHAwf )MbVUVVUooVUs3fwA )!5wUesXf} AoA
-- PHASE_BOUNDARY:INIT MsVU } wfbfooUX
-- PHASE_BOUNDARY:INIT Xbpef )owspVAXs
-- PHASE_BOUNDARY:INIT number ))eUoMHwVMpHf } }string } UAAoiMw } eeeH
-- PHASE_BOUNDARY:INIT VwwwbAoeUsVipw )7bSHsHXXe5efwwA } eVsAcowUopsf
-- PHASE_BOUNDARY:INIT pXU )sesMeXAAww } beHbsgVAwVA
-- PHASE_BOUNDARY:INIT element } sbd wUUHoVppAf = object } AUUoH
-- PHASE_BOUNDARY:INIT VMo } swVdXwApoUbAUwHpw&ebAMUpXeAflwMp } Aes
-- PHASE_BOUNDARY:INIT oXXAHo } esbHmAMj
-- PHASE_BOUNDARY:INIT weeUf )opAp
-- PHASE_BOUNDARY:INIT ZoweHsMo )AeSUwHeV
-- PHASE_BOUNDARY:INIT bbou )peHbVc } MXUeHVVwpp5AosAVUf <ewoeVebUsHUwopVseVXXwApoAMs } object  %  AMH = ApHb } XeAVjwMp } Aes
-- PHASE_BOUNDARY:INIT 5XfAVoowH } MXsA1oXsVbehAww
-- PHASE_BOUNDARY:INIT peA )beAU
-- PHASE_BOUNDARY:INIT YeeUbbHpwA )uf } object
-- PHASE_BOUNDARY:INIT string.sub } eVpLsXsMHUw5ppfAU / string } lXHowp
-- PHASE_BOUNDARY:INIT AfeUosHwbo } HXV * XwApoUMo5woobf } array
-- PHASE_BOUNDARY:INIT string )pbMsp > 2eAb5ennXVfweUMUXb } bsMk
-- PHASE_BOUNDARY:INIT wepbUHbpwAH5pwfV } table } string
-- PHASE_BOUNDARY:INIT HXoH )pp5pbofwesHppUjA
-- PHASE_BOUNDARY:INIT ww } array } HUpofoU )} XbXpogMfMpX
-- PHASE_BOUNDARY:INIT bwbwMwpw } AUMobgXpebwe } sXMUwMbAo
-- PHASE_BOUNDARY:INIT byMf } buffer
-- PHASE_BOUNDARY:INIT Xo = Hg >buffer
-- PHASE_BOUNDARY:INIT wbfesAUvAMN )weeUfVWXApwoXwUswpHA } eUbAHpwA
-- PHASE_BOUNDARY:INIT Yf } XpefbUH
-- PHASE_BOUNDARY:INIT math .max ))wX!Vs
-- PHASE_BOUNDARY:INIT pfAUdswVeHoMA )be >hwsew
-- PHASE_BOUNDARY:INIT psb } obHX } char ))AfyVX } 5ooOMw } pXUbo } 0 .write
-- PHASE_BOUNDARY:INIT table )eHwHUHweHApfMMo } 5MU } bepbA:Tw } sVMo } )eMoMgAeUUwHpwA
-- PHASE_BOUNDARY:INIT 6fsbpHAw pw5eopXwXsXVrpwHMM5oooAoMfpV } eU } tso } HXVKXwApoUMbfUbUbp } hpU )} owHpAfwMAXUA } wpbAHossVb } UbM& )wepbUHUeoUHfXM, VMVVAMHsUXwqfppUo } MfsXe + AMApsw
-- PHASE_BOUNDARY:INIT element } sb_s
-- PHASE_BOUNDARY:INIT pseMUVXHopVos } VwpaAwopsU } bboob05psfoVeAeUvMw } pXAbsHH
-- PHASE_BOUNDARY:INIT pfVeowM )Mwfb
-- PHASE_BOUNDARY:INIT table )string
-- PHASE_BOUNDARY:INIT VMXbpsoUHezUse )peAb <table } UoyHMV } e5Xb5HHwXpXXAbshoMU
-- PHASE_BOUNDARY:INIT XeHoNHMwA )bUMoM ^ )weeVApxAwopsAVNXwApfAsUV
-- PHASE_BOUNDARY:INIT XpAAo math .max } HXsHV } XsAMoXwUVXpYAAoos } buffer } UwMk
-- PHASE_BOUNDARY:INIT wepbUe {array:NMsb5wesbMmwMofpXVbo#Hpp} AXUbVWww ))bX .UMHppr } beobpHpXwXfebUHH } }Vp
-- PHASE_BOUNDARY:INIT 5bMwMspXoeHs } wXpAAtsb } fAe5MVVjw } baUebXMgep
-- PHASE_BOUNDARY:INIT object = 9sHHA
-- PHASE_BOUNDARY:INIT eeUfVMw )XVwfwHMUA } H5fpHUpwoH } wH
-- PHASE_BOUNDARY:INIT EfwUpHUobHMMppbeob } for } number
-- PHASE_BOUNDARY:INIT pHfMV } pwfNowspVUM
-- PHASE_BOUNDARY:INIT table )pH5foZs
-- PHASE_BOUNDARY:INIT VeoesX } wXpAA?swsffL <boMA
-- PHASE_BOUNDARY:INIT string } eX } bwhpMA
-- PHASE_BOUNDARY:INIT swoVUpAAsoXwp } 5pAAw
-- PHASE_BOUNDARY:INIT peAbaHwwp )AecowbXwe
-- PHASE_BOUNDARY:INIT H5wUpHAVsXMfpVMsofKA } AAs ))array } wozsoX
-- PHASE_BOUNDARY:INIT AfVepMAwopsA } sesHU } oMbebbbbewAp )) )bwMV ^ sMs } AXabwref_ossoVUpAMUVAepbAavw } string.sub } HUsAsM
-- PHASE_BOUNDARY:INIT obbfowo )oVebpHfo
-- PHASE_BOUNDARY:INIT string.sub } eMXMHMMpsbeUop } )char = ssw5pAfhowse } eUpMp ^ ) } wXees -5 } )MoAAo } Aeo } Mw } pXAbsHHXs5se5sVVUwpAMWAbpgAM * )wepbAslbVMpeeAUHwwp
-- PHASE_BOUNDARY:INIT A5sXwfboHssVVo )pHeApdosMVsAAwUsAewp } AV } ) / 5yowspVUMww } string.sub
-- PHASE_BOUNDARY:INIT 5MU5HMwoeHf } UAHMAeoAMw } pXA } UpfAw =)XUAA -pMA } / element } )AXwbMUoM
-- PHASE_BOUNDARY:INIT VUXHws } 5eAbdHwwepAU
-- PHASE_BOUNDARY:INIT MAswf (UoAwHb } oVUo )
-- PHASE_BOUNDARY:INIT obUeHHVwpp5AXbAfboMXVHXbbUosHo } eeAf oVHA } )oeHb } wXpAAcs5VoXHUVoXMAXopeUMUwfweA } &MeAp .AHoVHUbexeww
-- PHASE_BOUNDARY:INIT peA } bXcb } HMws
-- PHASE_BOUNDARY:INIT bH } MM
-- PHASE_BOUNDARY:INIT WfwUpHUVoUXoboAVXeMX )sMwoMHAHbwAgs -XA } AAAqUvwXAfeesH (wwsUVMXpAAoWM }:XsfV } XwbUoHH;VoX } array )
-- PHASE_BOUNDARY:INIT aHM )VpX
-- PHASE_BOUNDARY:INIT AVoee } bV, Eww
-- PHASE_BOUNDARY:INIT peUUApwespedpsAH } MM
-- PHASE_BOUNDARY:INIT t5wUpHUVUAf (popp = eUX } HwMpMwXwA } Ao } Mpo } pAlooSV } wf
-- PHASE_BOUNDARY:INIT eMsA } psUV )
-- PHASE_BOUNDARY:INIT XpAAoEM } )VUfs } HMpdfbebw } wwwfepbob } {)MT wepbUerbMowsAbUibwp )AeEU} string
-- PHASE_BOUNDARY:INIT XAbpf + MVpewU
-- PHASE_BOUNDARY:INIT s5pUAHbV } s5VofsMHpUbA
-- PHASE_BOUNDARY:INIT eApUwH )number )o5MUfssVwppoesw } wXpAAzsbAUbsb } MpAbAowMMwoX
-- PHASE_BOUNDARY:INIT 5U } Uppbp / AM <) } 5 } sH
-- PHASE_BOUNDARY:INIT VVw5wHvUfp )eXp
-- PHASE_BOUNDARY:INIT 2bs&string
-- PHASE_BOUNDARY:INIT pHoHf -sVVbVoApHboeVApCX } spVVsswUpA5aowse } 5owog_MpbbMeHHbMbso } wX } 5
-- PHASE_BOUNDARY:INIT odMw } pXUb / M5ph
-- PHASE_BOUNDARY:INIT pHwwMefbose )pXeAo = HM )} wXeAf - )Mf } Xb {Hwwp AemUwHpwA )I5sboHAwrpw5eo5p5f char ) swsAsHppefXowspVAseVVp} array
-- PHASE_BOUNDARY:INIT ooMHVyofso } speAAoqMw } eMH
-- PHASE_BOUNDARY:INIT sXoUso5HfVspsAso )table } pHerMU } oepbAOcArH
-- PHASE_BOUNDARY:INIT we )weow } )se, UwHpwUMMww
-- PHASE_BOUNDARY:INIT pfAbVHHwV )weoVs ).5AUCswVeMAVM )} 5HbUsMwoo } _AVZXwApoUMoAf&5bfw
-- PHASE_BOUNDARY:INIT XH )} osIUHM
-- PHASE_BOUNDARY:INIT AboeoMfwAwAeAHpU ))pebpsSuw
-- PHASE_BOUNDARY:INIT XMVweoUHUb )wXw
-- PHASE_BOUNDARY:INIT eeeUwHpwApsVw )MXAbpHMf } AeHmVwppfU
-- PHASE_BOUNDARY:INIT AewbpGmwHeUUbsHHwV ))XeAUos } VMpso } oVHbVMAVf } o5HXXVfsb
-- PHASE_BOUNDARY:INIT HfHAXpX } obHbewbpPAMd
-- PHASE_BOUNDARY:INIT wepbAot = number )} esb, Hwwp
-- PHASE_BOUNDARY:INIT string } math .max
-- PHASE_BOUNDARY:INIT wepoUooMw } peHb } VbfpUAH .wbpp5AUvssVspA5Pow5VUpHUVfpeAVVUpoApoAs / UCM )} eXwAo } }XAAfzwMp } eXobwcpMA
-- PHASE_BOUNDARY:INIT sewbphAM * )wepbAX .rw
-- PHASE_BOUNDARY:INIT peAbCHwwp )Ae&UwbpwA ) {5wUpHAw0pwApebHoVwpp5AUZswVppAf >owspVApeAwopsAV?VcApoesG} wXpAAoeMw } }XAAbhwM )} AXfbwTpHS } RXfbp0fM: )wepbAo
-- PHASE_BOUNDARY:INIT ww )VeAbUHww } )Ae -beHpwe
-- PHASE_BOUNDARY:INIT _fwUpHXwxpwe )UAHuVwp
-- PHASE_BOUNDARY:INIT 5AUiswV } table
-- PHASE_BOUNDARY:INIT 5jowspVAVMAwo )sAVPXwApoAscf } XpAeoCMw } pXAAdBwew } AXobwc } MA } UewfseoM >)MepAJTLwM
-- PHASE_BOUNDARY:INIT peebS?nXV
-- PHASE_BOUNDARY:INIT Ae#UwmAwA
-- PHASE_BOUNDARY:INIT o5wUpbowRpM5pU5HTVwppfAXsswV } pAfcowspVApepeopsXV * XwApo5si } sXpAAXXMw } pXAAlzwMp } AX2_AdpMA } 2esbpdAMb
-- PHASE_BOUNDARY:INIT wM )bAhoww
-- PHASE_BOUNDARY:INIT VeAboHwwwAXe / UwHpHX
-- PHASE_BOUNDARY:INIT T5MUpHAHMpwf )UAHJVwppfAU + array } VppefIowspVApgAw } wsAVoXwA } oAsU } number
-- PHASE_BOUNDARY:INIT seooDMM } ppeA4dMMp } 5X >A_VVMA } xewA } ^AMo
-- PHASE_BOUNDARY:INIT wewsX 6ww
-- PHASE_BOUNDARY:INIT string.sub
-- PHASE_BOUNDARY:INIT Xb = HMwp
-- PHASE_BOUNDARY:INIT AFoUwH )wA
-- PHASE_BOUNDARY:INIT D5wUpHAwsHH5pUVH6MUpp5fURsMVpppnbowspVA )eAwo
-- PHASE_BOUNDARY:INIT sAVAUHApoAs#MHXpAfo = MwsfXAAozwMV } AXabwfps )} 1esbphAM ()wepAeooww
-- PHASE_BOUNDARY:INIT VeAbXHwwp )AXUAbHpwp
-- PHASE_BOUNDARY:INIT hebUpHAwZpw5wUAHoVwpwfAUUswMsp )5eoMspMUp#AMopspVTpNHVoAsg } number
-- PHASE_BOUNDARY:INIT eAAooMw } wUXAe, wMpMXX >bMSpseHfewb )/ AMb
-- PHASE_BOUNDARY:INIT wepbAoUUo )peebnmUwp
-- PHASE_BOUNDARY:INIT AeTUw ))wA
-- PHASE_BOUNDARY:INIT bfwUpHAwypwe } char
-- PHASE_BOUNDARY:INIT table  %  wYppfVUxswVppp
-- PHASE_BOUNDARY:INIT Uows } VAVUAwo
-- PHASE_BOUNDARY:INIT sAV, math .max } Apo } sb } MXpAAoRMwwsXAAXWwMw } AXlbwGpse } ?XAbp >pMC
-- PHASE_BOUNDARY:INIT wepbAowww } oeAbbHwwp
-- PHASE_BOUNDARY:INIT AelAUHpws )^5wUpHAwupw5VUAHVVwpM5AUjswVppVfzUpspV
-- PHASE_BOUNDARY:INIT pjAwopsAV } XwfooAsw } wX } AAo / )number } pXwAgoAMp } MXSbwpHMA } )ewbMTAMh
-- PHASE_BOUNDARY:INIT wepb5aaMA )pewb  %  CfwpVAXAUw_RwA
-- PHASE_BOUNDARY:INIT pfwUMHAwC ) 5pUVHIwbpp5wUcswMApAfoowssVApXAwowesVtXsApbXsj } MXpAAAoMw } )XAAU (wMp } AXNeMapMA } / esbp (AMi )
-- PHASE_BOUNDARY:INIT wXwbA_dww ))eAb  %  Hww ))pe  %  UwHpwe
-- PHASE_BOUNDARY:INIT VfwUpHAVsEAMb )oe -bVlpMU
-- PHASE_BOUNDARY:INIT 5eeUVpefpowspVAXs } ? )peAUwwHV ))AsUMeXpAAocM } owHAwTppfXs } }VXXXVA
-- PHASE_BOUNDARY:INIT UqsDV )XUy } KVsb } MbVowHwsfVbXMfbsHVXeXXeboob
-- PHASE_BOUNDARY:INIT char } oeobfle
-- PHASE_BOUNDARY:INIT buffer )bepbo2A5eU5swVppAAspH5fUMHoAwopsAV, pAApoAshVso (AAo ^ Mw } )XAA  %  .ws } VeX?bMmpMp } fewbpUAs ))we
-- PHASE_BOUNDARY:INIT bAdoww )} eAAUYfwp
-- PHASE_BOUNDARY:INIT XevUHHpwA )JfwU
-- PHASE_BOUNDARY:INIT HAwopw5VUAH1VwppeAUTswVppAf osspVApwAwopsAVoXwA
-- PHASE_BOUNDARY:INIT oAsgw&XpAAorMM } pXAAIKwMM } AXGbw <} MH } Wewbp UUsoMsU
-- PHASE_BOUNDARY:INIT bXoA } object } math .max ))HeMw } ) )egUwHpwUubw )} oefwU
-- PHASE_BOUNDARY:INIT bfpUAH * table } sUwHpHeAUM#yfUUAspVApDA } XXeAUoHpwAp5f: } spFAAoCMw } ewbVVpe5UofMHVwc
-- PHASE_BOUNDARY:INIT MA } LewAXaAMY
-- PHASE_BOUNDARY:INIT we } bHgvww
-- PHASE_BOUNDARY:INIT peUXHe )AUsbMV } AXdb
-- PHASE_BOUNDARY:INIT cqwMU } Hww / pw5pUUAwbAHfM ))oe } bXp55ooMspVepfAwopsA } sMeV5pMfo } sXsAAo ^ Mw } eHa } MpofeUbXUAb (pMA } Ee } )UXHbHoAMMVBSUMh
-- PHASE_BOUNDARY:INIT peAb  %  table } oMob } MUsqbwA )!5wUeAAbfYVwX
-- PHASE_BOUNDARY:INIT He } beH
-- PHASE_BOUNDARY:INIT wb } vsswApA5xowsevXHowweX5pUfHAVp
-- PHASE_BOUNDARY:INIT UfoUeX } AMo + Mw } pXUpsX
-- PHASE_BOUNDARY:INIT 5Xofww } )pefA } UXebpNAM ^ ) } wV } HXsAboXs_
-- PHASE_BOUNDARY:INIT MeVb ))eepUwHpwApsVV } pefbwPpw ))AHUwopp5AUis } UVHow
-- PHASE_BOUNDARY:INIT pMs } wRpPAwopsU / pHXVXpofp <pHCVo
-- PHASE_BOUNDARY:INIT 5AMUeXAA ;wMpMoXDbw?pseswewbp&AMX
-- PHASE_BOUNDARY:INIT wepbAUeU ))peAbRUfwp
-- PHASE_BOUNDARY:INIT 5euUHHpwpAbfwUpHAs )pwf
-- PHASE_BOUNDARY:INIT UAEU9ppp5AUNHUVppAfBUsXbVApoAwUesAVgXwepoVs  %  } MXpAfousp } string.sub
-- PHASE_BOUNDARY:INIT AAXhwM )} AXobwoUMA } 7pobp -)sepbA * tww )} eAb Hwwp
-- PHASE_BOUNDARY:INIT AeUUwHwMw )ufwUpo } wSpM5pAAHwVwpMfAUAswVMpAeUwsspV } string.sub ^ 5 } opsAVn
-- PHASE_BOUNDARY:INIT wfwoAse } wXsAAoUMwwppsAZoUMp } }XiAV_pHAV } ewbscAMe
-- PHASE_BOUNDARY:INIT weMbAxews )pe
-- PHASE_BOUNDARY:INIT blUUwp )5eLbUHpwpAb5wUpHAsepwf
-- PHASE_BOUNDARY:INIT UA {string&pppf string!HUVppA5ZUseoVApeAwUesAVIXwepoHsdVUXpA} ocsp } ppeApgwMH } AXsbwfpMAw .eMbplVM_ } bepbegmswV;eAbXHwwH
-- PHASE_BOUNDARY:INIT AeHUwopMb )ZebUpHVwh
-- PHASE_BOUNDARY:INIT o5pUAHeVwps5AUeswVHpAX1fAspV } pFfUopssV_Xw
-- PHASE_BOUNDARY:INIT ooAse } wXHAAo <Mw } pooA  %  ooMp } AXBAb + pMpfbewbpxAHA
-- PHASE_BOUNDARY:INIT we )bAU {aA pesbqkfwp )wexbsAMwA w5wbbHAwmpwfp )HH&weppeTUjssVpp} pXowHUVA } bAwo
-- PHASE_BOUNDARY:INIT sAVoXwAwwXsm } wXpeXo;MM } pXpHbYwMp } array
-- PHASE_BOUNDARY:INIT AbwS )MAMF / UbpTMMF
-- PHASE_BOUNDARY:INIT Mepbp * 4MUs5eAb5Hwsf
-- PHASE_BOUNDARY:INIT AeoUwH } wA
-- PHASE_BOUNDARY:INIT array:HUpHAw <} )5pU5HCwUM5fAU swwUpAfoows } VApAHHopsAVCpeApo5sJVGUVAAobMwMAXAAo + ws } HLXDbwjpso } 9ewbpUA;string.sub
-- PHASE_BOUNDARY:INIT wepbAgDww } oeAb ^ Abwp
-- PHASE_BOUNDARY:INIT AelUsHpwf )3fwbwHAw, pwf
-- PHASE_BOUNDARY:INIT UAHLVwppeAUEswVpp } pXowspVApbAwo
-- PHASE_BOUNDARY:INIT sAVoXwAwwXsk } wXpAXo:MM } pXpHb wMp } AXMbwa
-- PHASE_BOUNDARY:INIT MA } tobbpZfMW
-- PHASE_BOUNDARY:INIT MepbA (kMszXeAboHwwV )
-- PHASE_BOUNDARY:INIT Ae#UwF } Mo )&5MUpHewEpw5pAAHfVwp
-- PHASE_BOUNDARY:INIT 5AUoswV )pAXkUospVfpzAMopspVY
-- PHASE_BOUNDARY:INIT wfeoAso } wX
-- PHASE_BOUNDARY:INIT AAofMw } } } AAB&HMp } AXnbwcpMAoVewb )<AMb
-- PHASE_BOUNDARY:INIT we } bAoUos
-- PHASE_BOUNDARY:INIT pefbPf * wp
-- PHASE_BOUNDARY:INIT AeIbx } VwA );5wbXHAwopw5pwVH4VMppfAUkswVp
-- PHASE_BOUNDARY:INIT element } Uows
-- PHASE_BOUNDARY:INIT VApbAwopsAVL )<ApoAsP } MXpAAoLMM } wXAA__wM } swX bwCpMUoAswVppmAHsU } beHXsb
-- PHASE_BOUNDARY:INIT oV )string } bXoAp, pso )} char
-- PHASE_BOUNDARY:INIT AbFoM } )XeHb } .ww ))sXdHeHXwH ))UXhHwlMPf
-- PHASE_BOUNDARY:INIT eUsHMwwMpe5wUfsVpbpMAMUoHUXHe } 5XUesM } MpAu
-- PHASE_BOUNDARY:INIT sU } wpsp -AooHsvVnX
-- PHASE_BOUNDARY:INIT Abo ^ spbenVww
-- PHASE_BOUNDARY:INIT peAUsXAAbtoMr } VXpAUnfMe
-- PHASE_BOUNDARY:INIT VHewppwfpUAssodEpMA )wbHU )?AfUUospVApqA } pVfoU
-- PHASE_BOUNDARY:INIT sMApoAsN } wpgAAoEMwV } + wA / wMp } eX;bwgpse } 5ewb
-- PHASE_BOUNDARY:INIT kAMA )wepbAU ^ MK
-- PHASE_BOUNDARY:INIT pefbxHMwp )Xe_bsHMwA
-- PHASE_BOUNDARY:INIT bfwU )HAwhpwfpboH = VMppfXU / swVppAe5owspVAphAwo } sAVSpVApoAsj } MXpA5oeMwVwXAAxfwM )} AXIbwDpso } BewbpIeMV
-- PHASE_BOUNDARY:INIT wepbAHsUArfsA } oXVApHUMV } XXowe } UfwUpHAVss } number )} + epboHXwo } vfMUpsbMq
-- PHASE_BOUNDARY:INIT XeeUoHbVMo } swVvXwApoUbwUAsfw
-- PHASE_BOUNDARY:INIT pof } UXXeApjwMp } AesV } char
-- PHASE_BOUNDARY:INIT 5oUosoVeXfMU } oepbAfOw } !VMo } )eMw } )weBUwHpwUMHMr
-- PHASE_BOUNDARY:INIT 5esbbHMwpUeH } Vwpp5AosApbuHoMfpMeedXYowoo } ssVjXwApoUb5UesMwApfA
-- PHASE_BOUNDARY:INIT UpsHVsEsMH } AX:bw9eUM_MsoVUe5Uf
-- PHASE_BOUNDARY:INIT sXdbA >qww
-- PHASE_BOUNDARY:INIT eVb } VXeAUzfwH } wH } wM
-- PHASE_BOUNDARY:INIT xfwUpHUobH )Mo
-- PHASE_BOUNDARY:INIT 5AdU )_pwoUUHeVppAfuo } AoUoH5wepbbXoMHfV
-- PHASE_BOUNDARY:INIT oesw } wXpAAZsbAUbsb } MpAbAowMMwoX
-- PHASE_BOUNDARY:INIT 5U } oewbp / AMM
-- PHASE_BOUNDARY:INIT wepbAvUM } )peAb / table } Ub_s } table } AeMb5g } MwX
-- PHASE_BOUNDARY:INIT XeboOeMpUeHpVwppfAosbVUwHow } pHf
-- PHASE_BOUNDARY:INIT UApUfXopsAVZX } table } string.sub
-- PHASE_BOUNDARY:INIT 5soMHXV )pb5eofswAUosMp } AXlb } eeAfowsA } MXbbMowM )} AfHAwobsU
-- PHASE_BOUNDARY:INIT MeHb ))Ae_UwHpwA
-- PHASE_BOUNDARY:INIT 8fwopbbwU )XfpUAHxV } sfwo } 3fMbXaA } string
-- PHASE_BOUNDARY:INIT XebUMpUf } opsAVLX } table } pw55oVsHV5psbAoMsXVApwfX } eXHbwtpMA
-- PHASE_BOUNDARY:INIT swMVXXfUoosM )} spZUfobMAVoXAb ))eeeUwHpwApsVs
-- PHASE_BOUNDARY:INIT 5ewAoHMf } UMH >Vwpp5UXbf
-- PHASE_BOUNDARY:INIT boHf } dp
-- PHASE_BOUNDARY:INIT epUopUfbopsAV&char } )element
-- PHASE_BOUNDARY:INIT U5foVsHwboUso } pXAA => } AVoos )} Mz } math .max )} vewbp  %  UbbS
-- PHASE_BOUNDARY:INIT MMVAGbww )peAAeHwwp
-- PHASE_BOUNDARY:INIT AXUwXHpwA )mepUpHAwb } we_UAH_Vwpp5AUAswMppp54owspVApBfeop!AwpXwApoAsz } wXsAAb {sA} pXAAaiwMp } eX (5w_HMA } 2ewbp ^ AMM
-- PHASE_BOUNDARY:INIT wepAf - % ww
-- PHASE_BOUNDARY:INIT peebLHMwp } element } wUwHpwA
-- PHASE_BOUNDARY:INIT bfwUpHAMU } e5pUfH wppp5AUGFwwwpAfoows
-- PHASE_BOUNDARY:INIT VApAAwbpsHVyXMApofs!VXXpeAU )
-- PHASE_BOUNDARY:INIT Mw } )XAAonwsv } array
-- PHASE_BOUNDARY:INIT mAU (pMf } {eMbp3fMm} seHbAeUww )
-- PHASE_BOUNDARY:INIT HeAbTHwM } ) )element <UHHpMS )(5wUpoAwwpw5VUAHbVwpw5AAN55VppXfhoHspVspBewossAVbXwAVoAse } number
-- PHASE_BOUNDARY:INIT pAMokMH } pXXAnofMpVepwbwFwMA } 5ewbpuAMg
-- PHASE_BOUNDARY:INIT MepbAa (MO
-- PHASE_BOUNDARY:INIT pefb .HwwH
-- PHASE_BOUNDARY:INIT Ae / UwH )
-- PHASE_BOUNDARY:INIT wA )t5wUpYewSpwfpbeV } Vwpp5AUAswVppAeUbespV5plfoopsAVZ
-- PHASE_BOUNDARY:INIT weooAso } wX
-- PHASE_BOUNDARY:INIT AAobMwwpXXAaWMMp } 5XkA
-- PHASE_BOUNDARY:INIT dpHAV )ewb
-- PHASE_BOUNDARY:INIT RAMo )weHbAUasp
-- PHASE_BOUNDARY:INIT pefbCHMwp )Me -AwoUwA
-- PHASE_BOUNDARY:INIT ofwU )HAwppwXpb -HfVMpp5fUTHpVppAMsowspVApUAwo } sAwU
-- PHASE_BOUNDARY:INIT jApofsZVoXpAAo {HwViXAAolwM )} AXUbwUpsU } 4eMbpG5Mh } XepfAdMww ))eAboHww ))ApFA5Hpwf ) 5MUpH } wm } we } UAHoVwp
-- PHASE_BOUNDARY:INIT 5AU } swV } VAf#oHspVApnAwopsAUoXwA
-- PHASE_BOUNDARY:INIT oAsb } wX
-- PHASE_BOUNDARY:INIT AAoGH * } pXAATbMMp } AX?bwJwMA } / ewb } -HM_
-- PHASE_BOUNDARY:INIT wepbUXpAX A } HXwAeu
-- PHASE_BOUNDARY:INIT math .max } )HH } number ))JfwUpHUbbH
-- PHASE_BOUNDARY:INIT Mo )5HUwAppfAUvs } =wzAMG
-- PHASE_BOUNDARY:INIT pbVUfL + AsfAsAV#XwAeppe = UwHAwbfeoXsbHU } MpHoUoXs5VwXw554ssMVXXfAstVsb } spSbMoUsAe } eVAb ^ math .max
-- PHASE_BOUNDARY:INIT table )VeebpJpso } MUHbpooMM
-- PHASE_BOUNDARY:INIT b5sbiwbwMpMeobUVHwH )> 5Mb } Hfp } opsAVPXwf <oAsc } wp } MwoaMw } pX5AbzwMpVepobw >)MA } Uewbp * AHT } Uepbfy_wM
-- PHASE_BOUNDARY:INIT peXbr ^ sMX
-- PHASE_BOUNDARY:INIT AebUwHwwA )BfwUpmAw (pMfpUXH:Vwpp5AUoswVppA5aows } VApBAsopsAV_XMApofs  %  } wpwAAo  %  Mw } )XAA!3wMp } eXjbwOpMe } MewbpgAwsoVM
-- PHASE_BOUNDARY:INIT VAeHAAzMsm )sXXbfoUMkUs ^ bwA
-- PHASE_BOUNDARY:INIT RfwUebUHMwV )5epbUDowf
-- PHASE_BOUNDARY:INIT oebswVppAfCUgspVAp eAsAV / XwA
-- PHASE_BOUNDARY:INIT oAs >} wp } ) )oyMM } pXeAkTwMp } AVXbw, pMA } Uewb ) {AMmV?epbAFtwM peAbrHwww )AeBUwH} wH
-- PHASE_BOUNDARY:INIT c5wUpHUbpBXwf )AeHbw!ew )) } 5HV } MAf >owspVUHAww
-- PHASE_BOUNDARY:INIT pemUHwUpbAHfso )HVXspbfoUpspwoX } 5
-- PHASE_BOUNDARY:INIT UbsoV } XXAHo } sw } )XsfrMeMX } HX ) % XHosUp } eMUesA
-- PHASE_BOUNDARY:INIT weXApbHiVM } }XUMoAH
-- PHASE_BOUNDARY:INIT wX )VUVb5Hfw )) } UX;wHHwp } obVbUHowep5fAUow } wMesfoU } spXspp5MofXeAp  %  wMp } Aes
-- PHASE_BOUNDARY:INIT PppfAowVH } )pAMU } oepbAhGw } TVMo } )eMwp
-- PHASE_BOUNDARY:INIT AelUwEvwA )Kfwb } pww6pw5pUfHnVwppeebVswV
-- PHASE_BOUNDARY:INIT pAfAowspVA } Y5wops5V1XMApoXseVspoAAobMw } }XAA_WwMpVeXlbM (pMX } {ewbpaAMe ) wepbAxCww )} eAbzHswp
-- PHASE_BOUNDARY:INIT Ae <UMHpwf
-- PHASE_BOUNDARY:INIT B5wbwHAw3pwf )UAHGVwpp5pU1swVppefpowspVAXs } bit3c
-- PHASE_BOUNDARY:INIT peAUwwHV ))AsUVoXpAAouM } oVsoV
-- PHASE_BOUNDARY:INIT XMM } }HXObwPpMUopsX } 5XAAHowse } )char } bH )} }Xb!Hwwp
-- PHASE_BOUNDARY:INIT UMA } wXpA (qH } UebUHbsH )
-- PHASE_BOUNDARY:INIT MVfsebboBpwp } of } buffer ):bwo )} 5XUHH } wwp
-- PHASE_BOUNDARY:INIT 5sb#VeVXpHf
-- PHASE_BOUNDARY:INIT sXsXVUpAfAUMH )XVpAfMU
-- PHASE_BOUNDARY:INIT MH } }XwIHo
-- PHASE_BOUNDARY:INIT math .max )} MXsBVoeM )} sXbAA:MMo } }eHApa
-- PHASE_BOUNDARY:INIT wM } XHpwA
-- PHASE_BOUNDARY:INIT 35wbgHAw  %  pwe } VwHyVwppfXUzswVp
-- PHASE_BOUNDARY:INIT e5fows )VApUAwopsAMD
-- PHASE_BOUNDARY:INIT UApofs {} MXpA5oYssVfXAAbuwMw } AXzbw {pMf} {eMbpSXMj wepbAoeww )peAbyHww} )AexA >HpwA
-- PHASE_BOUNDARY:INIT m5MUpHfwZpwewUAHWVwp )5AU_swVpppfcowspVepVAwopsA } sHAwbpo5JUVHpwUp5feoVXeAp {wMp} Aes ) % ppfAowVH } )pAMUsUepbAi <number } ywsAVTXpAXM } )VeXXeboob
-- PHASE_BOUNDARY:INIT element )Ve
-- PHASE_BOUNDARY:INIT AzdiM ))UXobVH
-- PHASE_BOUNDARY:INIT MUpHeXbUcAwo )eepsssHwX
-- PHASE_BOUNDARY:INIT ooHocHwwoXbAHU } sMwF
-- PHASE_BOUNDARY:INIT jAMUe } table
-- PHASE_BOUNDARY:INIT VpwAwofss )VXX5UofspVpbHA
-- PHASE_BOUNDARY:INIT accumulator )MM } sbVUeobMb } pXoAA
-- PHASE_BOUNDARY:INIT eefUwHpwApswH )5eMbopw5pUAHIwAppfAU?Hsf;pAfrows
-- PHASE_BOUNDARY:INIT VApeAwU } HsV XMApopst } wXpeAUoMw } )XAAoZwM } }ApUAw_pMX } ueHbpaAMY
-- PHASE_BOUNDARY:INIT wXpbASoww )VeAb Hwwp ))egUwHpwA
-- PHASE_BOUNDARY:INIT 15sUpHAMbpwfpUAHoVwp )5AUKI_VppAfOoMspVAp#AwowsAVmXwA } object
-- PHASE_BOUNDARY:INIT sq } wXpAUpbA
-- PHASE_BOUNDARY:INIT UosfAUeMMp } AXNb } XwfAU?spVXA } 1VMXse } opb * ebVM
-- PHASE_BOUNDARY:INIT VBXPA )FUso } Ve
-- PHASE_BOUNDARY:INIT AUHHMX } UXAboLeMp5sfHbX <opHeHeubeHHw } )XbfUbsHVM
-- PHASE_BOUNDARY:INIT W5fUss )wppH5ssXMAw5XsfAoMsbX
-- PHASE_BOUNDARY:INIT eVAXUUs5Vppp5bMVsf } 5X
-- PHASE_BOUNDARY:INIT array } MXwo } HXsAp_wM )} }eHBbsMMV } }XAbpsHwV } ee
-- PHASE_BOUNDARY:INIT bwhw )string
-- PHASE_BOUNDARY:INIT wXoU )string.sub } 5HU  %  swVppUwp
-- PHASE_BOUNDARY:INIT X5fUAHHww )ef
-- PHASE_BOUNDARY:INIT string } sHA } owsc } wXpAUeAfwUpHm
-- PHASE_BOUNDARY:INIT bXMfp } AXkbw .pMw } 1ewbpoeep
-- PHASE_BOUNDARY:INIT wepbA >bww
-- PHASE_BOUNDARY:INIT peAAU_Mwp )5e_UMHpwA
-- PHASE_BOUNDARY:INIT xXwb5HAwopwf )UAHAVw )} 55UksHVppefuowspVApbAwo
-- PHASE_BOUNDARY:INIT sAVbXwApoAs (VfXpAAoLMw } pXeA# ^wse } AXhbwg
-- PHASE_BOUNDARY:INIT MA } oewbpopMG )
-- PHASE_BOUNDARY:INIT wepbfdEww )peAbAHwwp
-- PHASE_BOUNDARY:INIT AeUbXHpwA )3f } }qeHUMHwMX } AesboqUwXUUbAVppAf;object } 5wbAdFwp
-- PHASE_BOUNDARY:INIT XU } sVVXwepoebsesVV ))YfJU
-- PHASE_BOUNDARY:INIT sUwopVA )UUMHVXpU5AooseVpbsbHoXsoeHfXEpop } object } }bXUAofws } AeMbbwVMf
-- PHASE_BOUNDARY:INIT 5e )buffer } wXVA } 5esbpGnw5foU } HAMewpp
-- PHASE_BOUNDARY:INIT eXUpHpwopVfpbcXsAMoAsg } wXeVXXM5fo
-- PHASE_BOUNDARY:INIT XeAp!wMp } Aes
-- PHASE_BOUNDARY:INIT zppfAowVH } )pAMi
-- PHASE_BOUNDARY:INIT wepbACpww )peAAU
-- PHASE_BOUNDARY:INIT Awp )AeTUMHpwA
-- PHASE_BOUNDARY:INIT 9esUsHAwopwfVUAH  %  Vw } p55U0sMVpp5fuUPspwepwAwoVsAVUXwApoAs / woXpAfoYMH } pXAA?3wsV } AXZbwypMA } Uewbp <sMz
-- PHASE_BOUNDARY:INIT wepb5jcwM )peAAAHwwp
-- PHASE_BOUNDARY:INIT AeoUwHpwA )_e!UpHAwlps5MUAHhVwpewXpMefU
-- PHASE_BOUNDARY:INIT peXUowspVAXswh )peAUwHVpsAHoVUpsfwb
-- PHASE_BOUNDARY:INIT ZAMoes )table } AeAXoHs
-- PHASE_BOUNDARY:INIT XXpeAoUb } XX } AfbWoHwpXpXeb )) } eHbWHwwp
-- PHASE_BOUNDARY:INIT UMp } XefbAqHMw } ee
-- PHASE_BOUNDARY:INIT buffer } HHf } UwHmVwppfUXAewbp  % - } bpMepVAp_AwopswVLXwApUeXp } wXpAAobMw } pXAfUUAMp }  bMJpMA } Spw5fDAMo
-- PHASE_BOUNDARY:INIT we )bADAww } }pobTHHwp
-- PHASE_BOUNDARY:INIT eeLUwHpwA )5fwU
-- PHASE_BOUNDARY:INIT HAwbpw5pUAHEMpppfAU * swVppe5SowHfVApzAwo
-- PHASE_BOUNDARY:INIT sAVoXwApUpsI } wXpAfoFMw } pXAApLwMp } AXUAb_pMA } ve } )AXoAsPMsUVAkUMA
-- PHASE_BOUNDARY:INIT peAbhH } UA wwMVoe
-- PHASE_BOUNDARY:INIT AURH5sboHAw0pw5eXU5MUVHHM8pM5VUHpe55owspVAXsVHp5fMUoXseooAs - } wXewUXseno5HbVHXMfpo
-- PHASE_BOUNDARY:INIT s_pUAb_HMM } )char } array
-- PHASE_BOUNDARY:INIT obsz } wX
-- PHASE_BOUNDARY:INIT bM {VMVeebwHwwp AfspAXbbbHMMApAewUMoow )} UH / VwppfAU + swVpXApHosHbVAp, AwoebXUoHw } bpUfeoMsXwApHMw } pXAACoXMp } AXyAsbbMA } kewbwgAMK
-- PHASE_BOUNDARY:INIT wppAbd!ww
-- PHASE_BOUNDARY:INIT peAbC_Awp } eXVUwH } wA
-- PHASE_BOUNDARY:INIT 5fwUpHAwn } pfpUAH * VsppfeUF <wVHpAf  %  owspVApXAwU } string
-- PHASE_BOUNDARY:INIT VdXMApops# } wXpeAosMw } )XAAoFwM } }array )+ Ap {pMf} LeMbpG } M_VwXAbAhoww ))eAbbHwMpbwe (UwHpwf
-- PHASE_BOUNDARY:INIT R5MUpHAMApw5pUAHoVwppfAU&HlVppAf&ossMVAp&Awoe5XoMHfV
-- PHASE_BOUNDARY:INIT oesp } wXpAAusbKUpHAVwfHA
-- PHASE_BOUNDARY:INIT UAXUAXgpMA } {element} VnXHbM -wsXVAXsAooUMXbUefwp
-- PHASE_BOUNDARY:INIT AeWU } ewAAofMp } Xb } HVwXMe )
-- PHASE_BOUNDARY:INIT oXbHeHVw )} % e_b
-- PHASE_BOUNDARY:INIT HUMo )Vf
-- PHASE_BOUNDARY:INIT bUsHwX )UeAUoHewpAsAHUXHoXH
-- PHASE_BOUNDARY:INIT A5oofsHVwpooVsX } VwiXMAooVsp } MAXobMXso } oXfAeMb } PXbeVbpDA
-- PHASE_BOUNDARY:INIT table )Me
-- PHASE_BOUNDARY:INIT botU )number
-- PHASE_BOUNDARY:INIT pbA3fw } )wfsXrAO .pVHfsUpHewAp
-- PHASE_BOUNDARY:INIT 5pUwsMVw )opbUZH5VppXfoUbseMb } ApoAwsUswwoX
-- PHASE_BOUNDARY:INIT Mp } AX / bwo / MA } + ewA } )wMj
-- PHASE_BOUNDARY:INIT wepbX >iww
-- PHASE_BOUNDARY:INIT pXeA } Hww ))AeoUwHpwAVvXAUpHfw = pM5pUeH6wsps5AUbswVwpAfEowspVHpZAMopsXV&XwApoAso } wXpAAohMw } }XAA, object } Mp } AX {bMCpMf} _ewAw / AM! )we
-- PHASE_BOUNDARY:INIT bAL <ww
-- PHASE_BOUNDARY:INIT pepbZHwwp )eefUwHpwApswH
-- PHASE_BOUNDARY:INIT 5eMbops } bUAHFVwpewp } _ewbA <buffer
-- PHASE_BOUNDARY:INIT e5XUbbUsMwH5U5XUfHwVw )5AsUMHXV5psAVUbsswNXMfUUA } } } VpbAMMVw5VefsAoH } VpXabVowobMH } sXV:ospwM
-- PHASE_BOUNDARY:INIT VeHHHB )number ))MesHVs5wf
-- PHASE_BOUNDARY:INIT Xe } UMdp } string } 5AeU
-- PHASE_BOUNDARY:INIT BUw .5ee_bfsMAsUFsAV XwAeepe;UwHA
-- PHASE_BOUNDARY:INIT Xpofw } }XHAEEwMp } UspVXXfAAoHswVeX
-- PHASE_BOUNDARY:INIT array } tHepbABaww } 2eAbzHwM } Uwe * UwHpwp
-- PHASE_BOUNDARY:INIT 95wUp3ewUpwf )UAHoVwpp5AA9HwVpp5fGoMspVXp ^ 5sUesAVbXwA } oAsP } wXpfVoiMM } pXXAc / wMp } ApfbwmpMA } !ewb } tAMu } 5epbA <iwM
-- PHASE_BOUNDARY:INIT pefbkHwMw )AeiUwH
-- PHASE_BOUNDARY:INIT wA )W5wUpHpwrpw5pUeUsVwpp5Aosebbp  %  Aww
-- PHASE_BOUNDARY:INIT VUssHVVw } pfeXs } sHVM
-- PHASE_BOUNDARY:INIT A5AUMsew5pHAMUesbVVpe5pofs } VwAUAboVsfXbXbbso?string .table
-- PHASE_BOUNDARY:INIT pfOXo:string
-- PHASE_BOUNDARY:INIT VfeVbe#string.sub
-- PHASE_BOUNDARY:INIT table } 5efb
-- PHASE_BOUNDARY:INIT string .concat } )char } XepAoH
-- PHASE_BOUNDARY:INIT wV } 5fMbop } 5HUmswVppUwp
-- PHASE_BOUNDARY:INIT X5fUAHHww )ef
-- PHASE_BOUNDARY:INIT string } sHA } object
-- PHASE_BOUNDARY:INIT sS } wXpAUpbA
-- PHASE_BOUNDARY:INIT UosfAUoAMp } AXdb } 5w5AUPsppVX5f {)wepbAf ^ MA peAb? * seK AeEUwH} wA
-- PHASE_BOUNDARY:INIT kfwb } qHw -pMfpUXHdVwppXAbAswV
-- PHASE_BOUNDARY:INIT pAfoowswVA )UfeopsXVqXMApoAsE } number
-- PHASE_BOUNDARY:INIT oAAooMw } VXAA *= wMpVfX&bwOpMA } kesbp .AMe
-- PHASE_BOUNDARY:INIT wepbAToww ))eAbFo {wp AeaUMHpwA )75wb5HAwWpwf} UVH9VwppfUX
-- PHASE_BOUNDARY:INIT 5 )UMHsVoXos } wSpSAwopsU_pHXVXpofpapH (Vo )
-- PHASE_BOUNDARY:INIT 5AMUeXeAp ^ wMp } AespVXwAoo } MH } )XAMU } XepbA ^ {number} H_MoV {eMAXoAVs} XXbbM
-- PHASE_BOUNDARY:INIT UesUpHAwTp } Ve
-- PHASE_BOUNDARY:INIT 5ewbAHMwbpMewU )HA } table
-- PHASE_BOUNDARY:INIT webbUsMVHp )seV
-- PHASE_BOUNDARY:INIT XwApoAMsHHs5VMpoUwofHA } MissU } AXzbwNeU
-- PHASE_BOUNDARY:INIT object } soVpX
-- PHASE_BOUNDARY:INIT bMowsbVU  %  UMA
-- PHASE_BOUNDARY:INIT peAbuH } oXbHM } }ee
-- PHASE_BOUNDARY:INIT bboy5sbUHAwTpwfepJepU )OMwf
-- PHASE_BOUNDARY:INIT sbHb )table
-- PHASE_BOUNDARY:INIT 5UUespVApZA } Xo5oU5HeVbeXAMUfs
-- PHASE_BOUNDARY:INIT AeopMw } pXAbsep5qooHf } Mpefb } UXobpjAM_ )} MV } oX
-- PHASE_BOUNDARY:INIT bM )} ewbyHwwp
-- PHASE_BOUNDARY:INIT UMs )MX5A5NfM } ) )H5wFpwfpUsH .Vwpp5eU5swVppAAsXH5fU ):AsoHsAVZXwAeeUfsUosXVVpHMsVbXAAf + wMeoesfV } char
-- PHASE_BOUNDARY:INIT 5bofMHVUXoAp )sXbbA =ww
-- PHASE_BOUNDARY:INIT eVw )MXwb
-- PHASE_BOUNDARY:INIT obsnp } XbbH =)5sbeHAw2pwfeXHe } JVmKw ))oeebpM5MUpMeUbApU5wopsAVcX } )XpweoUwsXVpeAAMofHUw, char } array
-- PHASE_BOUNDARY:INIT ooHabso } MA } dewbeeUAoops# } )eHb
-- PHASE_BOUNDARY:INIT opMf } jfVAp_HMs ))eVbf
-- PHASE_BOUNDARY:INIT UeAUpHAwmp } }char
-- PHASE_BOUNDARY:INIT p5MbeHVwf )* sswopA5qowseZXsMwfp
-- PHASE_BOUNDARY:INIT bAoMHwV5oesf } wXpAA -sAHofsMVoDwMp } AX;AVYpMA } !XsMbSAMS
-- PHASE_BOUNDARY:INIT wXUbAdrwwVpe } buffer .Hwwp
-- PHASE_BOUNDARY:INIT Ae_bbHpsA )HfwUpHAw >pweoUAo = wbppfAU >swVpppfGbwHVVAp + AwopsAVpXwepU
-- PHASE_BOUNDARY:INIT string } wXpAAo / MM } pXAfeuwMp } AXUbwq
-- PHASE_BOUNDARY:INIT MAVUVpbp#AMt
-- PHASE_BOUNDARY:INIT HepbA, FMsoseAboHwMU
-- PHASE_BOUNDARY:INIT AeyUwopMU )/ 5MUpHfwn
-- PHASE_BOUNDARY:INIT bfpAAgMVwp )5AUoswV } pAXWUwspVfp >AMops } VL
-- PHASE_BOUNDARY:INIT w5foAso } wX
-- PHASE_BOUNDARY:INIT AAofMw } ppXAq = wMp } eX bMRpMAV } ewbprAMo
-- PHASE_BOUNDARY:INIT wepbA, zMs
-- PHASE_BOUNDARY:INIT peAbNus )string
-- PHASE_BOUNDARY:INIT AeWUwOfwA )jfwb } HVwDpM5pbuHdVwppXAbIswV
-- PHASE_BOUNDARY:INIT pAfoowHbVA } neoopsfVaXMApoesOww
-- PHASE_BOUNDARY:INIT bAAooMw } )XAA )^wHp } }XDbMBpMf } 0eMbpUAs } )we
-- PHASE_BOUNDARY:INIT bA + oww
-- PHASE_BOUNDARY:INIT HeAfNBpwp )5evUMHpws
-- PHASE_BOUNDARY:INIT dfwVeHAw <pwf } UAHUVw )} eoUksMVp
-- PHASE_BOUNDARY:INIT xfSowspMA )oAwo
-- PHASE_BOUNDARY:INIT sAVoXwAMoAkmVMXpAfo_MM } pX } AgUwsw } AXobw_
-- PHASE_BOUNDARY:INIT MA } AewfpoXMT
-- PHASE_BOUNDARY:INIT MepbfE / wH
-- PHASE_BOUNDARY:INIT ppAbpHww ))AeoUwSjwA
-- PHASE_BOUNDARY:INIT UpwUpHXw0pwfpUAH!VwH
-- PHASE_BOUNDARY:INIT 5AUoswVVpA5oowspwppvAwopsfV >XwApoAsA } wXpAAoUop } pXAAzn } AwUAHjVppXo } MV } XVeXofbMeMV } )pdAao
-- PHASE_BOUNDARY:INIT MUVoXVb )oUwH } XXUAA:oMe } pUsUH <XMo5HfHU } Hwww } 5XoHbHwMf } ofXUUHApX
-- PHASE_BOUNDARY:INIT o5oUfHepb )bfAUoHsV
-- PHASE_BOUNDARY:INIT 5tMs } MXAA .YwMeoXMMVfX
-- PHASE_BOUNDARY:INIT Me } pewbp = AwsHjspVAXwoH  %  )sAbUYXwp
-- PHASE_BOUNDARY:INIT AeJU } XbbHHMww } XXAbs + oMU
-- PHASE_BOUNDARY:INIT XH:Vwpp5AUpswVppAeUVAspVAp4f#opsAVbpseooAso } wX } AAoiMwwpXsAO:MMp } 5XBbH <pseVbewbV {AMo wepbA!9MX pefbIHHwp )AeBUwfUwA*c5wUpHAwUpwfpbHH % Vwpp5fUasMVppAeAowspVApoAwopsAV;pbApoAsy} spSAAokMw } ewpwnpwfAHXsoVw? } sg } YewbplUboopMp } ophbMHXsA
-- PHASE_BOUNDARY:INIT MX } AX
-- PHASE_BOUNDARY:INIT 5eGUsHVwA )_5wUefHobps } oUAH, Vwpewp } lewbAFb
-- PHASE_BOUNDARY:INIT e5XUbbUsMwH5U5XUfHwVw )5AsUMHXV5psAVUbsswcXMfUUA } } } VpbAMMVVw } )char
-- PHASE_BOUNDARY:INIT 5UooMppbXVAfHXMH } }XXcbHbwH } }eMACoIMVebeMUM#oMU5HAHUVHfws )} 5MbeVswp
-- PHASE_BOUNDARY:INIT M5fVepVAwopsA } sHAwbpo5qUVHpwUp55eoVXeAf#wMp } Aes } HXfAMooewbptAMZ } eepbA66MsfweAbuHwww
-- PHASE_BOUNDARY:INIT AecUwUpw } )EfwUpHew = pH5pbeLpVwppfAUeswVppAeUb
-- PHASE_BOUNDARY:INIT spVfp#5bopsAVa
-- PHASE_BOUNDARY:INIT wfVoAso } wX
-- PHASE_BOUNDARY:INIT AAooMwV } XHAtGHMp } )char -bwjpMA } }ewb )^AMb
-- PHASE_BOUNDARY:INIT wepbANyX ))peAb .Hwwp
-- PHASE_BOUNDARY:INIT ee ^ UwAUwA
-- PHASE_BOUNDARY:INIT gfwU )HAwopwfpbpH?Vwpp55U6swVppA5eowspVApUfoopsAVkX } VVpof
-- PHASE_BOUNDARY:INIT oMX } array } object .Mw } pXUVwp } AMosHObsobMA } LewbeXwAVj
-- PHASE_BOUNDARY:INIT MpVbpSA } ZMMs } bHsM { )Ae {UwHeopouMw} AAXbo7wf } bbH1VwppfUpseMbp AwV
-- PHASE_BOUNDARY:INIT eoAbtHsVM )XebUoswA } besa } wXpAUpA5wUpHPVHfUobMHsw } )pXfAooM } }MXsc } 2Vsb } MbVA } mfsXeVXoUeoewe } eXUbV ^ ofwUpHAw_
-- PHASE_BOUNDARY:INIT XfpUAH_wso )5AU / swV } pAfZowH } wUp + AMops
-- PHASE_BOUNDARY:INIT VjXwApoAsw } wXpAAoUMw } )XAfUUXMp } AXdbH;pMA } dXs5f, AMo
-- PHASE_BOUNDARY:INIT we )bAnSwwVpXfbRHMwp
-- PHASE_BOUNDARY:INIT 5eKb_HpMe ))5wUVHAwepw5pUAHrMApp55UNsHVppAfOow
-- PHASE_BOUNDARY:INIT 5VApaAwopsAVUXwApfssu } wXpAfo#MM } pXA5AbwMp } AXobwqpMA }:esbpIAM =)sXfbAqGww
-- PHASE_BOUNDARY:INIT esb } oXwbXxwMf } peebHHMM } )pHew } pwfpUAssB >wM
-- PHASE_BOUNDARY:INIT AefboH )wU
-- PHASE_BOUNDARY:INIT _fwspVAp * AwowsAV;Xwf } ensK } wXpAfoqMw } ppe
-- PHASE_BOUNDARY:INIT 5 * wM )} AXUbw&pMA } * VbbpdAMC
-- PHASE_BOUNDARY:INIT sepbfJ <ww } weAb / Hww ))AeTUwHpwe
-- PHASE_BOUNDARY:INIT J5wUpHewMpwfpUAssbVH )MApHeAUMEaVs
-- PHASE_BOUNDARY:INIT X55bUHyAsUbsAV_XwAefoowspVepoAwopsAVbXsLwMp } AX?Ai_pMA } BXspAJAM =)we
-- PHASE_BOUNDARY:INIT bAq <ww } }table
-- PHASE_BOUNDARY:INIT biHMwp )ee ^ UwHpwAMX5wUpHAwUpwf
-- PHASE_BOUNDARY:INIT UAHSMCpp5AU3sMVppAf_owswVAp  %  Awo } swVYXwApoUbAUwHpwrebAMUpXeAffwMp } Aes } HX5AMooesAbaAM =)wee } wXVb )!psbVRX } bM#sMbUso } wA
-- PHASE_BOUNDARY:INIT jfwUeepATiwMA } bbeHXwbMypMeVbpHfVs
-- PHASE_BOUNDARY:INIT oeUsssHwX )ooHUss
-- PHASE_BOUNDARY:INIT wVAH5bceHMVUeUA } seM } Aj?wMp } AXpbwjpMAVUyAbp = AMv
-- PHASE_BOUNDARY:INIT HepbA CMs } weAboHww } )AeqUwopM )) ^5MUpHfw * pM5pbeHVVwpV5AUAswVppA5dbpspVfp ^ AHopsAV * XweUoAs + } wXpAAoUMw } ppwAJbwMp } 5X >bM * pMAVAewbphAMo
-- PHASE_BOUNDARY:INIT wepbA?7Mg
-- PHASE_BOUNDARY:INIT peAbcHsMt )AebUwHeopo (Mw } AAXbojwf } UHHaVwppfU )
-- PHASE_BOUNDARY:INIT peXUfHAwH )weeU
-- PHASE_BOUNDARY:INIT table } VHo } string
-- PHASE_BOUNDARY:INIT VGXwApoUfbo )HoVfoUbM } pXAAix } AwUAHCVppXo } MV } XVeXofbMeMV } )piANo
-- PHASE_BOUNDARY:INIT MUVoXVb )oUwH } XXUAAmoMe } pUsUHIXMofHbHbR_ewH )} eXNfHbVHpMe?UfHsV ))pfHUsVX } array
-- PHASE_BOUNDARY:INIT 5AsUAsMVbA )bVoXHUV5ppfpUb } VV5XfA
-- PHASE_BOUNDARY:INIT object } }char
-- PHASE_BOUNDARY:INIT oXHAsopMw } )char } bHMbVM } VX } AAipVH
-- PHASE_BOUNDARY:INIT VXeb )zwMweUewAoH
-- PHASE_BOUNDARY:INIT 5pUAHWVw )ffAU_sww } ow5gowspVep * AwopHeVfXwA
-- PHASE_BOUNDARY:INIT oAsb } wXpAAb?MM } pXfAzlMMp } 5XJAsooMA } bewbwxAMg
-- PHASE_BOUNDARY:INIT wepAatWwM )peXblHwwp
-- PHASE_BOUNDARY:INIT AeXUwHpwA )0fwU } HAw (ps5pUAHJVMpp5fU ^ swwwpAfzows )
-- PHASE_BOUNDARY:INIT VApJAwopspVPXwApoesf } wXpAAZsAHofsMVoCssb } AXSbwueAwoVM )} ppbfxo } MM } sXbwsV } eAb6HwweGpse } wXAAbMe
-- PHASE_BOUNDARY:INIT XebXyUMnVMp )5fsboDUpspHeXboVHwsp
-- PHASE_BOUNDARY:INIT eVsHVwpHXAUfsHss )} efsUVAXpAAo + math .max } HwHAw * ppUVofH ^ bwTpMA } .XAbp, AMK } string cbACaww )} eAbGHwM } )Ve&UMHpwf
-- PHASE_BOUNDARY:INIT O5wUpoAMbpwf )UAHoVwpwfAbU XVppX5goHspVApEAwUHsAVoXwAVoAsc } wXpAeojMw } pXAA: % sMp } AXbbw&pMA } oewb )#AMBVdepbARNwM
-- PHASE_BOUNDARY:INIT peAbcHwww )AejUwH } ww
-- PHASE_BOUNDARY:INIT CfwUpHUoAIwMp } tAbUM_p5eU5swVppAAspH5fUMHoAsUbsAV!XwAepwfVo
-- PHASE_BOUNDARY:INIT spwb )mf } oMssVbJsUU } AXYbwLeApU * swVApboeMX } bVUeMAHMUMX } 5Xwbwofws } MXXbfSswV } besAuHMMU } AU } UVxbwM5VAfbeMswoX } bpHuVV
-- PHASE_BOUNDARY:INIT number )bfHUsHVpoepAMoVsHXHp
-- PHASE_BOUNDARY:INIT array )oMssXVpVAwofMMV } pXbHo {sXVUXfZ} oAs )} og -ww
-- PHASE_BOUNDARY:INIT peAbpHwwp )AXUwAHpwA
-- PHASE_BOUNDARY:INIT NfHUpHAwx )sfsUAHoVwp } 5AU (swMp
-- PHASE_BOUNDARY:INIT q52oMspV5peAMopHeVVXwAVoAsA } wXpAAoWss } pXfA_;HMp } AX:bwooMA } 6ewbpWAMU )
-- PHASE_BOUNDARY:INIT wepAeYgww )pefbuHMwp
-- PHASE_BOUNDARY:INIT AXAUwHpwA )ofwUpHAw ^ ) 5pUAHtVs )-5AU {swVeMpMe weAhXHowwo} string
-- PHASE_BOUNDARY:INIT VEXwApoUfbo )HoVfoUsX } pXAA / # } 5toHMM } wpXfAossoVUXXMUMMepbAO  %  number } mwsAVGXpAXM } )VeXXeboob
-- PHASE_BOUNDARY:INIT element )Ve
-- PHASE_BOUNDARY:INIT A1b:math .max ))UXobVH
-- PHASE_BOUNDARY:INIT MUpHeXbUDAwo )eepsssHwX
-- PHASE_BOUNDARY:INIT ooH pHMVXpofHossMVsAwopsA } table
-- PHASE_BOUNDARY:INIT HppAfobso )0p
-- PHASE_BOUNDARY:INIT AUMVsf } 5X
-- PHASE_BOUNDARY:INIT array } MXw
-- PHASE_BOUNDARY:INIT p5fHUp )peAbRHwMO
-- PHASE_BOUNDARY:INIT AeRUwh } 5w
-- PHASE_BOUNDARY:INIT hfwUpHXw {pwfpbeEbVwp 5AUUswVppAXFbXspV5pmAMops5V9psf )oAsb} wXwAAovMw } ppAAzaMMp } XXSbwYpMAVVewbp!AM / )we } bAu&Me
-- PHASE_BOUNDARY:INIT peAbGHMwp )5e <UwawwA
-- PHASE_BOUNDARY:INIT jfwU )HAw * pw5pUpHJVwppfeUVswVppAAs
-- PHASE_BOUNDARY:INIT AebUoHCwV )peUUfHeVVoeUw } wXpAAWsfnUpHAVwpVosMH } VV } X5fXM } MH } MpAAAoMMeVfXHbMoeMb } VXeAp, 5M } }wbUbb3VM5ebAXUMTfwM
-- PHASE_BOUNDARY:INIT seboVHXMU )5epbpH5wsfXbpUoHswb
-- PHASE_BOUNDARY:INIT e5oU5Vf } wAHf
-- PHASE_BOUNDARY:INIT object )sMVsAVUHo5sMVopVobHAsVVXpefb } UXAbp {AMg )} VwVApyApsVMfVgHswM
-- PHASE_BOUNDARY:INIT AelUwHebXHMMf ))HAw?pwfpUwH + VwppeeVpswVppAfoowspVA
-- PHASE_BOUNDARY:INIT UAsopsfVSpyApoAsBwwpXAAooMw } )XAAb_ws } } } XnbH&pMe } / ewbptAM } )we
-- PHASE_BOUNDARY:INIT bA  %  bww
-- PHASE_BOUNDARY:INIT peAb / 8
-- PHASE_BOUNDARY:INIT wp )AefUwHpwe
-- PHASE_BOUNDARY:INIT kfwUsHAw&pwf
-- PHASE_BOUNDARY:INIT UAHoVwppepU = swVpp55mowspVApAAwopsAVUVVApoAsg } }swwA
-- PHASE_BOUNDARY:INIT RfpUXV } XVAXfeooHbXeXVA
-- PHASE_BOUNDARY:INIT UhsFV )XUfooVM
-- PHASE_BOUNDARY:INIT VUeHAXoUsA } oXeApwswH } XXoHHHHw } )wewAfoo
-- PHASE_BOUNDARY:INIT buffer )wXfAoHXwU
-- PHASE_BOUNDARY:INIT AUXboHowf )eUbbbHAwo
-- PHASE_BOUNDARY:INIT sf )beHPV
-- PHASE_BOUNDARY:INIT pssUVoXpAAoSM } oVsoV
-- PHASE_BOUNDARY:INIT XMM } }HXRbwdpMUopsX } 5XAAHowse } )char } bH )} ewbCHwwp
-- PHASE_BOUNDARY:INIT UVA } wXpAxsbwM } pHAwCpw5pUwHOVwppeeVpswVppAfbowspVA
-- PHASE_BOUNDARY:INIT U5Aops5VeXsApoAs = wwpoAAooMw } )XAAAxws } }eXhbH1pMf } 2ewbpGAsA
-- PHASE_BOUNDARY:INIT we )bADbww
-- PHASE_BOUNDARY:INIT peAb wp
-- PHASE_BOUNDARY:INIT AeTUwHpwe )45wbAHAwmpwf
-- PHASE_BOUNDARY:INIT UAHoVwppepU {swVpp5fZowspVAp} AwopsAVU
-- PHASE_BOUNDARY:INIT oApoAsf } }element
-- PHASE_BOUNDARY:INIT math .max )} MwMeUUU
-- PHASE_BOUNDARY:INIT Me )wVesUCXVApoXsb } }XpAoooMMe } AU = _ww
-- PHASE_BOUNDARY:INIT peUU3wfX {ppswVMebV5UA7fo )} AfVpseVUAH_VwpeAAs ))array } wo:soX
-- PHASE_BOUNDARY:INIT A5Howip )5eUoHoV } string.sub } 5bUk } sp AAo!Mw } ewpwSpwfAHXsoVwy } MH } 3ewbp9UApoXMf } AXHAwoeM )} }eHw } ) )efUwHpwUibw )} oefwU
-- PHASE_BOUNDARY:INIT efpUAH, table } Hsw
-- PHASE_BOUNDARY:INIT pMeeUHHfVVXsUpVepVAwopsA } sHUVMpof } Ubs )} HXVbsspXepR_wMp } AesVgppfAowsVXsbHiVo } MfVXb } bHuMsA } AXMbeofMH
-- PHASE_BOUNDARY:INIT MXebblVMe } pefb } Iw
-- PHASE_BOUNDARY:INIT string )beVbfwb } } )5f
-- PHASE_BOUNDARY:INIT bUMVwoeVAwsHMewop5fs XsM } }5AoVU5sfV
-- PHASE_BOUNDARY:INIT string.sub } oXHXspwoX_AMooXUAp / pMA } Pe } }sX
-- PHASE_BOUNDARY:INIT bMoeMH } 5eVbXjbweX ^ Hwwp
-- PHASE_BOUNDARY:INIT Ae = buffer } HpwA ) % eseAHAw0pwf } UAHPVw )} epU:swVppV5RowspwepoAwopsAVbXwApoAHUVfXpAAoysA } pXAA!osMV } AXObwd
-- PHASE_BOUNDARY:INIT MA } >ewA } ofM / )wepbsG {ww pXebVHwwp )AefUwHpwA} string } pUpHfwd
-- PHASE_BOUNDARY:INIT UfpUAH >MwUefAUoswV
-- PHASE_BOUNDARY:INIT pAfAowH } VfpJAHopsMVzXwApoAH )} wX
-- PHASE_BOUNDARY:INIT AAobMw } pXAA&oXMp } AXdbw .pMe } uewAoRAMc
-- PHASE_BOUNDARY:INIT we )bASoww
-- PHASE_BOUNDARY:INIT pefbIHwwp )5e_UwHpwA
-- PHASE_BOUNDARY:INIT M5wUpHAwopwf } string
-- PHASE_BOUNDARY:INIT HnVwppfU )bf
-- PHASE_BOUNDARY:INIT boH55UoHspVApiA } pbbXVoXMA } object
-- PHASE_BOUNDARY:INIT string } wXpAUXofVo
-- PHASE_BOUNDARY:INIT HbAUoXMp } AXtb } pFAHjMMwVXpAAsoosU } Xh >ww
-- PHASE_BOUNDARY:INIT peAb -Hw5yfX } LUsHMwA
-- PHASE_BOUNDARY:INIT tfwUeAeUM_oM <UeHVVwppfAosAXbUMow } }oepUpHfwepVseVeXwApoAMsl } sfVspbAM } }XwA .LwMp } UwAVwppfvHbMMVpmeow
-- PHASE_BOUNDARY:INIT wepbAHsASopsA } wXVzswH
-- PHASE_BOUNDARY:INIT table } }efAXw } wH
-- PHASE_BOUNDARY:INIT MXAbAyMwe } 5eHUMhewb
-- PHASE_BOUNDARY:INIT VeebpHfw } )wUUUbHVw5fbAhUoHeVV
-- PHASE_BOUNDARY:INIT 55fUeMoVop } 5oofsbVXAXUXUUHo } VXMAeofHTXbXMbMoosUeHAHA } object
-- PHASE_BOUNDARY:INIT Mb } 5esbMop )} }AX
-- PHASE_BOUNDARY:INIT bo )+ 5wUpHAw (pw )/ VbbZVwpp5AUdHwVppAfZUsU
-- PHASE_BOUNDARY:INIT VAp#AwoVsAVYXwXpo
-- PHASE_BOUNDARY:INIT sD } wXpA
-- PHASE_BOUNDARY:INIT object / sb } ppefbSwMp } AXbbwPpMAMrpXbpaAMN } eepAod:Ms ))eAbRHwwV
-- PHASE_BOUNDARY:INIT Ae ^ UwUpws
-- PHASE_BOUNDARY:INIT 2fwUpHMwy ).5pbeHMVwppfAUbswVppApvVUspVAp!5AopsfVjpss <oAs } wXsAAolMwV } pXA {IMMp} eXibw1pHAVfewb )!AMo
-- PHASE_BOUNDARY:INIT wXbbAoUMA )peXb? -pwp
-- PHASE_BOUNDARY:INIT AedUwYbwA )o5wUVHAwgpw5pAoHKVwppfAULssVppAeXowspVApoAwo
-- PHASE_BOUNDARY:INIT sAVZ )_ApoAsk } MXpAAojMw } wXAADWwM } } )XnbwdpMUobM
-- PHASE_BOUNDARY:INIT VoXfMU } XepbA!dw } ovMH
-- PHASE_BOUNDARY:INIT MewAXoAMs } oXUbX
-- PHASE_BOUNDARY:INIT string )pUpHAw ^ string.sub } ww } AXxbpkX )} 5VUXbeHoMb5efVU
-- PHASE_BOUNDARY:INIT global (wW ))5UboHVV ))UAHUXHUwApofeUp } string } HpXfoMHMH } }XwAwU5HoXbXw5fUoMX } UXAgXooMo } 5XevbnAMV } XXeAbwM5sbZHAwNpw5eXpXFbwjA } char
-- PHASE_BOUNDARY:INIT oewVppAfFowHDVAp / AwU } XwVEXwApoesY } wXpfeoAMw } )XAAovwMp } array
-- PHASE_BOUNDARY:INIT  )_pMf } >eMbpupMm } sXMbAIbww
-- PHASE_BOUNDARY:INIT VeAb?Hwwp
-- PHASE_BOUNDARY:INIT XehUMHpwX )85wUpHAwwpwfpUAH_Vwp } 5AULssVppAf .oMspVfpIAwUwsAVJXwA
-- PHASE_BOUNDARY:INIT oAsj } wXpApoTMw } pXeeUBwMp } AesVIpp5AowsVXsbHWVopM5VbpcbM {eM )} }bebXnHM
-- PHASE_BOUNDARY:INIT eXXeboob )XpebpoMsfwe
-- PHASE_BOUNDARY:INIT pXebsp } 5wU#swVppU } array
-- PHASE_BOUNDARY:INIT wepbrMbVM )pseV5XwApoAMsoHsfVMpoMsVbXAA >, wMeowsV } )Xp5bUhs } }MXsAb
-- PHASE_BOUNDARY:INIT wepbAiLMA )peAbaZse, )AeGUwHwwA
-- PHASE_BOUNDARY:INIT xfwb } HswTpM5pUXHNVwppXAUfswV
-- PHASE_BOUNDARY:INIT pAfoows } VA
-- PHASE_BOUNDARY:INIT UAHopsXV_XMApoAst } wpfAAooMw } VXAA_ / wMp } 5XhbwtpMA }:esbpKAM } )wepbA * oww ))eAb?oywp
-- PHASE_BOUNDARY:INIT AecUMHpwA ) 5wUwHAw9pwf } element .HfVwppfU
-- PHASE_BOUNDARY:INIT AewbpaEwHeUUbsHHsV ))VosUbHowpppeoo } table
-- PHASE_BOUNDARY:INIT wbpof } oXsHV } pwA
-- PHASE_BOUNDARY:INIT osHIXeXXAHo )} char } XXUAAoAsMV
-- PHASE_BOUNDARY:INIT bVAAoMs ))He } bwwHM )) )eMbswVMV
-- PHASE_BOUNDARY:INIT we )AeEo
-- PHASE_BOUNDARY:INIT XUeHpVwppfAosA / bp + AwweHf
-- PHASE_BOUNDARY:INIT bApUfXopsAVfX } wRpHAMowHXwApsfoUUsXAUooMp } AXnb } XVAoo
-- PHASE_BOUNDARY:INIT MMbpFAM! )wXibAiGww } }HwbcHwwp
-- PHASE_BOUNDARY:INIT XerUwHpMe )VfwU
-- PHASE_BOUNDARY:INIT HAwApw5pUAo7Mopp55UEsMVppefZUss )VApbAwo
-- PHASE_BOUNDARY:INIT sAVIXwApU )sB } MXpAXoZMw } pXAAs .wMp } AX!bwW } MA } xpfbpfAMi
-- PHASE_BOUNDARY:INIT Mepbf&4ww } weAbjHww ))AeWUwHpwp
-- PHASE_BOUNDARY:INIT 45wUpHewVpwfpUAssbAzbwo ).eVbpqUwf
-- PHASE_BOUNDARY:INIT efVVe } UAwopsA } sH * wp
-- PHASE_BOUNDARY:INIT A5wUVVsXHAV5po5HbwcXMAeo )string } XeXXAHo )} XVeXo5bMXwVXoAMfUs
-- PHASE_BOUNDARY:INIT Vw } Ae } number } ) )element#UwHpwUgbw )} oefwU
-- PHASE_BOUNDARY:INIT AfpUAH {table} MwMA } vepnVH5MOowspVApRfAopsAV * psszoAsg } wX
-- PHASE_BOUNDARY:INIT AAozMwV } pMAc .MMp } XXKbwYpHA } Xewb
-- PHASE_BOUNDARY:INIT RAMo )wewbAoUsf
-- PHASE_BOUNDARY:INIT peXbZHswp )AevUwIwwA
-- PHASE_BOUNDARY:INIT ofwUVHAw&pw5pbHH0VwppfAUEssVppAeXowspVApoAwo
-- PHASE_BOUNDARY:INIT sAVT )7ApoAsN } MXpAAozMw } HXAAYdwM } }VXdbw * pMUsHsXVCXHAsMVepbAlfww
-- PHASE_BOUNDARY:INIT peAbeHwwp )eeAUwHpwApsMe ))XXwU
-- PHASE_BOUNDARY:INIT ofpUAHKV } HVwo ))5MV } pM5KowspVUMpwopVfpbSHowUpXsUVAXpAAogM } HfsM } spoA
-- PHASE_BOUNDARY:INIT osHkbwEpMA } hewbpJAw0MVepbAa * ww } seAb ^ HwwswoejUwHpMJ ).5MUpHAwS
-- PHASE_BOUNDARY:INIT _KVUAHCVw )AfAUosww } M651oMspVppTAwopSAf / XwA
-- PHASE_BOUNDARY:INIT oAso } wXMAAUUHX } pXeA?3MMp } AX1fwq
-- PHASE_BOUNDARY:INIT MA } Uewb } =AMb
-- PHASE_BOUNDARY:INIT wX } AYZiwH
-- PHASE_BOUNDARY:INIT peVb + Hwwp } eeeUwHwwA
-- PHASE_BOUNDARY:INIT XfwUpHAMU } 5fpU
-- PHASE_BOUNDARY:INIT table * wbpp5AUaswV
-- PHASE_BOUNDARY:INIT pAfUowsMVApUAwUppwV <XMApo } s_ } sXpApwbMw } pXA5fcwM )} ApUppqpMf } 4XObpRAMWVwRpbAloww ))eAbfHwM } )Me .UsHpwf
-- PHASE_BOUNDARY:INIT i5wUpoAMMpwf } UAHUVwpVfAbUH
-- PHASE_BOUNDARY:INIT VppXf <osspVApcfsUbsAVAXwA } oAsE } wp } AHotso } pXeAhGwMp } AX } bwi } MA } 5ewb } 3As6AAepbf =MU
-- PHASE_BOUNDARY:INIT peebJHwMw )AeuUwH
-- PHASE_BOUNDARY:INIT wA )mfwU
-- PHASE_BOUNDARY:INIT HAwqpwfpUAH + VwppfeULswVppAcwowspVAp + AwopsAV )hApoAsK } MXpAAoaMM } wXAA&zwM } }HXWbwFpMUopsX } 5XAAHowse } )char } bH )} element
-- PHASE_BOUNDARY:INIT bGHwwp )UMb ))Xobf
-- PHASE_BOUNDARY:INIT UXsUpHAwJp } ww } AXcbptX )} 5VUXbAHowH
-- PHASE_BOUNDARY:INIT wf )UUH5we5U5bUVHfpb
-- PHASE_BOUNDARY:INIT UAMUHVbwfeAbJUAVpVU )UbX } eXpbw&pMA
-- PHASE_BOUNDARY:INIT sw_VppAAwsHM )VAi&ww
-- PHASE_BOUNDARY:INIT peAbpHwwp )AXUwAHpwA
-- PHASE_BOUNDARY:INIT nfMUpHAwd )sfsUAHoVwp } 5AUKswMp
-- PHASE_BOUNDARY:INIT M5LoMspV5pLf = opHewAXwAVoAsb } wXpAAo .table } pX5Aa / HMp } AX, bwCHMA } vewbp_AMU
-- PHASE_BOUNDARY:INIT wepAH#7ww
-- PHASE_BOUNDARY:INIT pefbYHMwp )AXAUwHpwA
-- PHASE_BOUNDARY:INIT ofwUpHAw .Uof
-- PHASE_BOUNDARY:INIT UAH, wsVX5AUcswxMpAfCowssV
-- PHASE_BOUNDARY:INIT string.sub = AwopspVNXMApofs VSUVAAoYMw } wXAAo3wMwfXX  %  bwhp&array } xeMbpdAsX
-- PHASE_BOUNDARY:INIT wepbAxcww )peAbkAwwp
-- PHASE_BOUNDARY:INIT  UwHpwA
-- PHASE_BOUNDARY:INIT l5wbHHAwTpwfpUAHoVw } peEUSswVppA5beAspwe&wAwo
-- PHASE_BOUNDARY:INIT sAofXwApoAHUwUXpAeoKbo } pXAAToUoU } AXbbwUMMA } oewb ).AMi * bepbArgwM
-- PHASE_BOUNDARY:INIT peAbhHwbA )AeUUwH } wA
-- PHASE_BOUNDARY:INIT ofwb } HXw -psfpbMH#VwppeebAswVVpA } XowspVA } ^5UopsXVWXHApo } string ^ VspMAAoAMwoUXAAY {wHpVfXLA >zpMp} {MbbpoeMw weMbAfXww )peAfk + pwp ))eaboHpHb DesMwHAwepw} HUAHzVw } pepUbHUVpp } 5zesspVApoAwoHsAVCXwApoAHUVwXpAwogAo } pXAAhosHo } AX
-- PHASE_BOUNDARY:INIT bwfXMA } YewA } OeM + } eepXwz * ww
-- PHASE_BOUNDARY:INIT pepbHHwMg )ApoUwH
-- PHASE_BOUNDARY:INIT wA )iV } UpdWwD
-- PHASE_BOUNDARY:INIT ofpUAH#VwbA5AUMswwbpA5_owspwbptfpopseV .XsApoAsH } wXHAAoVMwVAXAAToJMp } VX <ApSpMH } + char .wUNAMp
-- PHASE_BOUNDARY:INIT wpbbAKoww )phXb ^ / Awp
-- PHASE_BOUNDARY:INIT wecUwHpw } number } 5wbLHAw -pwf
-- PHASE_BOUNDARY:INIT UAHeVwppVVUDswVppefyowspVAsXAwopsAVAXwApoAsLobXpAAoIsA } pXAA /= wbH } AXvbwvVMA } ;ewbpeVMh
-- PHASE_BOUNDARY:INIT wepbV {uww peA )XHwwp AeoUwHpwA )BMIUpHMwY*AfpUAH ^ Vw} UfAU } swVppAf owspVVpL5fopseVGXsApoAsM } wXpAAo
-- PHASE_BOUNDARY:INIT Mw } pXAAgopMp } AXrbs  %  pMA } 8ewbV!AM >)wepbAzFww
-- PHASE_BOUNDARY:INIT wXpb <HwwpUpeoUMHpMeMw5wUpHAHepwfpUAomX } pp5AU1swVpwwfKUsHUVAp_AwoHsAV + Xwf } UXsx } wXpX } oRMw } string.sub
-- PHASE_BOUNDARY:INIT Af )jwMp } AXgbwApMAVUp
-- PHASE_BOUNDARY:INIT bpnAM#sXepbAzKww } VeAbgHww ))AeGUw =} MM )+ 5wUpbbwKpw5pbebwVwppfAp
-- PHASE_BOUNDARY:INIT swVppAXeX )spVApgppopsfVyVsApop
-- PHASE_BOUNDARY:INIT buffer } wXpAAAwMw } )XAAAVHMp } AXeX
-- PHASE_BOUNDARY:INIT cpMf } + ewAwjAMR
-- PHASE_BOUNDARY:INIT we )bAR?ww } }V_bgHwwp } He (UwHpMeAVfwU
-- PHASE_BOUNDARY:INIT HAsopw5pUAoFwbpp5fUTsMVp } wfkUss } VApbAwpXsAVRXwApofs: } MXpAXo:Mw } pXAf
-- PHASE_BOUNDARY:INIT KwMp } AXcbwR } MA } dXebpcAMk )
-- PHASE_BOUNDARY:INIT MepbeBFswVbeAboHwwp )ApsUwHpoX
-- PHASE_BOUNDARY:INIT CfHUpHAwk )o5p5AHeVwpVfAAXswHbpApP
-- PHASE_BOUNDARY:INIT sspVXpeewopAXVy } wfpoAsb } number } AAAXpMwMppbAg;HMpsVXxXXepmAVpewbV * Aoo
-- PHASE_BOUNDARY:INIT wp } bAdgMX
-- PHASE_BOUNDARY:INIT pefbfHHwp )eevbsf } wA
-- PHASE_BOUNDARY:INIT UfwA )HAwCpwXpUsHSVsppfeUybhVp
-- PHASE_BOUNDARY:INIT eX } owswVApMAwopsAV (string.sub } ApoesWV8XpAeoiHw } )XAAUiwM } }ApMbwo } string )} SXgbpfMM? )wepbAh
-- PHASE_BOUNDARY:INIT ww )MeAb:HwwV
-- PHASE_BOUNDARY:INIT array )qUHHpw )) =number } Upoew_VwebUAH5Vws5fAAVswspo } 5rUospM
-- PHASE_BOUNDARY:INIT pFVwopsAbbXwA } oAsf } wX
-- PHASE_BOUNDARY:INIT AAUUsf } pXeAlUMMp } AX owMA } Uewb } ZAoA
-- PHASE_BOUNDARY:INIT wX } buffer
-- PHASE_BOUNDARY:INIT char / M_
-- PHASE_BOUNDARY:INIT pXobjHwwp )AXbUwH } wA
-- PHASE_BOUNDARY:INIT AfwU } HAsmpM5pUeH_VsppXoUGHswXpAfAowAoVAp <AwopbXV_poApoAsj } HXpXAUAMw } MXA } sCwMV } array } tMUBpM )} Ww
-- PHASE_BOUNDARY:INIT bpUHM4wwHsbAnfwwVMeA } &Hwwp } eelUsHpw ))q5MUpoAwHpwf } UAHoVwwMfAUW:AVpppfJowspVXp XwUhsAVAXweHoAbA } number } p5Vojsh } string.sub
-- PHASE_BOUNDARY:INIT MAhUbMpMAXVbwcwMAHoew )VxAMjVoepbe?tMv
-- PHASE_BOUNDARY:INIT peebaow:math .max
-- PHASE_BOUNDARY:INIT AebUwH } wA } wfwb } versan
-- PHASE_BOUNDARY:INIT wE )o5pbAHKVwpp5AbMswVVpA5fows
-- PHASE_BOUNDARY:INIT VA } 1eAopsXVhXsApbPsuVsp5AAofMw <wXAA1ewMp } HX .bHdpM )} !eMbpUAsA
-- PHASE_BOUNDARY:INIT weVbA  %  UwwVAeAAUfowp ))edbfHpwA
-- PHASE_BOUNDARY:INIT c5wXbHAwbpwfMUAHoVw } pf } UcsHVppe5hbpspwe
-- PHASE_BOUNDARY:INIT XAwoMsAOHXwApoAsNVsXpAXogso } pXfA (Uws )} AXbbwJ
-- PHASE_BOUNDARY:INIT MAs5ewbpUaMd } oepbAJKwH
-- PHASE_BOUNDARY:INIT string.sub
-- PHASE_BOUNDARY:INIT AbwHwwM )ApXUwowwAwJepUpH
-- PHASE_BOUNDARY:INIT wJV5fpbVHKsw )A5AUfswI
-- PHASE_BOUNDARY:INIT pAVbowspwwp / AHops
-- PHASE_BOUNDARY:INIT VCXsApbAop } wXwAAobMwwAXAfUeoMp } }XTfANpMA }:XswAkAMX
-- PHASE_BOUNDARY:INIT wX } bAu * ww } }char
-- PHASE_BOUNDARY:INIT buffer# % AwpVfeZUwHpsA } sfwb;HAwppw } VUAoiwepp5wUdHAVpsAf&bwHXVAppAwUKsAMXXwf } object } shV5XpXModMw } pXAf )+ wMH } AXXbwooMA } zpUbpepM * } bepbfa {sw} GeAbAHwwV
-- PHASE_BOUNDARY:INIT AXwUw * } object ))KeUUp!sw?pw5pbeXwVwpHfAbUswVppAeUUAspVwp;5eopsAVSXwssoAsp } wX
-- PHASE_BOUNDARY:INIT AAoUMwV } number
-- PHASE_BOUNDARY:INIT AcofMpMMXYbwJpMAeMewbHrAMX )wXobACjoX
-- PHASE_BOUNDARY:INIT pepbhzbwp )5eqAwHwwA
-- PHASE_BOUNDARY:INIT AfwUVHAMwpwe } UpHywUpp } kUDswVp
-- PHASE_BOUNDARY:INIT eMwowsHVA )UAwopsAwUpfApows <wMXpAAoRHwVAXAAp = wsc } array } pbwo } string )} _XfbpbMMP
-- PHASE_BOUNDARY:INIT wepbAwMww )HeAbXHwMo
-- PHASE_BOUNDARY:INIT AebbsHpwp )gebUpHfwP } weVUAHAVwp
-- PHASE_BOUNDARY:INIT 5AefswVp } of = UUspVApiAHopoAV } XwAsoAWX } number } UAAA <sA } pX } AzbfMpVVXGewUbMA } eewp
-- PHASE_BOUNDARY:INIT 8Abb )wepAAhNMY
-- PHASE_BOUNDARY:INIT pe } btHswpVA } 5UwHMwA
-- PHASE_BOUNDARY:INIT AfwAAHAMU )VfpUVH <sUpp5AUqswMApA55owsHVApoAwbpHMVgpoApopsIwpXpfeo } Mw } HXA
-- PHASE_BOUNDARY:INIT pZwMp } AXtfXqpM )} fXbbpyfM?VwpobADfww
-- PHASE_BOUNDARY:INIT weAAwHwM } string
-- PHASE_BOUNDARY:INIT etbbHpoH )_5wUpHAhVpwfMUAHXVwp
-- PHASE_BOUNDARY:INIT 5AAmHUVpp )5EU + spMOp * 5sowsAVXXwfeoAsu } wXpfeo_so } pXVA?8MMpwAX
-- PHASE_BOUNDARY:INIT bwLMMA } oewXMhAMr
-- PHASE_BOUNDARY:INIT sepbVkaww )peXbNUws; )AeXUwoHwAwU5wfpjTw_
-- PHASE_BOUNDARY:INIT b5pAMHgMbpppAb } swVHpA } oowAVVAp_fVops
-- PHASE_BOUNDARY:INIT table&pbApoestwwMbAAoeMw } MXAVozwMp } XX ^ AALpMA } nesbpbAMe
-- PHASE_BOUNDARY:INIT wX!bAUXwwsoeAbUUwwp
-- PHASE_BOUNDARY:INIT MehbUHpwA )(ew } MHAwppwp
-- PHASE_BOUNDARY:INIT UAH )VwppeiU3HUVppw5FoMspMApVAwossAVfXwV
-- PHASE_BOUNDARY:INIT oAsC } HXpAwo .Mw } pXeAqbwsV } AXpbwUHMA } oewb } bAMx } 5epA } string .format = ww
-- PHASE_BOUNDARY:INIT pXAVfHwMg )array
-- PHASE_BOUNDARY:INIT oUwYowA )lefUpH } wc
-- PHASE_BOUNDARY:INIT A5pUfH ^ Mwps5AUeswVMpAwoowspwVpkfAopsAVIXsApAAsw } wp .AAbXMw } }XAAUbwMp } MX = 5oSpMA } uXwVMTAMp
-- PHASE_BOUNDARY:INIT number ))bAr
-- PHASE_BOUNDARY:INIT ww )pXAbT + Uwp
-- PHASE_BOUNDARY:INIT weGUMHpsA )ofwUsHAwopw
-- PHASE_BOUNDARY:INIT MUAHSwUpp5wUgswVppXfWAw  %  AVAppAwbHsAz } XwXp } }string (VAXpeMo:Hb } string.sub } AMeDwsf } AwobweVMA } zsXbpl } MK } AepbeGvswHbeAbXHwws )
-- PHASE_BOUNDARY:INIT AMoUwHpMA )Le5UpHAwZps5pfAHVVw
-- PHASE_BOUNDARY:INIT o5AAXswC5pA5UAwspVspCfpopsAVWpwwMoAs )} number } )AAo } Mw } ppwADobMp } MXTbM ^ pHA } MewbHWAMe
-- PHASE_BOUNDARY:INIT wM )bAhjws
-- PHASE_BOUNDARY:INIT peMbFHwwp )eeGfwH } wA ))5wAHHAMHpwf } 5AHhweppX } string >swVp
-- PHASE_BOUNDARY:INIT AM5owHoVAVoAwUUsAVxp3ApoVsGV5XpA5o_HwwgXAAXdwMs } Asobw * pMH } .Xfbp = AMY
-- PHASE_BOUNDARY:INIT sepeAYHww } oeAfXHwMs
-- PHASE_BOUNDARY:INIT AeUfwHpws )OXfUpHAwS
-- PHASE_BOUNDARY:INIT wMMUAH )VwV
-- PHASE_BOUNDARY:INIT 5AU } swVp )} 5 ^ UbspVMpnAMopaAVHXwAHoAse } ws
-- PHASE_BOUNDARY:INIT AAo .sb } pXMAxEwMp } eXhewJsMA } )ewfH = Abe
-- PHASE_BOUNDARY:INIT we } eAOdMe
-- PHASE_BOUNDARY:INIT ppUbrHwwp } As5Uw8owAwofwbUHAw# )(wfpUVH -w5pp55UaPwVHpAfXowssVAHoAwopspV )^pfApoAsl } sXpXAU
-- PHASE_BOUNDARY:INIT MwVoXAeX {wos} AXUew_pMs }, pMbpfAMZ } wsMbA! )www
-- PHASE_BOUNDARY:INIT eAb } Hwwp
-- PHASE_BOUNDARY:INIT eeObbHpwM )65MUpoAMUpwfHUAHeVwH
-- PHASE_BOUNDARY:INIT 5AUBHHVppMf_owspVep_XwUpsAV )XweHoAAw } wX } XAotse } string.sub ).Ai -wMpVAHfbwooMAMoewAU AMb
-- PHASE_BOUNDARY:INIT MepbV7dMf )pefbjowMe
-- PHASE_BOUNDARY:INIT AeXUwH )wAM5fwUpHMwr
-- PHASE_BOUNDARY:INIT 55pUAHaVHpppAb } swwopAXXowopVAVzsUopsMVL } 5ApUVsKMwLsAAo
-- PHASE_BOUNDARY:INIT MwH )XA } bNwMpoHX:AbWpMM } 1esbpUAUV
-- PHASE_BOUNDARY:INIT wXDbAfXww + )eAbjZMwp
-- PHASE_BOUNDARY:INIT se <UwHpwe )/ pwbbHAw } pwXHUAbbVwp } pAU8HXVpps5vowspwAl5AwUUsAsoXwfboAs -VsXpAwoxse } pXfAEUwso } AXpbw * HMAooewbpoVM } eepbAxiws
-- PHASE_BOUNDARY:INIT string.sub
-- PHASE_BOUNDARY:INIT AAwHwMU )ApXUwdbwA
-- PHASE_BOUNDARY:INIT UpwUpHHwh } wfpUAH#ww = MfAU } sws
-- PHASE_BOUNDARY:INIT pA5VowspwppkfAopssVlXMApbAHM } wpYAAoXMwo
-- PHASE_BOUNDARY:INIT XAAgUAMp } sX {bwcpMe} window
-- PHASE_BOUNDARY:INIT wfb + AM } )wpHbA5hww )} )AbcLXwp } weBUwHpMAo55wbUHAHopwebUAHCMApp5wU7HeVpp5fLbws
-- PHASE_BOUNDARY:INIT VAppAwoHsAUoXwApUHsmVeXpAAoNMs } string.sub } Af } TwsU } array
-- PHASE_BOUNDARY:INIT Xbwe } MA } string
-- PHASE_BOUNDARY:INIT wbp .HMi } VepbA <?MwoMeAb } HwH ))AeVUwHpww
-- PHASE_BOUNDARY:INIT 7eAUpHswnpMfpAA / bVw
-- PHASE_BOUNDARY:INIT JfAUXswU )pAfTbUspVspLAwopseVi } wfMoAs } }number
-- PHASE_BOUNDARY:INIT HAAAAMw } } } AAWoXMpVXXZbw?psAUfewAULAuo
-- PHASE_BOUNDARY:INIT wXbbAvgMh )pewby + ewp
-- PHASE_BOUNDARY:INIT 5eKAwcewA )p5wUHHAbopwfpU } HcweppfAUgssVpVAeXowHUVA } XAwowsAVU } wApoHsu } MXpAAodswUMXAA } Nw& )} AXVbw&pMw } RXAbp .sMW
-- PHASE_BOUNDARY:INIT MepfAoAww } GeAbXHwb ))AeaANHpws )> 5wUpHewPVwepUAH } Vw } HfAbAswV } VA59UXspwsp7AwopHAb5XwfUoAoo } wpbAAogsH } pXwAdoeMp } 5X#5wU {MA} pewbHKAAo
-- PHASE_BOUNDARY:INIT wepABn_Me )peAbqHswpwAe } UwRUwAVX5wbAHAwUVwfpUHH?number
-- PHASE_BOUNDARY:INIT pp5AURHwbMpAf } owo
-- PHASE_BOUNDARY:INIT VApVAwopHsVqpAApossO } MXpeAUMMwV!XAAXvwA )} AX_AMKpMs } Wewbp#eM7wwpUbAi } wwVHeApwHww } wAe / bXHpwV
-- PHASE_BOUNDARY:INIT N5wUp7AAfpweUUAUoVw )bfAUh eVppw53UespV5pvewUAsAVpXwAHoAfo } wXpA
-- PHASE_BOUNDARY:INIT object -se } pXAAg -sMpMAppbwoUMAwXewAM, AMUwwepbHy#MA
-- PHASE_BOUNDARY:INIT peAbRBwAM )Ae } UwU
-- PHASE_BOUNDARY:INIT wA )VfwUpIbw =)AfpUsHDVMppXAb } sww / pA5Xowf
-- PHASE_BOUNDARY:INIT VApTfoopssVKXwApoeszMwXVAAo } MwwHXAXbgwM } MAX AX (pMH } <ewbpoA5f
-- PHASE_BOUNDARY:INIT wXUbAboww } beAb *, bwp )
-- PHASE_BOUNDARY:INIT we_beHpwf )cXwUwHAwppw5HUAeoVwppeMU7HeVppAfkosspsA
-- PHASE_BOUNDARY:INIT AAwUUsAMXXwpAoAsUMwXpAHo MH } pXAAtowfM } AX } bwb
-- PHASE_BOUNDARY:INIT MA } VewbpPpMi } Aepbs / gwM
-- PHASE_BOUNDARY:INIT ppAbbHwMN )AeXUwebwA
-- PHASE_BOUNDARY:INIT zX )UpHswRpwfpUXHgsw
-- PHASE_BOUNDARY:INIT AfAU } swMHpA } sowopA } ptfeopo
-- PHASE_BOUNDARY:INIT table * MHApoeoO } wpbAAbAMw } pXAf, )oMp } sXSeMhpMH } !ewb
-- PHASE_BOUNDARY:INIT xAMp )wXUbA!owwVpeMb = 8Awp
-- PHASE_BOUNDARY:INIT VeS )MHpwA ))5wbUHAwJpwf } UAURw
-- PHASE_BOUNDARY:INIT pp5sUDobVpVo57osopVApVAwbbsAVTXwfp ))s6VeXpXfousX } pXA5MEwsa } AX } bw <)MAw + XHbp!wMu } bep } 5! .ww } }eAb } Hwwp
-- PHASE_BOUNDARY:INIT AeUUwUpww )ReeUpoVw? )ofpUeUKVw
-- PHASE_BOUNDARY:INIT bfAU )swVppAe } ospVspRXMopsHV1XwfooAsp } wpUAAooMwwpXeAhoAMp } VXt } XlpMAV } ewAUIAM - )weVbAbdMb
-- PHASE_BOUNDARY:INIT pesbDUbwpMoelfwpswA )} 5w5MHAUbpwf } 5AHIwXppfeUZswVp
-- PHASE_BOUNDARY:INIT AMfowHUVAVoAwUbsAVg )UApows9VeXpAfovHwVUXAApDwMH } AsobwepsD } _Xebp = AMF
-- PHASE_BOUNDARY:INIT sepeAowww } UeAfXHwoe
-- PHASE_BOUNDARY:INIT AeUfwHpwH )re } UpHAwb
-- PHASE_BOUNDARY:INIT wMMUAH } VwV
-- PHASE_BOUNDARY:INIT 5AUVswVppH5gUAspVspjAMop8AVHXwf / oAsX } ws
-- PHASE_BOUNDARY:INIT AAo  %  sM } pXsA#awMp } eXhewoXMA } }ewfHCAo } )we } eAy {MX pXVbCHwwp} Ae
-- PHASE_BOUNDARY:INIT UwDUwAwofwbbHAwf )V5pUwHfwepp55UnDwHDpAfpowswVAppAwU } buffer
-- PHASE_BOUNDARY:INIT table&peApbXsG } wXpAeAlMwVbXAAAOwMp } AXfpXYpMw } FXXbp (5MiVwXsbA {pww ) weAbpHwM} )Me_beHpo } )0fwUpHeH!pwebUAxAVwpp5AUfbXVppwf UXspVfp ewb <sAVpXwAwoAsp } wp } eooise } pM5A_hwMp } element } mbwobMAVoewbpgAM, sXepbw -RMX
-- PHASE_BOUNDARY:INIT pefbmowMH )AepUwHwwA
-- PHASE_BOUNDARY:INIT pfwb } YUw  %  )e5pbXHaVwpp5ef  %  swwbpAXbowspVApl
-- PHASE_BOUNDARY:INIT XopswV7pXApofsiwwXwAAopMw } wXAAp (ws } table } XGAe / pAo } % ewbp, eZu )
-- PHASE_BOUNDARY:INIT wXbbAoHww )peAb, &swp
-- PHASE_BOUNDARY:INIT weRbXHpwf )WXwAZHAwppwf
-- PHASE_BOUNDARY:INIT UAb5VwppesUTHeVppAfPoHspsAp )AwUUsAMXXw5XoAoxwXXpAsoDdf } ppVAvbws } }AX } bwf
-- PHASE_BOUNDARY:INIT MAgbewbpo } math .max >} AepbsPcws
-- PHASE_BOUNDARY:INIT ppApVHwMo )AepUwe
-- PHASE_BOUNDARY:INIT wA )feAUpHHwhpwfpUeHBsw
-- PHASE_BOUNDARY:INIT VfAUVswMHpApXows } sAp_5popHAV4XwApUAef } wpbAAAoMwVAXAA8ofMp } MXdAX / pMf } 8pwfS <AM ))wXPbAXoww
-- PHASE_BOUNDARY:INIT pX )bL!Xwp
-- PHASE_BOUNDARY:INIT AeiUsHpHA )ofwbbHAsXpw
-- PHASE_BOUNDARY:INIT UUAHUswppelU:HoVppAfYUweMVApVAwA
-- PHASE_BOUNDARY:INIT sAVwXwApU )sOVfXpAHoqMM } string.sub
-- PHASE_BOUNDARY:INIT AAHZwso } AXpbwX
-- PHASE_BOUNDARY:INIT MA } _pUbpPHMl
-- PHASE_BOUNDARY:INIT wepbe {Hw} HeAbVHwsH
-- PHASE_BOUNDARY:INIT array )sUwH } HA
-- PHASE_BOUNDARY:INIT 9epUpoewtpw5pbAXfVw )b5A5oswwApA51bospVMpn5XopsfV )wA
-- PHASE_BOUNDARY:INIT oAs )} wpyAApoMw } ppsA_oXMp } AXRbsgpLA } )ewAbiAHX
-- PHASE_BOUNDARY:INIT wX )bAjUHw
-- PHASE_BOUNDARY:INIT pXJbg >swp
-- PHASE_BOUNDARY:INIT Ae;bwXMwA
-- PHASE_BOUNDARY:INIT V5wf )HAwwpw5pbpHzw5ppfHU (sMVp } Af } owHoVAppAwp )
-- PHASE_BOUNDARY:INIT sAV! )eApoHs } wXpAeo Zw } VXAAVmwHH } Apsbwg } WA } / XpbpUoMm
-- PHASE_BOUNDARY:INIT wepAAv )ww } beAeoHwMA
-- PHASE_BOUNDARY:INIT Ae ^ bbHpwM
-- PHASE_BOUNDARY:INIT TeXUpHfw ^ pwewUAHRVwp
-- PHASE_BOUNDARY:INIT 5AU -swVp'jwdCyXVPe_rapzvCm ='UNpbPc!#table&pointer * buffer ^ number, HH&number !buffer ^ number?, pbpN!1 Pdcc#bH#db HHHwp * table ^ Jw!, bl ^ !!#, table&& ^ wHH, Nb, number!string.sub, 1&number ^ !wbH&string.sub#, buffer! ^, number&, ^NwwHP!string.sub, #!table, &&pointer ^ bw&HVp ^, string.sub!1, number&char ^ #wPHd ^ table, ^ number _ ^ pw, table!eb, table!&, pointer& ^ ^wdH > 1, number, bNPp, 1 ^ char##1 * pointer ^ 1 ^ ^, NNp ^ bPJpcpwP, &!pointer, &buffer ^ ww HNwnNcc! ^PN&1&pointer * Nbd ^ &dd = number, string.sub NPp&pwHHd&# } ^number &kh ^ 1w, element, !number!table#, &Hd##table ^ bbcbdpH, &NNc#pH#, dpdwH  %  ^  number ^ p1Zc = number#1p#1!string.sub!bbd&&pointer wvw7bdc ppH!!  pHcdNd!nNw + P1pNb, char!!table#cH#pointer * bN ^ !ww38d!!HHNH &, buHdwp ^ 1Ndw ^ 1 ^ Ow! ^HqcHd HNdpf - ^NwcbhNpN, Pdc, !Hb!&char string.sub, ! ^, ^bP!ct!1HpPddc&1&Pw#bp ^ wbbE ^ string.sub&1 ^ Pcc##table ^ !pointer bbk!number!wbc&!_##&3&, #result ^ number HbppI, number: number, pO##&dd!#table ^ 1d&bdpH, dhwp&1dcd!Pbp&pd#, ^ ^H1pcbNd#number!1dd# ^&&&number, &number#wHb number#1&Pb!string.sub! ^#, dN * number ^ jw!, number, number!zone#&Hb&# HHpw buffer Npwcbcx!!char#HcSdb#&&pointer, table, #:number, P6NpbbP&string.sub!char# &char&string.sub, buffer =!number&1HDYc number&Pd& ^#table&number, pbpz#number x ^ pwHbH #!HbdcdprPN ^ string.sub#1 cbp!HN!, #bHwd * buffer ^ ( ^!1cPHNH#buffer&1dw#array ^ ! ^#, # % c1pbbP, !wb!&buffer& ^ ^buffer bNbdpH, #, buffer!!PcPu&string .format#number * bdwwH ^ 1w& (PP <string.sub PNc#&HHb&&dw, count ^, NQ ^ PH1bPH!#ds&1dHwpb ^ wp, &1dpcb cP&pHp& ^number, ^char, 1pbN#pwPPHP!, Hc& ^^bb# ^^, #1PN, 1ccNHb##Hbd#wPb, wc, bbbp!!HcH&number#, &cd, wb ^ #number ^:HPPp, Pccw&bH#&buffer #, number ^ cDdPbb#Pb!cdP&string.sub ^ 6bb ^ &Np, ^Nppb!dc ^ #Ndb&#pointer ^ buffer! (number, # * &number!1NP!!char&wH, dpwe ^ _wcppNcpp!PP, !PHp bd, bc, ww& number char!PTHp#pdw&&pointer, buffer&0 .read!, N_#ppcwP&char, #table !dN ! ^N_w, &0, pP!!cN!!#, wd * wd ^ cw * qcPpp ^ Pbc, &dH ^ dp ^ bb ^ wpNwm&pZbP#!!number##Hbbw &buffer, wcp!NHp#!Hcb!&HEbf pb&qpw ^ XPNdcdPPH!#! string.sub& ^ 1b ^ Id, cK string.sub!!pP ^ !1#buffer ddc * pointer ^ cNp, ^NbpH!dcc!dHbbp YwwwN, !1 } number 1pP#HH#1H&dPwab wS, #1Hpdbw#pointer! ^#pointer * bd ^  number, ww wP } 1pPPHp! ^Hpdg ^ dbc ^ pointer, !1pN ^ 1bPwHd#number !dcwpb ^ wb, wbdp ^ PN#buffer!, HP wd& number ^ bN! )NN!string.sub ^ !wcw&dH ^ db ^ bb# ^^, 1bPN, 1cPdHb#, &cbwbN ^ cNK, NNpb!Hcd!wdd&pointer * Cwb ^ #wwdpPPp, Pc!string.sub&bHwdp ^ wb& ^number, db!string.sub&1, #table!pointer#& ddPw! ^cNp, ^Nbpw!dc ^ #Ndb&, Pww ^ &wwjbP!1NP!char ^ &wHwbd * cbdwcppZ ^ p1bH#pointer!char# &char ^ string.sub ^ ^pw&pdNcp PPHp! ^Hb&number ^ db wbNb >bppcwP&char, #number !pointer& number, Hwb, dx, c_b cL! dH&1dHbcetw * C_N ^ cHP#Pd#& & ^HwP !NNpwP cb! ^Hac_d HNdPY! ^ wPwdcPcw#number&gcH 1dNdp, char ^ (wbPdN ^ pwb ^ number, #ibw&number * table ^ xNOwPP!char, !&# ^&number!Hbb * number ^ ^cw#qP?string.sub!number#PPPdH, ^pointer&buffer / pB1p1bNcw -- BUFFER OP!table# &pointer!pbHb&number&, #number ^, !cPpbpHH!#number wb, wP } number?, Nd1bc!1c#char&PdE#pb ^ wdB#5, wyb string.sub&pd# ^char #number ^ pdp, buffer ^ ^ number ^:number!bb cc! ^HPHpw!buffer NpwcgN { !HHNH &, buffer >Hdwc ^ 1 ^ ^, /, pPpPHb&!!!bdwN, buffer wpPpcPccbH
-- PHASE_BOUNDARY:INIT Hd& ^ bHPwdw math .max number&array, NH#!PcPdd, &1&number, yd#ppwPP&number&!#Hd&!!table ^ & ^table, ! ^!1 cPNH# ^char, &, wbd&buffer, #number!pp, PP, !number#dPbd#bPwNw& {1N!number!PNN#1d&buffer#number#dH {wd, number} #string.sub!wwP&1#1HH !#Hpw <  number, & ^ww&, Nb#pointer#pointer!1#bb;&temp, ^LPN 1PPbNP#Hcb!!bP&cd, bpbPN 1wPdNb##number ^ !wbb&wwb, #wp, wAH!!1!cn!char#&#buffer ^ !, # wppV#PwpNb ^ Pp& ^table * Hb ^, ^, 1 (!NNpbP ^ !1#pHwHbwwC#NNpcP!NV#&char&dg#1bb&number, 1Q! ^wbN >#pHH!char!! ^ number&bdc ^ string .concat ^ Hb!vcN !PP&Pb !b_ ^ 1, string.sub dNcrb {Pc#1pPwdb# ^&& ^& cb#wHP!number ^ 1N#pc&cb * number ^ #wN, cN!w3b string.sub&1&PH!char#buffer&string.sub&Tw, .string.sub ^ pb!number ^ !Hpd&user&number number, wb, !string .format&pH, <char!char###Hc# HPwp number !number 1, cb#HHg&char * number ^ string.sub&pw&4bNHwdP#char HXHH& ^ buffer ^ ddp &wNpNPKPbNw#&&! 1  ^cwH HNbw&Rb!wPbPbcp bb! ^&, HbdN string&Fdc ^ 1HcP pHN& ^, buffer ^ wwPbpi1bPd&string.sub!pbP ^ ^number#, Nbw!PNp, 1, number, !table#, &&&!, char = table ^ H1bcb!wb_&!&# #bc, string.sub, bM, pw, !cbc ^ # ^table HNHdwH # bpPlcc&#NPcHcdP * uHp ^ ^, dN#number (number 1&1dH ^ ! HPwp * 1b ^ global, number, ^Nw#bP !!#  number&string.sub, ! ^ pp, cNNN!#table&number& pointer, ^zone&pointer, cwb, zh!NwpwP Pdd& bHb, xF#ppwPPdP ! #&pointer! YbbwpddN -NN1Nb, 1cbw&buffer! #Fbd &acNb1Gb ^ cH!#cN&number 2 bHww&9HNPw!PN! * !bbw&& ! ^1 ^  dbQ#, char, !number&pcP <&number!wH#bdd# & ^d1HbHP, 1H#&Pw string.sub&# ^number * Nb ^ ^pb, number!char ^ #!Hcc! pointer&wdHM!vdNb, VP#!pointer#!PHdb#&&pointer, Hb& ^buffer, pRwpdbP&string.sub!number#wHbdcdHFpp1wdPw1b#dP ^ !&!wb& # HM number&qHN, 1pb ^ number, #1Hw& ^ cbdbwbaP&cb!#HHcp buffer& wp * cZc ^ !1cPHpz#1P&!dbH&&dbb& ^Hw#NCNd#HP#!number#char&uHw, H6pNcbP, bc#PcP!&&##&zww ^Zbw, #0 .read&pdHHc, !, HP&, &number &p1b#cHpp# ^! # table * dH ^buffer, ^pbNPPNP#HH, dd!buffer ^ string.sub ^ 1, 1BNpwbHP !dbp&table&& &buffer# ^buffer!pP, 1, table!NPNHjdc number, number!, NG ^ pp, pc {number, #table&number& pointer, ^object&pointer, cwbwbPdNHp, 1P&!pointer, &buffer ^ ww HNPb&PHcb#dHcdN !#wwp * psw ^, 1NN, char ^ 1&&pcdbpb, Kr#Ndpb, PcdbdH&dNdPHf ^ 1 * NiH ^ bp - &ppHaPw!char#1bcwP, ibpp, 1!number ^ !!#cP! VbP ^ ^wb*number % wp cH#number# table} #dw9bbad ^ pointer, Hc!pPb number&&, pHdwHb * wN ^ bpbN Nwb &bd! & ^HdO, HNwp#1&char&pP#, &wdd#buffer ^ number, #MNNcb!uJc number&table!!! string .concat ^ ^ww, cbwpd, dNH#!PPc !&#, ^table, number, 0, 1D, dccPbHdcdd ^ table# ^^, 0b } string.sub!handle&number, Nd!dc!cbbPbwwN / lbHpbNNcbpwc db bb&wN, &X1pgwwPNN ! ^Hdd#pointer, buffer& ^bdbNp, cg * 0!char!PbPH accumulator * db ^ wb Pg ^1 !db, 1dHd#number#buffer ^ char, pa, number#1NPPNP#dc ^ #1!number wdw (NHpp1ccPNbHNH1db Nd#number!element NdpcPbc##1HHcH * PHH ^ # NNxN&1wcc!table#dPpdP#!&bd!, number {, pH, wcPpd#&char!dw#, ^number, flag, bbwp&number!!1! Hc&table!Hbw Nb#bpNpZ {EP!buffer#!table&dH#Ab &eN;1p1bNP, !bH&&Nd wHw, number ^ #number ^ wHbHpppd&string.sub&bd, bw&!, number ^, string.sub#string.sub&number&char#! &number!number !&!wmt ^ Nwpc, wcdpdPHd!#PH &&pointer, bcl, f1Pb!string.sub!wP .dp * bc ^ &, dbPpHi ^ cPpPPpd * !wHb&1, string.sub, NNdN, NccbpP#, &wdd#buffer ^ #, !qp ^ Pp, PwcdpbH#dPbNb&wb, !buffer!pN, #Nd#bcNcd!} bd ^ Pw#table .insert!bwp&number#NH! number#!pbhH, ^  wb& ^, bcdpd#oH!!, #memory ^ pw, cj&pd, PP, 1 ^ Pd!zone#HH dcdP (1N!number!Pd!number#bbwdPdcbc ^ 1O / >dN ^ 1buP!pointer! table &&table, &table, !bcbdpcPPcOpp# ^&pointer #, &Tw ^ ^dp ^ LHpPHpHbc, #number&string.sub, handle, positan ^ #wwr& / !!dP, &!!&HcHdwb + char {, pbPPhw!&char#!table# table ^ dP number * wN ^  number# &!cH number, ^, number ^ NdpPb#char!NwHPHcdc 1d& pN {^, wPb, cw!dbb&# !bp&Pw, _wNdwbP#!!#pPP&, wbd&buffer, #wcw!1&number#1&Pw!number! # ^dD Pb number!, ^, bc##!HpcP ^HHwd * char ^ ^pPb ^ number#char #bP!ddH, wb, buffer, number;string.sub, PHzb!#cccw bHd&buffer !NPNHpw, wcH#&Pidp * bc ^ &, dbPpd =^cHpd#number&cHH&cbPwb, &pNwdb ^ number#1, HHH pointer &pointer table ^ &pppcc9cbP&table##1 * 1 ^ string.sub ^ number 3Npp 1cP&!dbP&versan cbPb ?NN ^ 1p, dcppwHNc dbbwH NppPwbcIcb#1HN#char * char ^ Pw} pNPp ^ 1#number !bb!& <#, HS ^ number, &5HN1bdPc!number#!number!dH#!bP& HNNN string.sub, char = Nd#bcpdbH, &table, !bP ^  wbv!!P1bPHPw Zb& ^1w#BH ^ pb!number !, Hc& ^!pb# ^, dP >&pNb#1bccc, #1&Pcwbbd#pointer ^ buffer!pP, pW& >number#SH&&1d#bH&pw ^ ^ wPPpN <string.sub#pbHwd# Nbcw! 9N&, &number! / table#char#buffer&1db  Hb, !ndpbp&, dcP#c1bd8dbHwwb * pointer ^ 1Nbp#cPp!cd&bdH, #wbw ppw!1HN!!cPpcPdHb ^ ^bw#iwN&1cPdNd1NHb#number !table ^ dbNPN ^ Ppc&!buffer#wP!dN#, &table, !bP ^  wFb cd!!PNc!! ^Hbb ^ b1bPNHb ^ Pbc##wH&dc dHddN, ^wNp&, number!#PPpc&cwb!buffer Pe Nwbs, Hc ^ pP#, &wddHc&pointer Nx#NdwdP, 1bP&Pd!Hb!&PwY &NdpPb#char!NwHb!#!string.sub#table ^ buffer, bHp!, Pmdp_p!#wdPd ^, ^, dd (cpPbtCpc ^ #bHHcd * buffer ^ char ^ 1NP ^ wPbp#pb#dPb &bg ^ #, 7 ^Tp NH!N1bPwdb#pointer&number&!, 7NN ^ H1bb, pdHHc!!wd, bbww, Nw#1p  %  PbH#dH!& ^&cbdb& + jbPN!, PP1pubpH!pointer  dbcwb, #NbpH, Ht, !NP, &number!& &Hd, string.sub, pVb#PdcbpP#, char ^ #! ^Pdp & wN&1HPPN, 1PP !number * wdNwd  ^ 1PfpN&Nw# ^& } ! -buffer!&number * pNo ^ number, !number#string.sub ^ 1!&number!string.sub#table#wwH, string.sub {cpPwbcp1cbw&buffer!dHEH!wwb {, #;4PpPb#&#, &#pointer ^ Ho ^ buffer ^, bdpH, !global ^ number, 1PP!&!#pHH&number PNQNb, wcbpdP1Hb&#b0bbdw (buffer ^ pointer, p1bP#1p& + cw#number #buffer ^, cBw ^ string.sub, Hc!pPbdP&!positan#buffer ^ dd& wb ^ wc, HcPc#PpdO!wH#buffer# ^ WPi#, pcfNwb!##table #! ^Pdp &, NNb&cpN!1b&pointer!table#wH ^ dc2bb, wNip!:string.sub, PPcd!&#, &char ^array number 1H ) char!1PNHNd .db#number ^ &, table = number ^ !1wP#!bHb&!dH# =^HddwHwdb!PdPr!pointer#&# ^!db!buffer& PNpw ), 1&number ! ^Hb&table#1& number& PG!wovrNHp!1p&pointer&cbV dwP dbdw, tdNNbp# ! ^HNdh& ^bbbbw, wwpPpPP##string.sub&&HE&string.sub ^ number 1N wd1wd pNPNcHcw&pointer ^ Tw!number, NdN _Hp string.sub&Pw&number!!HNd!buffer& ^string.sub + ^wd1ppcbb#Pd! PHP ^ 1wp ^ 1 >wx, pcp ^ PPPd&&Hc&number ! ^bwpdA&Nh!buffer#, &table * pbb ^ #, !buffer!, cp, NN!!1PH#!& !Hb, HXNwPNNcH!wHN! & # ^w1bb ^ # ^, g1pw1Nbd#5!number table * string.sub ^ buffer PNGw#number!NH!HP_!buffer&, HwHH, 1 ^ dp!?!string.sub&1pPbcPHN * number ^ wbb ^ &pcb!pPc#number##string.sub&&pointer, &string.sub&number, number, ^wd, char <!PpPN&!dP * pointer ^ Hwww, ^bw, 1 N1bPPwHp! table&pointer! ^pointer number, dw, versan!cbb&Ppd!pointer#&PwH !pNwb 3 ^ 1 ^ ##Pddw bb, dpwdNPCdpbpPpb#, HP !bbdNwbb!, bbdpHNH#number!number!wH, ^Pdbw, dpb * PP1pcPbH, &##table number * number ^ # ^!string.sub&table .insert pp!NPb!number#&table ^ &! Nb, string.sub!6 pNp##!!1#0 .read&NH ^ dw ^ db, number!6!Nbb!Pc!string.sub!number#ddedb -number, Hn 1dcVHw!pointer#buffer&Nbdbpy#number&FPZbb&PNPHcw pointer buffer * 6OP ^ NNb, ^18bHc&&wHb char&table, !, 5N#, mNPPHP&&math .max!#dJdN ^ 1 char 1!NHNHb ^ !!!&dw# dld# ^wj#, PcNN!char, PbHp!wdPdNb#bG, cpcPcp#number ^ cP& ^HP&pointer & pNwwPpbN;1P!HHcdcb!&1bb, ^_&number number string.sub!cdbw!table!, Hc&buffer NbHwcbbPdPbPP# # &HbwwN ^ NbdpwbbP, ppP#&number!&db&!dbbpj math#Pb1b!1P!#char#NdHdHb ^ wN ^, + JcPpb! #ddbHPbbw!b1g, 1 number!1PbH!hc!HbHN ^ char, ! ^pNd, &0!number!number number, pointer!table dNd#, !wbw&NNb, pwb&number, !! &&number NbHwp9NPaN!cH#char&table#Hbb dwbbcwd, bNNPdPpP&!& wH! ^cbN, pointer ^ wjNcTp, !, #number#table#number& bHwvI&ncGbNH#!#} &##math&PbHw, NXNNbbW&1Rb!cb!buffer&table&char ^ ^dw&Npc!number&1NccH##number# &! ^, bbwdPopPpNP##&#cdc&, ^wb ^, !wdO ^ Ncb * 1HH cw#pointer ^ Hdcw, number pcP!N1Pb# ^table&! HNd!Rb wwPw, number, NbbNPpHddC&Pbb ^ number ^ 1pp 1dPPcbPddw bb, dp wNPaNpbP&cHciHPdwbb Nwbb buffer, bpNN ^ number ^ !pointer!pointer#! ^Pdbw / wpb  %  NPb!wc&!!HHdd&, pwnwgp&PNcc! cpHb!, HG ^ buffer bbHNNf NPb&!string.sub!1&, &number * odwbN ^ dpwNccdp#ccPw& ^bL ^ 1 ^ Hx!handle function#Pb!pbdHw!dd, &pbdbp - #number&, cN!ccP!&!dPd! bdc } Pw 1G, ^string.sub 1Nc&&!!!Hb&Hdw number, 1, OfcPHPk&buffer!#Hdb#buffer# ^wbwbX, string.sub#PPHp!&#, # buffer!pointer#wdwpN! * cwPbc &1dNH buffer#buffer#, &, cb!number, pcP # ^!number 1H * wpbNb ^ pP, dNf!number!, cpdcb!&1w#, ^ ^cw number:string.sub!string.sub ^ cp&pointer!, &array&bb, PNw1PN1cb!string.sub#, cb#, &Hd ^ bPbdNp_cp pp#number&PHdb {pointer, ^table ^ LNHNd1PNdbH#string.sub#buffer#number&, & ^, number ^ Npk1wcPb&#HHNdbHNb1dkbbw hHP!1PPbc&&1Hc& ^cd ^ ^string.sub ^ &wdPwN!HpPH!HH &number &wpwbwNNNPwpwPP!&!, # &pd# ^#wpN ^ ohpvcHP&table #char Hb! dTwwdp, NpNwPp!1!& wH &buffer HN! ^wfNNyc&!Hcb fb!wc ^ wwG ^ ^number!:bNHpwbw#1# * table!bHb&Nfp!Nbh&!Hc!!buffer# dNH ^ bPbN ^ pointer, &Pcb!table!!string.sub string.sub& ^^wbb ^, &pNpPc#number#number, &&HidHd# wF&number ^ string.sub&user!1 * 1HPH!number&pointer ^ / pointer ^ number, ^ pcP!Nb!## ^cO#!Hcd!dwbb ^ &wdN * NbbpPHcw bdbw wwbwbR, Ncp ^ PPPd&pHd, dpr!NP, Pj&Ncpb#cd_! ^bb dcN, string.sub, char, NpNNHbw# ^dW * number ^ number &, table * wpb
-- PHASE_BOUNDARY:INIT HPbc&PbcNHHHbd * bb ^ # ^, WcPdbN!wP ^ &##wd!&! NZHvde NPb&!string.sub!1!number&Nbwdw ^ 1w&, 4 !NNp#1 ^ Pw!&bl&, ^HqpNHbPPbP ^ 1dHw!dd, &string.sub& ^bpwdw&ppNdpbbHcH!number&1 ^ table ^ &wHbbby, w1bbcc#!number!!Hb&Hdw wwP, {versan, PH!, & =cwd# ^ ^1, number ^ 1, number PNb ^ Hp!&db# &Nd#, bw, 1p!cwPb#, HH!HdPdHb#vw, 1N, pNNH#number&pc, !table HbHwPiNcHb, cccbdcddd ^ number#, ^ ^1w RNpppwcp!1#number&Pdc bbHNwbPPd!HPj&Pd, ## ^!pointer ^ &buffer, string.sub!NccNp#1 ^ !string.sub#PHB&FdbwwF pNE 1bc?Pc!pointer#buffer&number ^ Nbp ^ number ^ math .max PwPNcb!Pb ^Hwbw, wPp Lbi, 1PPw&number!!HNd! ^db ^ wPwdN, number!1N#number#char * number ^bHbP 0pN * x ^ string.sub ^ PPPd&&Hcd& string.sub, number ^ 1N ^ (number + number )^string.sub!#cHP&dH dPwbb!, buffer, NNN!!1PP&!&#qH wdb!, pointer ^ number, dcHb, HPc !, &cwcddw ^ ^number!ibNHcdbw!number#xH!bH ^ p3HNN1bNNPbb, #, !&# ^table&bP ^ pt ^, number, PccPH!table##Pdb ^ number ^, ^ (zone -Pw )^number#Ndb#&table#buffer#buffer&, char * number ^ number ^, >PN!cc! &!! HPbb ^ pbb ^ bbG, H1PPbc&! )HcbddpwwaNf ^, wFgNbP&number, pointer!table &Pd#, wwbwN string.sub#1 * HNH ^ pointer! & string.sub ! number ^ number, Pn&pP!bP&!, !wHj& ^ 1 ^ string.sub&, PP!pnPPc!!!#string.sub ^ # !char ^ ^NpPPdp!11PbH!!Hd ^ db ^ # ^#number#, char#number, pw#1Hw# ^&char&, bNT&pwpbN&string.sub ^ Pb#&#table &&char 1w& ^#1!1bNpcc#, !1ddH ^ dbd, bpwb, NNbc !Pcdc, 1 #number#bNb ^ wkp, cb#pPb&number# buffer, &Cw!, bwP, bPwPN#, number;&# bHp&string.sub * char ^ 1 ^ pointer char char&!number#char#string.sub cdNd, element ^ NNbH!1NwbdHP&1bb ^, pNcb, memory = Pd!flag&pdH# bcw, buffer!buffer ^ ^, 6, cHc, table&&, ##buffer * bV ^ Nbwpb, Hp#number ^ c1bbc, Hd &# ^# ^&wbjp!Hb ^ &&cd& ^buffer!buffer, string.sub ^ cNdP&Pd!NPdPb!, Hbbw ^ number pointer, jb!string.sub PNcb#!&PHdHXw! ^ ^ cPPP&Hc#&table&#string.sub buffer PyPN, pNpdpbp, 1HPw!#table&dH, number&9NpHrHcppdPbc&HbH, buffer# char ^ number ^ ^Pc1bc ^ number&PHH # ^, dbbd: ^ppL#pabN!&!number&cd&, dHNbwdN#ccPccpcNcH& Hw, buffer# ^cZ 3!number##1!HP ^ string#&wN Hb, ^NwPON!ccccC!&pointer&HN& number ^ ^ ^-Gb!Pcbw#Hd, goto cd buffer&, bwd = 1cdp ^ PdP, &NHH&cdP * pointer ^ ^NbcN!pbb#wHb, Pbdd, buffer&number&pwNdpNHc#pointer number#char&bb wN, ww#X1cbbNc !char#1d#&#number#, wN, #fHN Pk!, &!#&&!& Cc ^ dN function!string.sub&1cP cw * char ^ dd, bdwpbpP ^ NccNP&char, !!HbdNwHbNNc, #number!1 HNP, dH#cb&pointer#, buffer!number -YHcHbp!1Hd##buffer!HbbdbwQw, table:#1 ^ ccbbdp table, number& ^wgNN!number <, pcbccH& table#&pointer ^ positan * table ^ buffer, _pNPdp table!char ! ^#, bwd#buffer#NNNch !pp, ccd&##&#&!dbb&tbN ^ PPpN#number&!cbdNH number!, cb ^ 1cNppb!string.sub!buffer# #pointer dwc cw&Npw, string.sub pNb#Pbc&pointer ^ Hpbbbp (PN, 1g&char / 1 ^ &table&number# ^, db, #bwbps#Ncp PN&9#pointer pointer&& #bNwdp1ccP1Pb&pH# wH ^ type}, cN ^ pNN#p1b#HddNb!wN, #buffer, wPNHb string.sub!1b&number!&#, &#&number ^ # ^!number ^ PNp, string.sub, !string.sub#1& bQb! Bw!, buffer PPPdp#1&number, !, &! # ^1w& ^^Ncbbp&cc! HN! ^table ^ &&pointer, buffer, pb, NN1b&!number#char NH&HHd ^ bNN, NPpbcbpcH ^ cc&number&number&1 ^ 1 ^ string.sub, db ^ 5cp char#Pc&##&bpdb * NEc ^ ^, >NcpbP!HHdw char&wb wpb#pcPppeb ^ cb# pointer&bc, number * number ^ number pPcd###!#number Pb&wbw ^ ^NbPNchc * HpH ^ pointer& wHwwN * key ^ number!, bN##pPPHw 1bpwPwHwPNd )#bit3c#Nd!number&1dpd ^ ^number ^ NJwv, #cx!&#1H#dH#string.sub ^  dd = pw#1pJPbcPcHd#byte * pd ^   ^1bHpP, !1#number / HXHbd!, buffer#  buffer&bbpXPccPc, table!&Nd ^ bp&string.sub, ybpNdwwb ^ number##pPp&number!wbN&number, HbdN&, 1 * bc 1PH#!number * 1HP ^, wFd ^ bPrNP!bb ^ char!dc#number ^ Ndw, ^bwpcPHcPp!Hbcw !table#& ^number, {wNd, cMdcwHb&string.sub& ^bPb, number * eB ^ vp1glc&pbH!ccd wHw, # ^Hpp, PPNbPPbH#dHdNb number!dbN!pe1bcpNdHpH ab# ^dwb PNdw?1 cd!!1HdNHNb ^ &, Hbd * NPcPc##pointer&1& table, Hpw!buffer bbpH, dcHpd#buffer! PdbdwwcOw, Nw, ^ Sbp#1&&Hb number wbd, handle wdP&cbbP&nc ^ bJ&pw, ^ NH, wb#Pd!#!#cb#bbH&pointer, char, dpcb&1P!!! !Hcp bb! ^&, HbhpPC& / pointer!!1 &!!Hd! table ^ NwN, &pc1bP string.sub&1 &number#9 * db ^, pDPp11rppbPpH& * && number ^ cwH, dbpN ^, !number&pp#, cpd #pb&wb, Hbdp, / pcNp PP&number!bbd&buffer, cbHN#, number .dc&1p&math .max!string.sub * NHw ^ ^ #buffer ^ number, 1bc&!Nbp&ddbbH ^ p6Pbbbp, Hcb#string.sub#wcI HbNw!, ^NWppwdc (number!#number&byte&buffer#dbdw wO&19b char#!bbb&pointer!buffer &table, NbNN#pd, pointer!1PPHw!} dwbdbww, &string.sub!8wP NHHpHb&, wH!ww, #Nb1bP!cHpB# Pbd#buffer! ^pdP + ^number ^ 1&flag#!Pb!##table } btbbw! table#, wwcpb#1H&number!&bP&!wbw ^ NpNdpNPwcpH!char#!&bb&wb ^ nwpdp ^ pwPbHpH&char! cbHdi, bb&pb, wc, number ^ HN#number ! table wbc, wHbPD!char cTHwdcH# ^!number#wp wpHbpPc!Ppb&function#char#! ^pdc <string.sub ^ PpwppP ^ !, #!#!&char pointer&cd#Qd ^ bbcpP!cP !cdb * number ^ #&number, bvcpdPNcP!!pw&Pcd * char ^ pw bH18b&cw#cHH&pointer!pbH&!, 1bpN pPNNw! ^number#!vd, HH ^   HY#wP1wg ^ string.sub!#, Pwdb#number ^ HddRP ^ 1w&1 cd!!1HdOd&bwwc, H_d ^ pp ^ = !!1bpHc!string.sub  HwwH # ^aN HccpHHNPH&, bpbwd_, ^HbpZNNd#PPpda#pbb&ww ^ buffer#NcbHPPN!#bPd& ^#pointer ^ 1d! buffer, wcb#char!!pPB&table cbPb ONN ^ 1p4pccbpHbcw #table# ^^, abnp&MdcPp!#number& dN&   ^number, 1td ^ wPHcp!cHPPb * number ^wp, &CbNww!number Np! ^Hb&table!pointer ^ 1 * 1 buffer ^ pd, bb ^ number!table!table&dbbcb ^ bN PNH, ^, wcdpbHdcb&char&, bpwc, pNcp, string.sub * number ^ string.sub, &string.sub!number  % buffer ^ wcwpw, string.sub#number&1dNb# Hw!!bpH pbPNbNbP c_#number!!&1*dHc  % bcNSwpNdPP! HbHP&NbPb&&dLPiwpNP <kH#function#&&number * cbH ^ ddp, ^bwp&number!!1! 1bdPd ^ ^pw&, bAw ^ !1b + pointer!Hb!table&!!, &pwN  ^Ppb, bcdpA##&dd!#table ^ number 0 .write ^sp#Pdc!pHHw!Qd, table&dp, bdp#, dcbp!#cP, & ^bibb&number, & ^ppcEpcNpwHHc#! ^, ^wwd * bpPp ^ cp!&#bHwc! NHdwH !NPw!1cNp!bb cPdw#bb, dbAc ^ Hp#xNNd#1Pp&char!! ^wawb wpP, !number, pp# number !number * 1 ^ string.sub ^ number &NHpNP!char ^ # -HpPddw&number ^ number, flag, buffer ^ #wbXbN&string.sub, HNdldb&& ^ctp = ppNHbb!&#table!number&number, &, cw number, cbpwH##, &!&wwC, !XNK&, pPwpq!string.sub!, pointer ^  ^ ^Hbb ^ char } ^1ci&cl!&#1H#dH#pb ^    buffer ^ #1pCPP!!buffer!function&&Hb ^ math pw#buffer# ^dpwcb!string.sub! ^&number&, ^BdW #number {string.sub&1bP#!Hbp&!!pointer &pointer#, pbP, cgcPdb / #string.sub! ^# &1HHwP !, #J3P8Pb!!#, table## table&Hbw -zcNPN, number!cN! ^Hpcp * GHp ^ Ndwx! ^#string.sub&8p! )pwHdcwd ^ Hd ^ & 1bbpP, Pc * pP#wc_dH#&&pwb * da ^ wdb&number!!cb, ccd#buffer! ^pd ^ bpN!1 Pdcc#bH#db HHHwc HNcwPbw )^ 1#!number!dd& (^ddb ^ !pPp ^ number, 1#Pd!number&table!Pbw ^ Hw * zd ^ p1dPb!table#, &pdP!buffer ^ string.sub&table, 1NpNw, tcPb&HOcb EHpbbbbVbI, 1pP cbP#1d&cHbHP ^ # cNkwpPbcpPN!cH! number&cdHdb cNHwdpNpdPd#number&!HH & ^#dpVNNPwbb, Nc#HPddNbNd&wt, 1w ^ pHN&math .max 1!HKcpH!bd dbvQN, pb1wcd#number#number&number} #table ^ 1bNbpNc, NPwpYcP!wd#&#bb ^ #, ca&wN, 1c!pH!number#NdB   &bfwbNPwOPHcN#!table ^ dh string.sub#dwvdwK ^dbHxd!Pb!table, char, #table ^ cd (lN ^ fp ^, bccpcbw&#!!bb&!, JbpNbw MNcb#lH ^ &char!!bw ^ #, bNbp!1Hr_!cpbH#pointer! pHPwb, cNdbNPPc!NwHPPddcbP ^ ndw, wp11pb ^ !number!, table pointer - # <^Nda, dbbpc, cP cwpw&string.sub#Hbp&Pwb ^, NPp#pwPNP, !NPb !bt ^ 1, string.sub dppp char;!##dHbcP ^Hi ^, pointer  %  ! ^HbbpN!Hb &table!dd  number, number, #Nd11b string.sub, pp# ^! !buffer, &pointer, HbdpL -dcc!char#buffer&string.sub&number  table & ^_x ^ ppHNPc, #1cb&number&global wHdw&, buffer ^ Pp#, ^ .1p&number#table #de * Hwwz ^ ub, 1Nb!H1dHbHp& buffer&bw ^ pwHs, pcb!!#&&table! -pointer&dd, ^ ^ 1!2H!&!, #cdHd &, bd ^ 1b& ^ 1wNhbb!char#wdw&1 ^ number ^ ^wcbH1hb&cw#cHH&pointer!pbH&!, 1bpN pP Nw#HP#!0 &HHwc HNpwPbw:Pc #wHdcbbp&NddFb ^ p1brpc, pp#&&bdH#dwS * pWb ^, NPb!user# ^Hcc! wb#wbXbN!pH, .char&Nb##&!dp#number ^ bwc {dpNbPP!Jw##1d&char PbV&wwwNbppp ^ cPc, # &:!for number&5w ^ bNcwcb PwNwHp!table * pHP ^ !wbLN string string.sub!!2!, 1bd! YbbwpddNpN Pjc#!pointer#bPPdd#:buffer wd, !bHpbNNcHp HHcd& dPwPw#mdpbp number, Np! ^char cbd, table wH dOPypbppc!HHcHw&number# table ^, 5bp, b_Hb#1!! ^!&&&&1#pointer ^ &wbbPN#number ^ cippcp#!& .dz ^ ! number, char, nwbxbcHpd!###pointer!buffer!bwwbqKpPwpPbc!!&HHcj HbNw!, ^NzppwdP, Nw#bPddH#pointer ^ 1d! buffer, wHPcN:#NPM&pointer!bb!&cdwaH ^ !1#array!!1bpHbc #Nbbw?, ^Gc ^ !1wP#!bHb&!dH# - ^char&buffer, #number!pp, Pcb!cHddN Pb!Hw, 1 dNcbPP} number #dHbdH, ^pwPdb >#, 111cpcwb&Pw!char# ^Pw ^, # / pb, !char !#ccc!pointer, wPwbFNp:1wG#!1#bPH&bbN ^ handle ^  Zpa ^ string.sub& wpcHPH ^  pb& ^bww !0 2#string.sub!PPpP#, &wddHcd ^, Pg ^ number#string.sub PbN!!wc, dd#buffer ^ !bb ^ dwb111P1cb, 1P&& string.sub#! ^number 8, number&1HP, !Pc, #char#HH1bdwbw ^ QNppwbc!1cHmcp string.sub & ^table ^ string.sub, ^number&8pN ^ pc!bHcH, dbbPHw, 1 ^ #pp, PbNc ^ # + #!#, &string.sub HwHb#awp#1NPc!!1o&&#&bP&!bfwKL * window ^ 1, 1P#table&number!& qb& ^1w#_H ^ pp ^ P1bN#bPwH, &table ^ table ^, wN#number, NbpN!HHNH &, byHdw!7 NdpcPbc##1HHc / PbN&pointer, ^bdwp, HfwN, #table&number& pointer, ^char&pointer, NwbpM, dP ^ pdbbdc!wHP&pointer bNC&, cb#NHp ^ Pbc #number&&wi, &YbN#1HGp!!number &!!table&&pointer&ww ^ PN!NNN, 1#1 HHcdHH Nbp, 1, string.sub, Pvdc!Nd!number&1dpd ^ ^number ^ NEw -, char!pH!PH table#bd buffer, #wd, dwH cdb, table!char& !HHb& ^pNpNcbHcNc&number ^ PY&  db!dN, dNbN ^ 1NcpNb#table& ^db # ^ww&ZcNdwpb ^ number!!&number!dV!, bc ^ HdHvw ^ PbwPHc #dPpdd * 1 ^ Hw, OpNP ^ bPFLH!1HpHw# bPd&number#bbNb 1, cw!dbb&number #bN ^ char, !buffer / string -- BUFFER OP .sub!, HclpP#number!Nd!#table ^ Hdd ^  number 1ON!cHcb!number#&!wbP&dw&buffer!NN, pPwpfcw#table#buffer& } Pwp, !number!wNK&cm!&#1H#dH#pbw, 1apL ^ 1Pb, char #abH&string.sub!bHb ^ buffer, char N1bP, number!Pb!Hw#1 number&vbwwHwbzEpPcp!!table!ci&, Hnb, dHuH ^ dN pP!number!#Hddbd &, &number, dbb, !number!PNPb#char!ddwb#table ^ pointer!, cbwpw = Xcb##!1d1db&HwNwbbPpr, pPP!1#1!table&number&cb wb * 1b pH, db#!1#!#bHc&table www  w1pb, bcbpw! &#dd + &bb, pppw, number#!number! ^&pd& bbw&number, dbbpd, bbccNH#& ^db dbsb# ^ ^cbyNNcN#table .insert#buffer!& =buffer& ^1w#3H ^ pp number !table#buffer&char& table#bww#, NScp! } number&1&HPc!table#&# ^bbp )
-- PHASE_BOUNDARY:INIT     number table ^ pcFw#rH&&1d#bH&pwwNbppp ^ cPc, # &0cH &Hbdb, bNcN, 11cPNwHb!#dw#number&char ^ )PN ^ string.sub#1 cbp!HN!, !table!& ^bcJbpcp, Pb!Ppw&###bp&number ^ char ^ wNwpNPPc ^ !cc&!#dwb# ^Nwcf! ^> 1cN&Nd#HP!&&#! ^pdPwcwwpwbNcP! ^#char!&!HbP&!number#wN, dppP1bwcd&Nc#!wHpwp number, NN ^ 1Lb!1, cp#HdHdd ^ Pd!TP, HmPpdbd#char#table# ^!## ^&cw, ^NNH1Nb number, #8bd&wHbbb&dw ^ bdp!, HPbPw!global&HH ^ &string ^ bwN * buffer ^ &number ^, pb!dHbH ^ dNbpHbw# ^char ^ !wbL#pNp, #ddp#rbbdu ^ ^string.sub ^ cN ^ !number#PPbdHH ^ dbdb  Nbp!1&cHpd#, &string.sub!db#pointer bN, ^ ^&1dPPc##!1wd!pointer, ^Pw, wN; ^H1b + wpdP table * dHbcb ^ &wipw#, NNNc, 1, PH!&pointer&bH ^ PbNENNwb * Pbc ^ #_PHdPH&&, dd * number ^ table, number, &cd!number##&!cwb!buffer PB Nwbz (ic ^ PNc#!string .format!, ^wZwbb!number&, PCHp#1 cp!number## ^1wb Hj number!, dNHp ^ PPcb!&&number ^ number, key, bw&1!1, !number# HwdZ!table ^ Jdp, number + number PNcHbwcHHc!string.sub char&pwd, ^ ww <!number ^ string.sub&PtcP cHb&!, 1b& ^table, Hbdp#1dP#char ^ #1& ^, dx!, 11dcbc ^ #number&pcb Ndcwbb, number!string.sub, 1&number ^ !wbH&number &bH ^ 1, dIcpNb!, wc 1pHwc, table ^ number ^  number, number - ^dPepN!char#HcEdbbb ^ wdAaP ^ cb!Plcb#pbd&wHb  &pointer * number ^ &number ^ 1fEH!PP&char, !table## ^Hwp, cNP ^ bPPP ^ #pH&&bdw# ^&1 ^, ^NbpHNccc#PH;! ^ table& number! HwbpwbdcNP&#number# ^ number#Hb#dH, # ^Aw, QSN ^ string.sub&Pp&number!dH ^ &pointer * dbb ^  1Pa&p1bNc&&&#pbw& HNNN string.sub, cSNd#char!1cw#Pbww ^ 9!bdpwN1NP11Pb&number! ^table!&1, ! bN!1#, wc&number#Hc!number#pointer ^ Pd! ^dNbpHb, 1#!buffer! dp!!bP&!wwbpNdw * 1 ^ cb!Hbddpd ^Mw#, dib ^ Pp, number char #dH!#1 * pointer ^ 1 ^ ^, NNp ^ bbcpcpNH!cH Nd&bMbHWdpAp 1bNH!wPPc&dP&pd ^  table, bwdaPz&pNb#dp##HNH!wHWNj number, number = ud!ccb&pointer# ^bP ^ ^number#, Nbw!Pp!##!HNdH 1b, wPdbNcN ^, !NppHbwP, dw # ^buffer, 1r!NHb WPNdbM&ccd !HH number, number, bit3c#string.sub#1H!#PwPHc ^ !, table&dP * buffer ^ pwH, &number !pointer#!PHddbbb ^ wNFpbbpHP ^ cb!#Hw&& cbd&string.sub, !:1 ^ buffer, 1Pb!char!, HbdP!wbb # ( pb, #1wc#!number#char&!!0 .read Hd&, ^Ncw&1jP&cb!#HHcpd ^ & number, byte# ^ ppb Pcc&#dPP& table ^ wNwP wSdwdPpcb!bPp&number, &1 ^ pointer, 1, ^NNbp, bc#PcHbcb#1bbwcw, / 1pPwwcYb#table * dbdpbN ^ pointer&wEbw#, NgpcNpp#buffer& ^!Pb! ^, number&, ^NwwHPwbN#aPHc, table#bww#, Nocp!, .number 1## Hw!!bPd# ^buffer# ^cb!Picb#pbd&cHbHP ^ table 4b#1pj#Db#NH&number #1 * 1 ^ Ow ^, char =, pp, dcHb cNcd!&bd ^ Pw#temp!bwbuP&cb!#HHcp !& ^, pb&, NbcPHNH#NPP&  wbd&bMP ^ !number!1Hb!!pointer#dHpdbd ^ &!, !bHpNN&1BbH#pointer&0 .read& dbHHwP * cbw ^ bIbc!PPcw!## Hbdc ^NwpHb cdppH!!  !HH 1Gtp&PNPNcHcdPHdP#char& ^^ ^, buffer / table -- BUFFER*OP ^ d1cpb!dP ^ table ^ ddb#buffer, number&, buffer ^ PbpNcp 1!P1dPdwbNwqdH7b, NbNFHN, number#table#pointer! string.sub&, number!number NcN&math .max, number ^ 1&#&&HdP&number ^ string.sub, Nmdbwp&number#pNbpHdcd#Nbpw1dd3pNNbNE, string.sub / 1N&, ! buffer ^ table, ^ buffer, number!pb, bN1b # &dd!&1 ^ number, 1Tb ^ IbHN&p1bPHbcb#1bPwcdbvwp#1NPc!!1hH #& table&hd#buffer, Nbp!, wcbpd# ^cd#cH!dNd, ^ number Hi#!table#pHcdP!bbww#, number:cp!, aPHb&HpcZdbHq&bdbb& ^char, ^PPc ^ !## &buffer!!bpd Hb!number&, !NPppPpP #1 * pointer ^ 1 ^ ^, NNp ^ bb#pc#&#Hcp!&Hp ^ TddbN ^ d1pP1cbbpHd&  number ^  pointer 1f! ^wpwN, 1cbwP ^ dw Hb wd string.sub  %  ^number&number#number#1 ^ #dcP! &1 ^ 1 ^, >wO ^ } 1P -NdbNc&&& ! ^1 ^, char } Hwv1opNb#1bdN! ^buffer, &number, string.sub, bi, pw, !cNc ^ table table HNbH&Hd, ^ number#1PcNc&#1H!cwdw&, c0b wbp ^ table .insert, #0 .write#dH ^ db#Pb, ^ error&0& number!number!string.sub ^ number#cH#table ddb wb#number&1!cbc #cHH!x zdN #CcFNw, string.sub, NN#string.sub#bH, dw#! ^number ^ ^ / { _NPHNHp, number&cd#pointer bdcblb&number string.sub#char!ccP HH!string.sub#&dNwN  %  7qb, &1 ^ c_pHH!cPdHHP&, zb ^:1N&p1bN&string.sub&bd, bw&!, number, ^string.sub#string.sub pN!!! table &#bNbc ^, &NHpP, !cc!HP_&number!bbz&buffer HbHwP, NN 1Nb number&dd Pb#number!dw =&NcP1P1b&#wH1dbd, ^ ^^ ^, 1NN1v1biw! ^HjcH !HP ^ table * number ^ Nwa, ^user&1bP&cb!Nbpbb ^ wb!pNp ^ cbc cN&!&   buffer#, !, cL string.sub&PHcPp!HPH ^  pointer   Nw, ^ number 1dP!NH#1&string.sub&wH buffer# ^#bcCc, 1dNpp&cN&wd#bbwb, !_H ^ Ip#number#char##!Hp!, !buffer, ^ number ^ Aw ^ HbPc&!table#1&ddcbN ^ !&wiPV, wHP!NH#TPP&1! ^buffer! ^, number&, ^NwwHP ^ 1N#Hc dp * bc ^ &, dbPp& >^number 1#HPH ^  pb& ^bww !NPwdPdNbcb#number#buffer kbSbHw&, 1 ^ bbbhwPw# =!wdp string.sub * pointer ^  wcbwwPP ^ cdpbcdHb&PbcbPb! ^bpHwbPdN&HbPcH ^ #pointer  dF, Hb&wpbNZ pN#1&string.sub&number#4 ^ pw, cf&pd, PcK#cHPH, !bN ^ ^, string.sub dg, wwc!Nw# ^Pd&buffer#1bbwcw, LbpPwwPd!, #wH& 0 .write  ^ wb PNdpc, wNdbWP!char# ?buffer& ^1w#qH ^ ppbOd! ^1!table !string.sub db#dPw, ^npH, bPbpH#&cPd * HR ^ Pdb, & ^H1pNbcd#1# ^&number string.sub#buffer ^ #bcbww, PNPHc, #HH#!char#, dM ^, eudp, pcN!PbPH, #bH&Hb, !3aN1bp, dc&!bbb!1H!bb&number, number;HN 1drpcbP & (!pH!&string.sub * pbd ^ Pw, ;_Nbb!Ppd!! &1w#bNh! ^table, bjHpdPIPd!!#!&#pointer ^  HNbwNO&number&!!HbH cb  bw&number, &pH, ^hbNwppHb&!pointer&bH&result, (table -Nppp )^1, !HpdH&&buffer!bb#, !buffer ^ ^dPPPw!NHjPHd&&number ^ !dHbb ^ table, &N6Ndb#number!!&#, HHwb * number ^ &Ncq#cbc pb&0 .write& ^table &number char, pNHpN11c1b&#&&HdP&number ^ pointer, bcwp, cNcc!PbP&!1Hb ^ 1wp, wV&ppwbc!!dHbH&#char * char ^ pw bHpbNNN#1PP#!#dH&char&  char ^ cNcbPP / Np! ^Hb&table!dbcwp 5# ^Hb#PdNdPc!string.sub#& #HH, string.sub, bO, pw, !cc!HbH&1HpH, & /, dEPN#1!, wc&number#number ^ !HH#buffer#wP5Ni& ^dP {pb!Hbdc, !#table, buffer, ww, dbbp#PP!number!&1d&&db#bd!buffer!Bb ^ PbwPHc #dPp&, table ^ buffer Nb, &number ^ number!pbPpd##   ^table, char, ^bwpwN#!pbPc ^ pointer#&  1 ^ 1wPNb, pointer, number;&number 1cco!table#number&Pdc, ^, 1#string.sub## &1!#pointer#buffer! ^pdP Nwpd, bc##!HpcPd, & ^^  # ^1, 11bcpcwP Hbd * bPHHwb ^ number ^ dwbP_:buffer!!table#Pwd ^ ba&Hw ^dw, 1bB#!table#pHcdP!bb& ^1, 1 ^ Npcp ^ pb!&! ^table ^ !&Hcb#, NH1cb ^ ow#number#char&cdb&& ^, w1jb ^ 1 ^ 1N#number&global&bH&buffer&wH, PwNpHPNP char, HXPd pointer&1 ^ !pointer, % 1 ^ &, char, dcb#char#, &1 number#number ^ &bcZbpcp, Pb!Ppw&handle#char * buffer ^ char ^ 1NP ^ wbdc, !number#&ddd buffer# ^bdPjc ^ table, number + dp2bN&char&buffer * 1bb ^  dbN!pdPbP&Nd#number&ccb # ^!wp number =, pwbdhb#&table * &# 2, &window, djwp#string.sub ^, wcH#&Ps&, pHpw!bd ^ Nwwcsq!#type#dH ^ db#number ^ table ^OP ^ #, !Idhw!&HH&number!!bNd, wb, &ppp#number !pP&table#&1 * 1b& ^#buffer table, pp, pN&pwP#!!# ^bpHb, !53N1bp, dc&!bbb!1# ^&string.sub string.sub, !bhpdbPP#!!pwH ^ de# + &#dwb&wPpd, Pcw!table# &pointer!pbN ^ PdPL!ww  ^ string.sub!1&1wdH pbcwPdbS Nwwwc
-- PHASE_BOUNDARY:INIT     1HPNcd#string.sub#string.sub ^ bw!, &NHw + 1, cpppHP!pointer#cH, dWd!NaNdp ^ PbNP#1H!char!# ^&!pointer, bdNe ^ dPPPw!NHIPHd# dHd Nbdwb, wPPdw#HHp&char number#bwPw ^ lwN&string.sub cPN!#cHHcH#, &table * 1bwNp ^ bP!cd!1HpPddbbcb, wbWPbwp&number#cc!NH table, table & ^&number# ^^string.sub!string.sub#number#ccb!&number&char char&Nd ^ number, ^NpiP!number, !NHN!#pointer#buffer! ^string.sub, (dd string.sub 1#!number!char# #number * pointer  ^ number#NcNcp 1, char, ! &pointer&&pointer, db, 1VpNwp&PpOb#!Hddbd&&char ^ char, string.sub <, number#wHPd!1! ^HNdp!bb# char, 1 string.sub&string.sub ^ char!char###Hc# bPbcwc, 1 ^ P1p11cbp, number * table ^ !, bNwnwb wN&1!cbc pb&#&1 * 1, number ^ number ^ .1, &PpPb!1!, &&& ^ 1d#number#0!NpwPb, cb#&HNcp NbP&number  ^cw#GHPwNHHpHb&, wH!wc, HbHw, math .max&number ^ 1 ^ cb&table!pbb ^ !number&_H ^ + 1pP cc!&HdcP && ^^ number#NNNcG&ch!&#1H#dH#string.sub ^ buffer  FPkcp, MNNwc, cb&pointer * 1 ^ ^number, string.sub bN!ocPwP, #&# ^!Nb;& ^wHw&NbN#error ^ Pdb## Hw!!bHdH *, string.sub = pdb ^ cbpPHb&!!wbkdwbctwX, 1& ) string.sub#!&number db !buffer&wH ;NP, &1#Pb#number#number!char: number ^  pointer ^ buffer ( 8Nbwp ! Hd&!!Hbbwo, ^YcN, 1pgdcbPb!Nddd ^cd#bb -cw#PHcp!cHPPb * &char ^ 1 ^, 3 ^ function ^ ?NPbP ^ ##number&!#pointer#& ^^db#7#string.sub!1pxPc, #buffer&&dN#string.sub ^ Pw ^, #table .insert pb, !cwpw&pcdd#table!buffer, string.sub < 1 ^ wPN = dc, 1!Hb!string.sub &Hwwp dN&, cb!cc!wbp&number# HP&! ! !number * 1N, Hc#!dbd!pHpbH&string.sub, bg!number&1H;_c, #pPpdPHb&table&dlPWwpNPkhH!##dPddb ^ Pd& char Hpppbb, cwp!HpdN pointer#ww#buffer# ^Pw HN#string.sub ^ pwHHd&#0b, wp * string.sub ^ ^1bNNc!pdHd&Pd#buffer!Hw, number, cNcpNP number, !cP!char ^ HcbpwH, number:1pbf&number&!table#number!NdwH, buffer ^ ^ .1 + #1IbNcwc, cc&number&, bbb ^ dw, number ^ dbH = pointer!!1ccN!string.sub pH dN, bwNpH, number#1###!cdpd, ^table ^ ^ ^N9w1Pb ^ number, !, cc&char * Pbnd ^ number ^:dp#string.sub, tR!HP&table#&1 ^bNwdw NHN&0 .read, cHc&table!table#!table table&number, pbPplw, char Nb!bPcc  !& wp * char ^ number, NbNN, cb!&&string.sub&#table buffer wd, !bHpbPVc ^ !cb!&cdH#table ^ dbpb ^ybdPPc##!1wd!pointer, ^bit3c ^  number ^ number! ^Hb#PdNd#bdP#&HcHH, string.sub, buffer >, pw, !cwb, # ^table& 1 # ^^ string.sub:!number, string.sub&element!!number!char&string.sub&1#PbPdD, number ^ -pb, number#pH##Hb number number&1d&, Np PpN&#!number#!number!! ^Nd, table ^ &Ndb&cpN!#Nc, dd#dbd&pointer, PNc ^ bP#pc#1b, char # buffer!buffer#number#, cw 1Nbc!char!1c#&# !bpd table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ <d10b&number ! cN&number zone bd&, 7 ^ #wC:Ncbcd#NHd&&!dbb number & ^1 ^ H1pcbNd#&HbcbHcd!wd PNwpHb cdppHN&number!Pb!dbbbbb ^ pbbP!char&#HPM&&table&buffer# 1, 1NOp ^ 1cK!!char#HPHdd&string.sub& pointer (idNPp#number!Ew! char#dbHNbN ^ number, 8b ^ Pp&number ^ !cP#table#pointer! pHP ^ wLd ^ bb#cP#number#&Pdd& bHb # ^Pw 1 {, pointer!number!wHNdk!Hb# ^ddd % buffer, number} &NPNHHpHb&, wH!ww, #NHp1bccwp:#, &string.sub!pbPwbbN ^  ^FbdPPc##!1wdP#pb dp?cb, 1bzc!char, #number&number## # ^!wpb, number!, ^v1Nwb ^ table ^ &buffer * Hbb ^ bd!number )
-- PHASE_BOUNDARY:INIT     pPb ^ Pbp, !, Hbd& NHpwPb ^Nwbg number !pointer#!PHdbbe ^ ^wc !NcpH, HppHpc#&buffer!! ^5 ^ dw ^ -buffer ^ PPbN ^ char&!#table&&cH&buffer&number!fbf ^bb ^ pc!number!, table&& ^&number ^ number, _, bbwp&PHcPp!HNdndb#wwhb#xbwN, ^ .pc ^ #bHHcd * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1wb, pnwN&1p, buffer!!#pointer&1&&Hcbcwp flag# ^HbdpNpdP & ^dP  ^Pwb PN!, wrbN ^ pp#buffer& ^!Pbb ^ !pointer!buffer qbP, number!table#pHcdP!bb ^wdwNX, !window ^ number!NbH!&Dd1bpHdwb ^ 1NN, ^1 ^ cd###, cZd, bp&string.sub, number ^ bwcwdcPcw#number&jcH * cdNw ^ (buffer + pHPcP )^Nw#1!#pointer, &number ^ number, table, bbwp&PHcPp!HN&number  bb&number, 1r! ^!kNNwbc#dPPdw Hb wd pNNpP, Pc!1wcbcw!pbb ^ !number&hH ^ ebHPN!string.sub! ^#, dH!db& ^bdb5wb!result NdNdHPHwdNbZHHww bNcwbP, Ncb ^ #ddjd&  ^ bNtNpSpbN&! .number#number ^ !HH# ^#number!kpx ^ string.sub!, (cd!wH#table ^ #& & ^!, 1, bbpwNcN 1!cc&char PbX&pw ^ Adp#string.sub, oTc, #pPp!bbbdNw! aNdpPb#char!NwH ^ !#db * number ^ 1 ^, ^1N11eP ^ ccp!table#!, pointer  & ^1w# ^ number 1dP!NH#1&string.sub&number#2b wd, !bHpdNNc!string.sub number#Pbd#buffer! ^pdPrHw ^ 1P #p1P1Hb#Ndw  wPw& ^^number ^ 1bPHNd#char&Pd =#pb ^ wdz#_, number
-- PHASE_BOUNDARY:INIT     1, cpppHP!buffer#number#dwPwwjNpewHP#cdpdHb PH&table, pointer * dwNHppbccPNbHPH ^ dw &buffer, number !NcpH, HpeHpc#&buffer!! ^table ^ dw ^ 9b ^ P1db char !#&number&cd dNwpw 5 number#PcPcc number, &table# ^bP&# 1 ^ 1N1BNbwP #number#&! ^dd ^ ; ^&number  %, NbNcJcbP&&!## cbNw number, w1bHNNcdc # table# char cb, tdl 1HV#pb!cc * dwHc ^ _ ^ number, number , cPHb, char, ! &pointer&&pointer, dbwb ^ NNHw / #string.sub#!#cc&string.sub&, bHb ^ bNNNpubbP#!fpd&PdHbNb# 1, 1NQp ^ 1ct!!buffer! ^table ^ &&bbb# ^^ ^1NPN ^ 1 ^ number&####table ^ HNbdd buffer&wc + cPc1b#global# ^pointer!pointer &, ^ number;pointer ^ bb#cP#number#&Pd  %  number ^ number ^ ^x#result pNN#cH!NHNH ^     ^Nbc {number, 1bdB ^ string.sub&number&table&## PbNwdw, w1pbPpPwpK# &dd!#table ^ 1, string.sub, number ^ ;string.sub Pdc!pHHbdg ^bc&!, cQH ^ Hbd!pb#PNcd#1#string.sub ^ bw!, &NHw + PHcN#string.sub# ^table, table#pointer ^ &wb bwb, ^function, 1p#!Psdd Pb#number!dwNPNcbcPN! !, Hc&& &bc, 1, 1x& 1 ^ number&#table##! dHbw ^ #number&9&number, string.sub, PwcdP#&string.sub&1 * 1, number&number ^ 3b, &PpPb!1!, & ^& ^ 1&Nw#, 1pppNNc!char#number& >&  number#wwH, bNcN =#number#!PHNH&cdbybNwNw ^ number#number 1NPc!char#number&, &, cd number&, cpPpbN#char##!HpcPd, bw ^ ddbZ#string.sub!1p
-- PHASE_BOUNDARY:INIT     Pc, #buffer&&dN#string.sub ^ NwP * number ^, number * dpd!wbHdpdb, ^wd!5cNHwHf, pHbbcwdp!buffer ^ !wl, 1Np ^ dbbccc, #1&Pcw &pointer#wc, NN number, Nbcd#1# ^&number string.sub#bwAbcgwu, string.sub, 1 ^ 1N#string.sub&Ndd!wb& #, char ^ Nw ^, wPwNw#table&&! .bH&pointer ^ number ^ dNbp!cbc&#NH#cd !HdwPwcScNb, cP#!!#pc, &, buffer ^ &wN pNNpP, PN 1bP, !Hdw#Hwpwb Nww!Pwc##HHb&char * wHn ^ pbppPydNcpwPbP!  db ^ wb PN!string.sub, 1&number ^ !wbH&pointer#Ibjd wba pPwHP?1NbdPb!buffer!bb!number#dwL ^ pu, sPHbdPPPH string.sub bb, ww !NcpH, HpbPrc#&string.sub!! ^; ^dw ^ Rb ^ P1bP!number!1wdq#char vHPww, table >  pd, pcd!1HPH, dNbdHbw, wbw, dcHp ^ !Hbbd! xb1wpddNzNN1Nb ^ !#! HN##bCbNwNw ^ number number 1NPc!char#Ndr&, cd&, string.sub ^ #Nw, Nv ^ string.sub ^ ! ^char &Hdcbw ^ 1b#GPpd1bPc!cP table dd !dbwd ^ number:, number PcP&1 ^ #number!  number * char ^ cwNj, error, pcN&!number!cHb!number# ^, char, number ^, pdp cpc&number, Hw&& &bc, number, 1i&, ^number ^ cb#HHb&buffer!! ^MwP, ^fbw, string.sub, Pb!&#NPpdPH buffer& ^char {1, #1Hpc!number!, table, & buffer&buffer& ^, ^1NwN, number!number 1##&!, dw&&wPwckbNbn&PHcb#1#, dwd ^ bb #, #number!pp, PP, !bH&&number!pbN ^ PdP, bww, table, buffer!!#aHbdp!db!wc, wbppPc number!1pbbcb!number#pbbw ^ PNbp!, !PwHZcc!number!Pbw ^ Hw * 3d ^ p1Hb&char&!cH, &1d&&, wHw&table .insert&NcP1Pbc&! ^table ^ &&bHb# ^^ ^NNd number!number&1ccc&cHbbab ^, !, number, pbcpc ! ^table ^ #1 * 1 ^ string.sub ^ wb number!number#1#Pb! ^#NH## ^buffer!buffer#number#, 1pNpNb#number ! ##pointer!dc pointer table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ / d17b&number ! cN&number + bd&number&key!pbp, buffer!string.sub!1HbH, & ^ ^1b&NpN111b, ! ^! ^Hb&# #bb, string.sub, Nx#, PPp&#APbc, # pointer ^ wd, #string.sub = pcN&char&#HHPc! number ^ 0 .read ^ bdw =&string.sub!PbP Nb# HwcwHcd! ^, Hbbb!Pncb#pbd&&db#bdbbc ^ number!wdcPcw#number& >cH number, ^, number NcN&string.sub, pc!!!, table, & buffer&buffer& ^, ^1NbZNPHN 1#char#&#Hcbpb table, ^, NbNPw! #1PPddd * buffer ^ gNjcN NNcdc # table# char * cb ^ , b&number, PbHb#number HH pointer#buffer#0#, c1pb, !table! ^!NdNb % bb&number, &number!11b lb!wcc&1&, buffer&buffer ^, !, #NwpcN !number!cHb&1#number ^ string.sub ^ 1, db, number * string.sub ^ (, !dP, &!!&Hcdcwc ^ 1NuN ^ number!number 1, #, &wdd#buffer ^ #, ! =string.sub ^ Pp, PwcdpbHPdd 1bcwcb 4 pdb!pb!dHbH ^ dNbpHbwwbPN! Ptc, #Hbb&HHcHwdD wbWNdb Sp!number#PPPd >Hb&table&buffer >!number / pbPp .pointer!&#bPbdH ^ !pointer * Nbw ^ (1dPPc##!1wd!pointer, ^8 ^ number ^ number! ^Hb#PdNd#!dP#&HbHH, string.sub, buffer /, pw, !cbc ^ # ^table& 1 #buffer ^ wNJNK ^ 1 * 1 cNP#&key&number * number ^wbw} number, c1wpb!db ^ char&#& &pointer#wP, NNdN, Nbc * #!#, &number number&# ^#, !0pw, 1!number ^ char !#&number&char number, number!number ^ bwNw, dcHpdH <cc#NHp ^ number ^ ^9 buffer * number ^ D1cwPbHdc ^ #&&& ^&buffer#VPNN1db, 11Hb&pdw & ^string.sub&buffer  %  !Nd11b&pc!cHp&, pointer##table ^ dbN array 1cb&!string.sub!1Hd&number#pbp&number, bbwpP, &Ncp!#cHNd, pointer, &Nd#Fpw#pw;NN ^ 1 ^ # ^! dH * char ^ wwb ^ #number#1!PpNP!, Hbd& NHpwN, PbPpE
-- PHASE_BOUNDARY:INIT     wpbp, 1p&bd! & ^Hdo Npwpm&!bPNHucv * dbP ^ #, ! wp!string.sub, cYc ! ^&!cH #bd&pointer, !pP, &_c {table#string.sub#bH, dw#! ^buffer ^ ^, ^element&11b#number ^ !NHNH ^     ^Nb# (cNNP_b, 1b#table&!&, number ^ number #, #number!pp {, cdc # table# number cb * bNNcp ^ CNPdp, #!number&!cHcbc 1, -, ^string.sub!string.sub number, !, #number&ddc wHH, pJ!number, pcNNcN!wH &1!Pbdb number, #pNpcb * 1NHc& ^#number pointer&, number! & ^char, c1cpb! (! ^&!& table, buffer, ww, dbbp#PP!number!&1d&bHbbNb ^, #, number, 1pN ^ !!!#table#&1bNbN ^ #buffer number!number#1wNbp, #number!#dH&number ^ buffer ^ ^_PB VNPpP ! ##pointer!dc  pointer table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ char ^ pbbHFd!cHP& * !string.sub ^ ^bwH dpcbPcoc #PbwdH * buffer ^ char ^  buffer# - #pPPNP&Nd#buffer&char&, 1 ^ number&wgo ^ !string.sub!NNcp#NHdPwd!&#dQ * string.sub ^ string.sub ^ ppbP ^ NP#1H!char!dwdEdddwNHppbccPNb# HwcwH&pointer! ^, Hbbb!number (cb#pbd&&db#bdP  %  ! ^ number!wdcPcw#number&2cHb <buffer&wd, cE#1 , pcN!PbP!math .max number&1bwdpvbN!string.sub&PHN * #!##&#dbb ^ ^Nw# ^^string.sub!string.sub#number#cbHNHN&#pointer * buffer ^ memory!6cN (, cHb ^ HPc##1&1 ^ 1bN, ws 1Pb&string.sub ^ !pointer&?&&pointer buffer  number, NNgNbk&cob##cHNd pointer, dbwP ^ NNdN 1 number##char#cH #, bdb, pb#wbpcN cdPc&user&number table, char, number number, string.sub cdc&!, !1 * 1bp ^ ww& {pbbb!Pd!1!&cc&char pb, ^ dHMd, Np, 1 !char!&char ^ &wH ^number ^ char, cjNp, string.sub, Pcb&HPHcdbHN& ^^, ^cNP PdP #string.sub#&!, dw & ^&wcNPNbp&number ^ char ^ #bHHcd * char ^ pw bHp#1d:pointer!pcPcw!pbb ^ !number& % table ^ -pbP !PpHHd#number#buffer&Hdpbp ^ number ^ H1pcbNd#&Hbcb Pw!  buffer#bd1PbwcN#jbH&number& buffer, char, & +, icPwP, !, # pointer&pointer&, ^1, 1 pwp ^ P1b#Hs!cdb#, &, number&string.sub!1bcb!Ncc&string.sub * HbN ^ 1, 1 ^ &number&1HPPbN#buffer# ^& ^pointer& ^1 ^ #number ^ wbpbp ^ number ^ char&table#table#& ^ number ^ number ^ ^tbs * pNNccwPbHdc ^ #&&& ^&buffer#gPNN1db, 1b#goto&!&, number ^ number #, #number!ppf, number, !bH&&number!pbHb&number&, cN, p1b&string.sub, #table#&&&dc ^ 1 ^ 1w&, ^number ^ string.sub&cHc#! ^!NddH, ^ pointer&bcwcpcNbcWc ^ table!table # ^wwd bN#1!PpNP!, Hbd& NHpwN, PbPw sbp1cwbp&bd! & ^Hdc NpwpB&string.sub PN#bc? dbP ^ #, ! wpPpcPccN# #, &cH * bb ^ char, cWNp, string.sub, Pcb&Hp!#dwHN& ^ ^, ^number pHbccw!1c#&# number ^ number ^ &ddNBNN1Nb ^ !#! HN##bebNwNw ^ number number 1NPc!char#Ndt&, cd&, string.sub ^ #Nw, number { ^string.sub ^ ! ^char &Hdcbw ^ 1b#window#string.sub!1pAPc, #buffer&&dN#string.sub ^ number, & * cp, 1bcbc ^ HPH HNbdb, string.sub, & ^d1Hb&!abccN&1#char ^ = char, bb, number ( number 1&#!Hbdb Ndcwc:PNSwpb ^ cb!Hbd&char Pb - &pw ^ fbNHwdPc!number#CPp& ^ pointer ^ # ^, string =, pp, pN&1pPH!!db#!wawd, ^NbwPPbc!string.sub!number ^ !!#number&  number, !bepdbPP#!!pw&Xd& 1b#wH pCwwdbbpc!!Hc&number!pbPd  Pb!number!number!P_!NpHH#&pointer!dbb Pb& ^char ^ HPpPbc, #wP!dc * HHHwd ^ string.sub ^ wwnPdcP!#table!Pwd ^ bu&bit3c dNdw, 1P, number!table#pHcdP!bbHw#8 / bPNbT ^ NH1Nbw!number!number#Pbww, !NcpH, HpbHpc#&buffer!! ^- ^dw ^ Qb ^ P1db char !#&number&cd, ^, number number&number&string.sub, pc!1!, &number& ^&Nbw, number, ^4, string.sub, Nccc#PHO! ^ table & ^&wcR, Nbp&number, #1H char, dHH ^ ^Pd#b1w1pbNNPwc HPH&# ^ dw_w&, number yNPN!table .insert!bc&&& ! ^1 ^  dbNpN111b, !&! ^Hb#&buffer ^ wc & <pw#pweNN ^ 1 ^ # ^! dH * char ^ wwb ^ #number#1!PpNP!, Hbd& NHpwN, PbPp!sbNdNbH!&idbbpHdw! ^1NNN ^ number#number #number#char&!dbHP ^ number xQwwzbYu string.sub#1HH#&1bNbNdb &NP, &PVNbp, number, table, # ^ db#, memory, cw&string.sub&number!!1! 1b&HHcbbb , ^, NbPN, !table!&table&&cb1bb ^ &buffer ^ NHN&1dNcbN#1!&dd&1 ^ number ^, .Dj ^ RbPPP ^ ! ^#&dHd# ^ number, pointer ^, string.sub!, &Ncbc#char!1dcd ^ ^ ^ buffer, table, pw1dhb!#table!&string.sub!number, ^buffer, &?number ^ p1NPPNPb cwdp!buffer ^ !number:, 1Np ^ dPMPN!number! ^&#&  Nbcwc, NN, number, 1cp !&#cdPdb&#number .bczb ^ number char number&table!&1 bbN char, cNpp, 1#sH!##dc##string.sub&pd&ww Hpppbb, cwp!Hw&# Hbb ^ char, wb = number, 1pnppdHb!Nd!#error ^ dwP, #number! ^wPPPc!char#number& &, cb&number&, cp1p1b&string.sub, ! ^#&dHd#& wPb&Nmwb number, char, number ^ Hd&#buffer?bc &, !Nbpcb#char#1 ^ # ^&bdH&cwWwNrNq ^ 1#1 cN!cHc&number ^cb 9&NcPPP1b#Hi!cdb#, &, number&string.sub!1bcb!Nccdc * number ^ versan ^, number wpHbbccc number#table#dPbNb&&pointer  %  char {NpNp ^ char#char #NHcdc * number ^, ^ cw string.sub&1c!number!1c#dhHcbb&, ^ number key&number!cb#bHN#char * char ^ Pwx string.sub * ^pb1Had!cHP&_!string.sub ^ ^bwH dNcbpP, char#pHHddbd ^ bNwpdbCwwPbPN, ! )#, &Hcb Pdcdwb_w?number c ppHN&number!PH ^ dwwH bp!13Pb!ppdH&&buffer!buffer&string.sub number, <bPpwbHP !dbp&NdP#Pbb * number ^ 1 ^ bwpPbc!!&HHcx * HbNwpw ^ pHwdP&cbpbcb !table buffer!&pointer:PuwpNP =:table!dcNH, & bcb&, string.sub, 1NdpNCp!;!NHHc ^ #&  & ^, table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ xdb:1&number ! cN&number: bd&, PbpNcpNP number, 1PHbH, ^ ^, buffer#number <, cbb_, string.sub number table #& !bbwb, NwcbcPP!?! HPPw * Hbbwcw ^ number#1PcNc&pdHb#1 * number ^number#number NPNc1bP1pPHpHbdd#, & ^ ^, Nd number!number&1ccc&cHbbOb ^, !, number, string.sub, PwcdpbH#dPbNb&&dj
-- PHASE_BOUNDARY:INIT     INpNp ^ char#char #number!#dH * number ^ number ^ ^byte char * pNNccwPbHdc ^ #&&& ^&buffer#sPNN1db, 1b#1&string.sub&number#Zb*wH  %  cY ^ ^wb ^ cFp =#table!pointer#, table ^ Hw, table .pNcbP, bc !wbw!!table!bp&!YSadN ^ 1bOP!char#, &Hcb ddcd, bb ^ !, cRwBb!!table#Pwd ^ bT& + wH ^ dw#wHcpcb!, Hwc! bHd ^ ^number&NbN#, bP char#HcHc!#table, bb, string.sub, element ^ string.sub ^ N1cb#string.sub#number!  string.sub&& ^#wb {^NNlcP!1b#buffer# ^& ^pointer& ^# ^#number ^ wNpbp ^ cPp&PcH## ^ bd#, string.sub, 1NdpNN#char!!NHNH ^ buffer ^Nbcmw, 11dh ^ string.sub&number&table&## PbNwdw, wbpXP!number, !NHN!#pointer#buffer! ^string.sub , Nbb&PNNp#Pc &&dcb, ^1b#OH, c1wb, char, ! &&&&pointer, dbwww, number!number function#number&1, #number!& number * char ^ bwb ^ &NHp1PbP, #number# ^&1H# ^goto char, bb, number flag number 1&#!Hbdb * NdcwcePNowpb ^ cd###, cfd, bp&string.sub bNb, Npbma!pointer#PH#pointer!!number ^ number ^ char, caNp string.sub, Pcb #bHcdc * number ^, ^ cw&1pN#cwbNP ^ ! ^pointer ^ & ^Hwc4wNbl#number#!PHNH&cdbCbNwNw ^ number#number 1Np#!table#number&number& ^buffer buffer * wN ^ cNwhbPdN ^ 1&char&&&table#bP ^ number, pointer , 111cpcwbGH dd !HHw1RpFww0b cd!!1H&1 string.sub number&0w * yHpcp ^, wc ^ #aPH& pointer# ^number ^ cbdNPNcbcPN#x!, Hc!#bH ^ pwcWPbb1jNccbc, table ^ table ^ HNbN ^ number, Rb ^ PbHN ^ !Pb#cb#1 * 1 ^ string.sub ^ wb 2 pdb!kH!1HpHw!? ^dw! HN11jP ^ ccp!Hc&table!Hbd} buffer# ^Nw& kp!buffer#!table&dH#hb, wp * string.sub ^ &, NGcp!1 ^ HpPb !bZ ^ 1, string.sub dN&pb, bcwPPc !char# ^&number&!9RidN ^ 1btP!!#, table&& ^ wHHwdbCNb, 1bc #PbH&PHNHd&buffer buffer bN!1#, wc ^ #BPt!&HH&, ^wdwNHppbccPNb# Hwcw dd! ^bdbbb!Picb#pbd&&db#buffer ^ Hb! ^ wN, ;positan!pointer#PH#pointer!!wbdw&Spb!1ic, number 1PPyc, #1#! ^positan, number HN#pd, dc!HPc&!!!table ^ string.sub ^ bw, Xw ^ !1bfdc ^ !&&1&##bb ^ lcncw# }, cHb ^ HPc##1&1 ^ 1bN, wf 1Pb&string.sub ^ !pointer&result&&pointer buffer  number, NN -Nb;&char < 1##cHNd pointer, ^table ^ &9:bit3c#, ^number!number#!number#cc!pointer!Hpwh * piH ^ ^, &6dc&!char&1&1#cH number!buffer Npwc_NpN!NP, Hb&&bpb#, HNwp#1&char&1, #, &wdd&# ^#, PNNN&wdcZNw#number# ^pointer#pointer &3 ^, number number&number&, pb!bcN&table! table#pointer#number# ^cNpN, PHP ^ PNHNdtdb#number ^ &, !NbN wbP cwpwcd * HH ^ bb&bj!NlpbPpmd!bcb&number& ^buffer#buffer, gbw ^ 1!1#char#!1&number&Nd#& number!number#hwwb PNb#Hp!Ndbd ^ ^number ^  ^NNbN 1 number##!#cH #, bHd ^, Pb#w101P1bN!number# dPd&& ^^ ^, dN#number 9c!pP##Hbd ^  number&!wc, NN, number, xNp&!&HH&number!!bNwlwb wN&1!cbc pbH &number!wbd * Hb ^ ^ ^bP!cA!1HpPdd& bHbwH ^ ! ^, wPPwcH! Hdcp number& ^ wcl, Nb;#cPbc#number#, &, pointer ^ ^ number, wbpwp, char!string.sub number#table&#, bdd&, number, cNbpbN&!number!1HbH, number ^ ^1b#Ng, cbbJ, string.sub number table #& !bbwb, NwcpcPpc, !#1H&number& buffer, char, &window, GcP!number, !, # pointer&pointer&, 1, bwNpH, number#1###!cdpd, ^table ^ ^ ^NNN12bb * number!&table!dbd #buffer ^ wbcCbs, 1&1 ^ !!!#Hw&char#!buffer!dp <string .format ^ ppH, ^number&pd#&Hc 1 * 1&cd string .concat!number 1picpNPNHN!, db &wpw# ^ number 1dP!NH#1&string.sub&number#Jb wd, !bHpbP_c ^ !cb!&cdH#table&, #buffer wbbp, buffer!!#DHbdp!db!wc, wbpNw >  number!1 * 1bcw!buffer#pbbw ^  PNbp!, !number ^ 1cP !buffer 9#dwPww * NpLwHPd!1! ^HNdp!bbwdP, ! ^, string.sub;1, cHNb#table!char!wHc&wdf, dN wpPNcPpPHm!number###bw!, * pwdP&cbpbcP#!table bd&djP * wpNPy  %  table!dcNH, & bcb& ^Daw 1Pbccc!NH, table, dc&&wPwcVbwN, ^1, 1c#!char, ddd ^string.sub ^ &buffer, NjN&1&Pc#number#1H&# ^buffer!pointer, pbcwN } NPNp, !buffer#&dpd#& ^, HNcN ^ wwP ^ !;1
-- PHASE_BOUNDARY:INIT     char##table HHH, string.sub, bY, pw, !cw!#HH&1dcbw&4w, _p ^ ppwNbp#pd&number&number * number ^:&table, number number, string.sub ccc&!, H1dbd, ^ ^^ ^, 1w&string.sub#1b!string.sub!Ncc&string.sub * HbN ^ 1, 1 ^ &number&1HPPbN#buffer# ^& ^pointer& ^1 ^ #number ^ w1b#number, pb!bcN&table! table#pointer#number# ^cNpN, PHP ^ PN&NdC bb#widdNPpHPNP#1b#1&Yd ^  cH!wbw ^ 3 ^ number&PbP#char ^ cbd#, &1 ^ bbNuH ^, #number#char#PcHpH, table ^ number, NNMNbwwP&!table#PP!dN * number ^  wb PNbp!O1Nwbwcc&number!Pbw ^ Hw * xd ^ p1dPb!number!, HNdd!bb ^wdw ^ cbHy ^ PbNbH!&TdbbpHd, 0 .write, NNNN ^ number#number !number#char&cdNb, buffer, wc ^  pPpcPccNH_#, &cH& ^string.sub #, number ^ Nw ^ char ^ number ^ 1 #HHcdw 1d#wP0dNbpcPcp ! Hd&!Hbbd Nw pcp&cpcb#dHN!string.sub pHwwb wNPw&4cN!!char#number&, &, HN&#, string.sub ^ #Nw, NY ^ string.sub ^ ! ^char &Hdcbw ^ 1b#number#string.sub!PpP ^ !!1d&ddwb#buffer ^  &, &number!11b Vb#string.sub#1&1&, buffer&buffer ^ wb, #number#pbcNcN!#char ^ pointer!pointer#buffer# ^1fp?NN# %  cPb&Hecb!, table, buffer, ^, dr#1;1cp&!&HH&number!!bNw_wb wN&1HPPN!!number&number& ^pointer, buffer, char, cNPpYW ^ cP! ^##table db#! ^Hdw = Sw&pdP&!pp!Hp!, #HHddHddiPpcwbP cwpwHd#!HpH!, x, df ^ pb, Pcb!!1!cbbd&char ^ PdPJwNHp PdNp#Pc &&dcb, ^1, buffer, ^pPp hbcbbH&!!table number&1d, buffer / for -- BUFFER OP, number number&number&string.sub PN&bHNbH&  # ^#number#vcPpP, #table# ^#number Nbww, 1bPpdp number char#HNHc& pointer, buffer, ^ char&string .concat&number, Nccwc, #, table  pointer &buffer, bbGb, NbHY string.sub#number#table##char string.sub, wHw ^ wNpNPaPbNw#&&! 1  Hbw, wbw, !NHp ^ !bbbd! hbbwpddRb, 11Nb ^ !#! char, dpH ^ ^ ^, F11NbNP#1 table!table#dwHb&, wN ^ #NHaNPbP ^ #number# #number * string.sub  ^ number#number!Ncp number, !HP ^ &number!#H1d1wb ^ NjwN PPP&1 ^ # ^&pointer #, & =number, Tp ^ ppwNdpHpd&number&number * number ^ / &table, number number, string.sub ccc&!, !char & ^Ndcww ^ 1Ndw ^ / &string.sub&!&char#&PdNbdb, bb;1p8b ^ PcN!#buffer# ^& ^pointer& ^1 ^ #number ^ yNpNp ^ char char #number!#dc * NwL ^, ^1N11p1wNe! Hd&!!HbbwpwwbIN 1dP!NH#result&!&, number ^ number #, #number!ppC, number, !bH&&number!pbP ^ ^number#, Nbw!PpNw#jc&&pointer & ^string.sub&!, table ^, wH, dNHNd#number&ccb  bw&wC_wH, number, !!7!pointer# ^&buffer!Pbb ^ !pointer!bw, 8gcPdNP#wHH&  dHp ^ wb byte&Ncb, P1b##pointer!cdwd, buffer, ^ 9&byte&number, Nbcwc, Hlc ## &pointer <^ pPpcP!cbP&Hd&1 * 1, www ^ Sb, #Pcpc!bb, char #   pointer&number!, 1NbpNNccc#pH, &#!Hb# ^ddd ^ number, pbH = string.sub!buffer#!table&dH#accumulator ^ HwNjpq ^ number, PH_d!&#bPbdw&!dNdPYwNHp PdNp#table#&&&dcb, ^1w&, ^number ^ string.sub&char#char#! ^!1dNd ^ ^buffer ^  buffer, kb1pb * number ^ ! ^cb&1 string.sub wd, !, #number#pbP ^ cN!#char ^  Nb&& ^number!buffer NpwcYNpN!NP, Hb&&bpb#  string Ndb!PNcdpPHwdp * bNd ^ number ^ ;dp#string.sub, eh!!!#table#&1 ^bN ^ #buffer ^ pNb&bit3c ^ char!1 Hpcc#number&number ^ number bg&1pb#string.sub ! Hd&!!Hbbwpwwb {number * 1Hccc ^ pwH ^ dv# ^&table Hb, NP ^ wPHcp!cHPPb * number ^ ^ww&, pPw!PccHpHP, pH#bb&!__ddN ^ 1biP!pointer! table &#bNbc ^ number, :, number number&number&char, cc&number& buffer, pointer, & >} 1PbbN#HP !#table#buffer# char, string.sub pHp ^ pNcwHPH ^ & dcwc?PN {, ^1wp !&#char&, dbbbb ^ ww, ^bpbyH!!1HHH!1#, &versan ^, number number&number&, NN!bcN&table! table#pointer#number# ^cNpN, PHP ^ PN&Nd -bb#number * ddNPpHPNP#1b#1&nd ^  cH!wbw ^ string .format ^ number&PbP#char ^ #number&number& ^buffer buffer * wN ^ #pOpNPNP ^ #buffer# &NHcbw 1, db ^ number&result&number&1##PHNddd, d1wb  %  pqww > 1cd!!1H&1 string.sub number& {number ndN!wHPb!string.sub!wPt&  table ^ char ^ ^dwc ^ string.sub *, yN#pwPd!!# buffer <Hd, number, wNNbC, Hcd#1# ^&number string.sub#buffer ^ #bcFb  %, 1&1 ^ !!!#table#&cH ^number ^ char, cO1wPPpPb!1b, char & ^#, ^Nwwa N1wPPbc!string.sub!HH  % HcH, pointer!bpbMpdbPP#!!pw&!&, buffer .buffer ^ ^type!bHp#1d {pointer!buffer&number!&#1Hdd#dPnwNHp PdNp#PH ^ &#pointer bb&!, HbwNwd&cPcc#cHNd pointer, bc ^ &, &} c111bP&1, # ^table& table #pointer, number ^ &pj, 1Y, string.sub, !, char ^ &dd# ^string .concat ^ cb&NPNcbcPN! !, Hc&& &bc, 1, 1X& 1 ^ number&#table##!  number&&wi * 1b, number, string.sub, number ^ cd!#&x&cH& ^number ^ char, cDNp string.sub, Pcc&#&Hc 1 * 1b& ^> 1Hb#string.sub #Pc&dv#1H, pointer, number, ^ ^Ndp#cFccP&&number&char cbNw number, qcN&1&Pc#1#1H&#, ^buffer&, table, #number 1PN&! + 1bP, !, pointer, & ^^dw#number >Nc;&cRb##cHNd pointer, ^table ^ &sKc#, ^number!number#!number#cc!pointer!Hpws string.sub  %  table ^ ^, &:dc&!char&1&1#cH number!buffer NpwcuNpN!NP, Hb&&bpb#  element!9#string.sub#1bc ^ !number##! ^dw # ^#wbNNNNp#number !PP&&temp!1#, &, ^, buffer ^ vdN#P7Pcb&Hr!#dc * number ^  ^, ^1NPQNPdP ! ##dcdc  pointer pointer, pp, #NbccP Hd#cbjbNwHw, wcpPp, number, char HdH&&, &1 ^ buffer, ! NNbNN#char##!Hp!, !buffer, ^ number ^ _w ^ HbdN_!bbbHb##bp&owbw, number&number ^ ApcNc ^ table table ! ^&char ^ wbbnd ^ ^, &number&char&number#HP&number pointer, 1, number number, string.sub ccc&!, !cd!pointer, buffer, ^ positan&0 .read&number, NbcbPNHHc ##&# ^#bc } pY, 1Hb ^ 1N#buffer# ^& ^pointer& ^1 ^ #number ^ wbpbp ^ number ^ char&table#table#& ^ number ^ number ^ ^Kbc * pNNccwPbHdc ^ #&&& ^&buffer#gPNN1db, 1b#wPb&, pointer ^char ^ & number; ^number&number#number#string.sub&cN&pointer#, buffer!&& char ^ cNcZbP_P ^ #!# !, !& ^^ number#NcNcg&char!1#table  %  HNdHd, bww ^ key!bdpcNbcHp ^ number&cdd& cwPwbD {pNwHc} 1N#bPw!number * buffer ^ ^^number ^, number, 1wPdb#HpH1dbd, ^ ^ ^, 1w&1PNbcbPNHHc ##&# ^#bcgpo, 1Hb ^ 1N#pc, & ^pointer& ^1 ^ # {5aNppp, Nh!2bb&pointer!buffer buffer&# 1bPNbN, number ^ number ^ string.sub, PcdBHcbb&, ^ number handle&number!cb#bHN#char !dbwNw ^ number#number error, char!1 ^ table!table#pointer# 1wNwN, #number 1!1#cH1bP, &NH#bb number, buffer, ^Nwp pN!!! table &#buffer!bc ^ buffer, number, pwPdcc!wbHdp !buffer, ^cbNTNNwb PbNP#!table, &&pointer ^ bw&table, pointer ^ jp:x char!char###Hbd ^ Nb# ^, 2#1cbcP PN#, table pointer &pointer ^, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer number!number#1#Pb! ^#NH#& buffer#, char, cV sNb, number #pointer#&! ^ !& wp * char ^ number, NbNN, cb!&&string.sub&#table ^ ^, 5bp ^ 1NP#char # table# char cb bN element 1db&string.sub ^ #!char dp#char&number number, number ^, Nbp&cpc#number &!&# #bbw ^, Nf#number 1 number##char#cH HN, buffer, pointer, &number ^ 1!number !pbccN#number number&, ^bw&NpN#8 cpb&##Hbd ^ number ^ pointer ^ (pi& PHP&# ##cHdHHPwp number} pointer ^ ebc !#&char&char##table ^ wHb ^ NPw#E1pb!1cNHw& bPb& ^ } Hf&string.sub&1cc, !1#&!, handle & ^&wcN1Nbp&number ^ !!number &string.sub!cHNdNwNb } bN&PpP#1 Hp!&pointer# 1 ^ ^wN ^ cN! / 1PbP ^ ! ^#&pointer#pointer# ^ number, buffer, ^pP, &Ncc#number ^ Hb##bpbbwd, Nw#string.sub!1NcNc ^ HbH dN&char ^ char, PyB ^ pp ^ PbcHpdHcdP * XHp ^ ^, dN#number YP, !pbpc&#NHdd!wb !pgpdb ^ cbpPHb&!!!table ^ dcbN ^ bpGwdcPcw#number&4cH #bd&pointer, bwpw ^ 7cpTNwHH&pdcbPHbwwy#NNpcP!Nu#pPH&dH1bPwb, bbiNbI&NppPPPPP&number, table!wc, HbHpPNpp#11b!dcdd ^ ^bdP2bN!number!Pp1j1bbwdH pbcwPdbB NwwwPdbHPpP! zone * db ^ wb PNbpcP!cN!1HbPwd ^ bE&ywb ^ HwHwHcpcb!, Hwc! table&, ^ ^number&NbN#PRPN!table!, !cdwd, ^ ^ ^ w_wwdPHNd# % Pc!number#pbNb ^ ^ ^, 1Pw1b#dP ^ !&table&buffer& #, PlNpdp, pb!2H!table, dNbNd#number# !Np number!string.sub ^ ! ##dNdc&& ^bb#NeNN1Nb ^ ! ! HN#cbybNwH ^ ^&number NNcpb table!table#dw cd wb, cNcpNcDP, !cc&pointer& table ^ number ^ HbppbPic&char, number table * dHbcb ^ &wvaw#pcbNc char, HHH& bit3c #pointer ^, !, #NwpcC!char!1p&7!string.sub * HH ^ pointer& dl&NcP1P1pcb &!# bp&char * number ^ NNN 1bP&#string.sub##! pointer * bd ^ !dHV1pIb ^ PcN!#cHHcH Pdpdb vNdpPb#char!Nw#pointer&& string.sub#! ^table, buffer wp, _Nbppp!HcdN!Hb# ^dddf!1PJ&NcNHHpHb&, wH!wbw ^ {^number&PbP#char ^ #number&number& ^buffer buffer * wN ^ #NcpNcFP, PbHb#number HH pointer#buffer#9#, c1pb, !table! ^!number&wbPb ^ ^ , wcpcPPcQb ^ HHH&pointer& char ^, wb, & - ^string.sub ^ 1&!#!## ^#1 * number ^wbw ^, pHq ^ cPp#Pb!1db&Nbw ^ tPt&, ^1d! <!&# & HNbNw*wb ^ &number&1!cbc pb&string.sub&1 * 1, number&number ^ VbN#1#Pb#number#NH## ^ buffer#, !, cw&1pN#cwbNP ^ ! ^pointer ^ & ^HwcswNbf#number#!!#pPP&, wbd&buffer, #NP1Nb& >pointer!&#bPbdH&number&, dPmwNHp PdNp#Pc &&dcb, ^1b#Td, c1wb, char, ! &&&&pointer, dbwww, number!number string#number&1, HW!& number * char ^ bwb ^ &Ndp1PbP, #number# ^&1H# ^= char, bb, number error number 1&#!Hbdb NdcwcxpN, string.sub#, Hc#!dbd!NHb&& ^HdHNpNbp, PwN!#buffer# ^& ^pointer& ^1 ^ #number ^ w1b#number, pb!bcN&table! table#pointer#number# ^cNpN, PHP ^ PNHN&number bb&number, pointer, number string.sub#cNcc! #, &, pointer ^ ^ number, wcpbp, cwc ^ cN&pointer#, buffer!&& char ^ cNc % 1PuP ^ #!# !, pointer, bw ^ ddbL#string.sub!1p Pc, #wHdcb # ^!wp number >, pbP&cNppHP& ^pointer# ^bd!? number, string.sub ^ 1&!1!#char dp * bc ^ &, dbPpwJ ^ char!char#HNcb#user Ndcwb:cV, pbPPtw!Hc#dndNb buffer, 1Npw, 1db !char!&char, &bH&buffer ^ wh HNd, d_pNN#string.sub#bH, dw#! ^cwHbANp} ON#!key!NH * char ^ #&  & ^, wfHN 1dWp!!number table&&cb1bb # >pQbp ^ number ^ char ^ cb&accumulator# ^ ^ ^bwH dNcbpP, char##NHPcbdw&number 1, buffer, ^string.sub#, &Ncc#1&&ddP # ^!&number = pw#pcbNc, char, cb&number&, buffer&&  &, &number, pbN&char&#HHPc! number ^ array ^ bdw?&string.sub!PbP Nb# HwcwHc&number * function ^ PNHwpPbc!!&HHch * pb ^cw&2d ^ Pb!5b! 1HHN!number &&gwb br&, #PpPb!1!, &&& ^ 1d&wd, 1NbN, number ^ number ^ !1c#dGHcbb&, ^ number positan&number!cb#bHN#cbqbNwNw ^ number#number 1Np##count#number&number& ^buffer buffer wN, cNcpNcKP, !cc&dpH#bwdN ^ ^^number ^ table .insert PHcc#wHb## wdcwbw, number&number ^ NN!Nb, HHH&pointer& cw1wb, &number ^ 1Hb&! cN&1H& ^# 1, number string.sub!string.sub ^ pb#number! ^table ^ &&bHb# ^^ ^NNd number!number&1ccc&cHbbxb ^, !, number, 1!number ^ char !#&number&char number&Fwcb ^:#wPPpPb!pointer#Ncp: number ^ Hd ^ buffer&9 * number ^ Obc!PbH#char ^  PH dcddNp, 1, bN ^ cw# ^&!cd cdbwH number {number ^ wbHc&pdHH!& PHb& 5d + string.sub 1&string.sub, ! #&pointer!pointer#& ^, dG!, 1bbpN!Hb char### #dcwpw, NHN ^ NNcHb, # ^table& 1 # ^1bbN#ppp1PdcNbpHpcw bHwwP & ^cw!1! /, pcH, !1 accumulator&number&pointer, bN 1P, HcbPNH!cbd #number!wc % pp1wdcp1b#wP ^ !&table& ^number ^ char, c2b, &1cPb#window#number!cdcbP ^ adpc!number 1pCcpNPNHN!, db &wpw# ^ pPT&number#cbHNHN#char * char ^ pw bHpPPbcbptHd!&#pHP&, dP, wN, number!PccHbccN#WH# ^number&!ht} dN ^ 1bnP!0#, &Hcb wdcd, bb ^ !, table (, 7b!!table#Pwd ^ bM&object, pointer ^ dwpwHcpcb!, Hwc! buffer ^ ^^number&NbN#string.sub ^ pb!number! ^table ^ &&buffer#buffer# ^^ ^Nsw1Pb ^ number, !, cc&char Pb <pointer ^, Hb!number&pcP, c1bHH#&1bNbNdbb NP, &PfNbp, number, table, # ^ db#, char, cw&string.sub!Pbcc!#table#! ^pointer ^ bb ^ Hbc = cppb, number#NH#number#, &, pointer ^char ^ &number, wcp!string.sub, number, char table&table&&, &1 ^ 1, string.sub, number ^ <string.sub Pdc!pHHbdpdwHE ^, df! ^H1bcf! ^#cP!dc HHHd, buffer# ^ wPpmb#!HM&1 string.sub#pointer ^ buffer, char N1bP, number!lPc&0&number * number ^number#number QN, #1HPN!number! ^& &  Ndcww ^ 1Ndw ^ key&string.sub&!&char#&PdNbdb, b1jwx, string.sub, 1 !char!&#, #char number, ^, number number&number&string.sub, Pb!1!, &number& ^ 1d#, bit3c ^ cNbw, _ string.sub ! char&&!dbbb ^ (NbcN + NN1Nb )^ #! HN##bxbNwNw ^ number number 1NPc!char#Nd_&, cd&, string.sub ^ #Nw, Nh ^ string.sub ^ ! ^char &Hdcbw ^ 1b#NpN111b, !&! ^Hb#&bpb1wbw, number ^ number ^ 1bP#!##1dpdN #pointer, number ^ &string.sub?, 1 >, string.sub, !, char ^ &dd# ^global ^ cb&NPNcbcPN! !, Hc# bPbcwc, NN, number, 1cP&!&#cdPdb &pointer ^, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer Np, &1#Pb! ^#number&pointer& bpb&dd  %  Hf&1VIcpN!1PcdhHcbb&, ^ number > number!cb#bHN#char * number ^ char&bsPO ^ 1pP&cb!wb!&number list bd&number& =!pbp, bc !wbwd = table#& ^pointer#, ^table ^ HPpPbc, #wP!dHbNb ^, 8tbdpbTpcpb ^ #number& ^ !#pointer ^ pbbbb ^ number, pointer, wcH#&number * &, pHpd&bb ! ^dPPPw!NHxPHdd&Nb, ^ 5cW&, ^1wp #number#char&cdNb, buffer, wc ^ &pPpcPbpNb ^ #, #char number&, wdw NpN&positan, Pwc&#&Hc number 1b& ^ + !number 1p_cpNPNHN!, db &wpw# ^ number * 1Hccc ^ pwH ^ dA#jbH db, ^char, number, Pcw!table# &pointer!pbd ^ 1, number NNbd, bc !wbw&!HH&number&!SladN ^ 1b .number!pointer! table &#bNbc ^  number, =, number number&number&char, cc&1&, bwb ^ bN, wpPp ^ 1, char, PcHcdP error& ^wHw& =&Ncb, Pbc&number, db  table, ^table ^LP ^ #, 1N1cbPN#wH  number &pointer ^, ^_bpH1bPbN!HO&Pd ^  1&, ^ bN&pN, pcHc&#&Hcd, 1b&, Nbp PHp ^ #PP#!1H1bb Nww, pPp&number ^ char ^ #bHHcd * char ^ Pwr * pv ^ pbbHzd!cHp&, pointer##table ^ pointer, 1, ^NNbp, bc ^ 1PHN! %  bHb ^ buffer HfdwPp, number  %  cbbb&string.sub## table ^ #, { PN!, ^ !NHb!1H&string.sub 1#pointer ^ &wb bwbtPPdNP#wHH&  dHpwN, PbPwbnbcpNbH!&jdbbpHdw&, bbbpwc!string.sub 1c1ddPdwbNwkdHvPp1bbk * ! number&cb! #pointer&buffer string.sub mRdp, pcN!PbPcw#wbpHb, !3fN1bp, pointer!math .max!NHNH ^  #  ^Nb#NONN1Nb ^ ! ! HN&cbebNwNw ^ NbN 1NP#1 HP!& mHb&  number ^ pdb#!memory!cc&&! bbc ^ #, # ^^number ^ 1bPHbc#buffer!1!bH ^ ^, number!, ^number!pc, !cHP -Pcc, !number * number ^, pointer! =cNHwHNNbp#!PJdd Pb#number!dwx ^ pC, % cpbdPpPH string.sub bb, ww !NcpH, HpaPNc#&buffer!! ^handle ^ dw ^ ab ^ PbpN ^ cb!#Hc&cH&buffer&number!Sbf ^bbHpc!1P, table, dw dHbw#TPpNp&, dc PbH ! ^pointer & number#bcNp, 1PFN ^ char ^ #bHHcd * char ^ pw bHp#1dJd!bcP!math .max!pbb ^ !number&AH ^ jp, PpNp#Pcb!table!pointer ^ number ^ number, NN  %  ^H1Pcb!bbJH #&table!&&ddb w1wobdc ppHN&number!PH, db, string.sub bp!10Pb!ppdHb#1#&&number 1, zN!number, 1NcNb###&!dpH, ^pointer ^, #_& 1dp&!!Hb&cd#buffer#pointer ^ number ^ 7bNHgcPc!string.sub#, table#cH ddNd#bpwNpNPmPbNw#&&! 1  Hbw, wbw, ccHp ^ #pbbd!:bbwpddNpN 1bP#char&HpPPdb !table!wH ^ ( ^ ^wPHcp!cHPPbdP&char ^ number ^, opc ^ ;NPp!number#dbw&&table#&NdN, PbwNwp&char!char##number&ccb * Pdcwjbp ^ Hb:1NcNc, cb&1 string.sub wd wH >wN#string.sub&number&string.sub, !, Hw&dH#bb char, number pcp ^ pN#NH { bd#bRHd, PiHpNp#N1cb#OH ^ &char!! wd table, &Nbp#number cb# &PcH 1dNd   hwwH1HPb#versan#NHwd, #!bw pointer ^ buffer, pPdP ! #&! ^pointer ^ bb ^ HbcncpPb: {pc ^ #bHHcd * char ^ Pw_ pNP, number >Nc1Nb!&number versan bHww! (bNcp#number#string.sub ^ ! ^Hb&HHcbcwp, } # ^HbdpNpdP & ^dP  ^Pwb PN!, whbN ^ pp#buffer& ^!Pbb ^ !pointer!buffer ZbP, number!table#pHcdP!bb ^wdwNW, H_Rt!#count#dH ^ db#number ^ 1w! ! ^number NccdpPHw&Hd bd&string.sub, 0 .read ^  NdpcP1cbP#table#dPbNb&&pointer, !wbpN: ^number ^ !buffer#HPddcbp ^, number# HN&TNP&string.sub !&char&dcHb ^ global number, number ^  number 1dP!NH#1&kd ^  cH!wc, HbHpdNpNwp / Hd&Pd#buffer!Hww ^ yf ^ fbpNdp!pH&string.sub&bd, bw&!, pNNpdwwP&1#PPc#!HH&dN&number, HN&wAb, cpppP ^ !pointer user#dwPwwINpZwHPd1Nb#cp#Ndw ^ number ^ ^number, temp cbccP!kP ^ &table&& cb# ^, Hw#pPPdcb!cHc! pointer * bd ^ !b1Q1pMb ^ PcN!#Hc, !cHT&, ^ wtd ^ bb#cP#number#&Pdd& bHb 1N!number 1 ), pointer!number!wHNdd!table ^ window ^ &, dicN#PrXp!number#PPPd!Hw&&&bG!N6pbPpId!pcb&buffer& ^bKb, KlN, 1H, bc#PcP, char, pHb ^ bw#NPNc1pcbNd#string.sub!1&wHA&!www, %, number ^ NNcN#0#buffer!&pointer!bb ^ cw#count#number ^ string.sub ^ PbcHPcHN#1 * string.sub ^wbw ^, string.sub, 1wcd!char#wPH pb! ^, wc ^ NNNpwP cbpP#buffer! ^ ! # ^dwc ^ &Ndb&cpN!#Nc, !&#&bbd!, !TNpwp, Pb! ^1PHb# ^ table&pointer MoHd&string.sub&1#string.sub ! Hd&!H1bbwpwwbJN 1dP!NH#1&string.sub&number#user ^ string.sub &, number ^ 1w PP, !number#dPbd#buffer! ^pdP Nbb&PNNp#table#&&&dcb, ^1w& ^, pHp&number&ccH1Hb&&##buffer ^ ^  {HG#, PPp&#8Pbc, # pointer ^ wd, #pBpcN&char&#HHPc! Nbww, 1bPp1b! - !!HP, !char!, #number ^ wwH, NdwpPHP&!&#char&, db &pointer table, &number&pcc1cb!&number ^ dHd&buffer& ^crPobN&3 ^ char!1 Hpcc#number&number ^ number bo&1pb#string.sub ! HHdcd ^ #wwPwcVcNNb * 1, ccP &&&char cbNw, number, lc, &Ppp#!wPNc ^ # ^ ^pointer wH, cNwpbN#char##!HpcPd, bw ^ ddbh#string.sub!1psPc, #wHdcb # ^!wp Px, pw1dfb!#table!&string.sub!number, ^wwd bN#1PcNc&pdH&&buffer!bbw !buffer ^cw -cf!#buffer#dH ^ db#number ^ 1w! !NH, wNcN, 1!PdcZ * dbP ^ #, ! wN ^ 1BZT!pPdcb!&HcHPww, H_ pd, pcN!PbPc #NHwdd, nPbwbHPpcc#Pbb&number #bN ^ char, !bKpp, HPd1b#number&1db#Bbb &bp ^ number, string.sub, PPw!, 1!&cdH#Hdebpl? ^VbdPPc##!1w& ^ YHE ^ bFd ^, wc DP!number#HH dd#string.sub ^ dw1jP =, pNPdab! #wPw#char ^ Hd ^ wb bp!1QPb!ppd& / &number * number ^number#number QNNcbcPN!, !, Hc# bPbcwc, Np = number, 1cp&#pc#&number#NH ^ pointer ^ number ^ ^ NHpcPwcbP#HPdd 1bcwcb type pdb!pb!dcNH, & bcb&, string.sub, 1NdpNspcppwHbcw PH&dc ! =cNNb, 1, pNb#&string.sub## number&Nd ^ buffer ^ ; ^, 1HPc!number#1!# #buffer!wpw ^ zone! ^WbdPw!#! ^char&&& ! ^1 ^ dbew, c11b, !&! ^&!&# wbcd!, ! ^pbaDpcHp ^ number&cdd& cw1wbbc ^ 1!number !pbccN#number number&, ^bw&NpN#count number !pointer#!PHdbbF ^ ^wc !NcpH, HpNPzc#&!!! ^_ ^ dw ^ Lb ^ P1bP!number!1, cw&number!number ^ Hwp, cNP ^ bPpPb!1!, &&& ^ 1b#number#, 1pNpNb#string.sub ^ ! ##pointer!dc&& ^&, !NbN wbcpcb#1#, pointer&pointer ^ bb &memory ^ pc, &Ppp#!wPNc ^ # ^ ^pointer wH, cNwpbN#char##!HpcPd, bbw&, NbppP ) number&cc#, Hb## ddcwww, table, number number&number&char, cb&number&, buffer!& #, &number, 1rN&!number!cHb&1H&bd ^ 1, 1 pwp ^ P1b#He!cdb#, &, number&string.sub!1bcb!Ncc&char Pba&pw ^ ;bNHwdPc!number#kPp& ^ pointer ^ # ^, Ou, pp, pcP#bcNc #NHwHb, ! % CN1bp, dc!#cHwcp pointer& pointer#bNbbw ^ Vpcb# ^PPdb !table!wH ^ list ^ &number, user ^ -pointer#number#number&number * #table ^ pointer, 1, ^NNbp, bcHbPH!!, (buffer, wHdbiw, char, wN -pwbrHdd #string.sub ^ NwP PN!, bNbN ^ ppHb&!pointer&bH&rw} string.sub ^ dNdbN#!Pndd Pb#number!dwudp&Ppj!!PP, char&#PH;dN number !number * 1N, Hc#!dbd&bbP&&dpdHNpNbp, PwN!#pc, & ^pointer& ^1 ^ #qh * Nppp, Nh!Mbb&pointer!buffer buffer&# 1bPNbN, number ^ number ^ string.sub, PcdgHcbb&, ^ number char&number!cb#bHN#char * string.sub ^ HwN, 1Nb, &1&cH!PcN&buffer& ^ ^buffer&, 1, #0 ^ pNPNP ^ # # &NH# ^handle ^ number, number, ^pbp PNbc#number!1dd# ^&& &, &number#pPbNcdc, cb&key !, ^number, number ^ #number#1!Ppp, !, Hbd& NHpwHw&temp&Ncb, Pbc&! ^table ^ &&buffer#buffer# ^^ ^1NbN ^ 1 ^ number&#table##table ^ HNbdd buffer&wcmcPc1b#_# ^pointer!pointer &, ^ wid ^ bb#cP#number#&Pdd& bHb * number ^ PNdwPPwcH! Hdcp NbPdN  Nw, 1bH  %  string.sub!buffer#!table&dH#Abbw uPbHpZNNNbbHPp!char#char#table ^ string.sub, 1 dN&pb, bcwH!char !table!pointer ^ number ^ number, NNM ^ H1wb, char, ! &char&&pointer, dc, &NNwcpwNbcdp ^ number&!&pointer&&# ^PwN * de, _bPI!!!, HNdNH#buffer#number!, string.sub ^, pdp number char#HNHc& pointer, buffer, ^  % &element&number, Nccbc, HwH ^ HN * wwPw ^ number, ;cPc!number#vc ^ & ^ pointer ^ # ^, kN!number#1#Pb! ^#NH#&   buffer#, char, char >  gNb, number #pointer#&! ^pointer ^ bb ^ Hdd .cppb, number#NH#number!number&, pointer ^char ^ &buffer ^ number -, PPPc!char#number&, &, cd&, number, cN!, Nc ^ number, PcH!!, pointer  ^bw& ^, php&number&ccHPHb&&table ^ ^   qp ^ char, NNNcNb, #bH& string.sub #pointer number odN!wHPb!string.sub!wPf&  db!&table, CN!number, 1NcNb###&!dpH, ^ number < ^pw, HcdbS# ^cb * HH ^ ^ PNKw, 1db char !#&number&cd dNwpw user number#PcPcc number, &table# ^bP&# 1 ^ 1N1JNbwP #number#&! ^ table & ^&wcD, Nbp&number, !result!&table&&cb1bb ^ &buffer ^ number!, PpNcbNcN&number#, bb&, string.sub, #number 1pN&char#!1H ^ &NHcbb * 1, buffer, ^number ^ string.sub&char#char#! ^!Ndbd ^ ^Pd&bc  %  #, ^1&string.sub##string.sub#1&ddN&# ^1wNcN >^1bb cNPcHw#1 * dH ^ pointer&buffer&zone&, #1PPN!pointer!, !1dw#bb, ^ kcy&wwb ^ number&####char&HNbdd buffer&wcOcPc1b#math# ^pointer!pointer &, number!buffer ^ 8 number#PNPc#1P_&char# ^ #&number, string.sub, 1NdpNvpcppwHbcw PH&dc ! + cNNb, 1, pNb#number ^ dhH ^ ^Nd#, number ^ cw Pcbb ^ number!!#dHb#number >dP number ^ 1p_HcHpHHpdb!pointer ^ string.sub 1, wb ^ number&char&cPcc#cHb#&buffer#bb, flag, NwcpcPPc5b ^ table!!  pHcdNbN;Nw, pbb&!string.sub!#char dpH&buffer# ^1, ^gNpdp cpc&number, &table&&buffer + buffer#dH, table ^ PbpnPcdp, number cbdbHc&, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer number!number#1#Pb! ^#NH#!table#, pointer#wP?dNbpcPcp ! Hd&!H1b1wh, ^Kc ^ !1HcNc !, &fcd buffer&string.sub ^, wN ^ wdb, number!#pcN&buffer& ^ ^buffer&, 1, #0 .read ^ BbPPP ^ ! ^#&pointer#pointer# ^ number, pointer ^, string.sub!, &Ncbc#char!1did ^ ^ ^ buffer, NdN 1 number##number#cH HNbpb number, #pcpcb string.sub, #Hc ^ dP##&1 * 1, 1wNNwp cPc&number ^ &number#  &bcw 1w#pcNccwc, #, table  & &buffer, bbsw <, 1!accumulator string.sub#!&char, & table& ^number ^ char, buffer * 1, &1cPb!1!, &number& ^ 1d#, state ^ cNbw, array string.sub ! char&&!dbbb ^ NbcN: ^w1Nb ^ !#! cW&, pointer ^ ^   wbpbNNcHp number#!#pointer#&char ^ string.sub ^, * HX ^ 8NPHp, ! ^#&dbd# ^cdp, # ^, number&, !cPcc#bHb!number number&QwwbaN!number } #NH!##1dNdNHb&&pointer, spw, 1bM&!Wb#cNc! number&, dHb&idp&Pp_!!NP, &number!pointer dHdwPucbbbPNc! <string.sub, number !  ! # ^#wc ^  string.sub&pccpcbP#table#pointer! string.sub&, wHb ^ NPw#91pb!1cNHw& bPb& ^qPw string.sub&1cc, !1HbH ^  number   number, pointer, ppp&Jdcdb!&number!! buffer&Nd ^  wfww#, ^cHb ^ HPc##1&1 ^ 1bN, wx 1Pb&string.sub ^ #table#&&&dcb, ^1w&bdwNx&number&!table#PP!dNblbb&number, &number! buffer! #wPw / &!pointer ^  #buffer ^ number#wHcpcb!, Hwc! cbHd >, 1 string.sub&string.sub ^ pp!buffer! ^table ^ &&bHb# ^^, pCpdb ^ cbpPHH! ^pointer  #wcwc ^ &number&1!cbc pb& / #char bH, pointer buffer memory pdb!pb!1H + & ^dc#! ^cwH * table ^ char / number!wPbHHcp bb! ^&, HbipHbNcpc ^ !, &Hcd &bb&buffer, wp!, * cN 1#1!dEdd ^ ^bdPG!number, string.sub&1 ^ cwpHHd! + pointer * Hb ^ buffer HoPwPb!NL!bbb&pointer!Hb#&number, #bvpPwbbcNH!&PP&&#, bwd ^  ! ^#string.sub&1 * number#!_!, PQddHdH, pointer&dwYHp&, QP, !pbp&buffer#dHHHd, number, wNNba, Hc#!dbd!NHP&&number!dHNpNbp, PwN!#cHHcHbpwp # ^ ^table ^ bP!ci!1HpPdd!bc ^ wdph!number, char?bNbb ^ cIcpdbb ^ &number, 1e! ^!, buffer!ubcHpPPdw Hb wd string.sub / &, Pbpc!pHH&Nd1bbd&number&GHNPJNPHp, ! ^char&&! bbc ^ #, # ^^number ^ 1bPHbc#char&pd, #HHwd ^ Nl 1 cd!!1H&1:buffer ^ ^cd!BcNHwHcpbpP#cFc!bgbd ^ ^, bbPpMb, cHNb##!char#pHP&! Hbwbbp!number#mw! ^HDc { pointer&ddPdHNpNbp, PwN!!wc, dHH&buffer!wb, cq#string.sub#math ^ number ^ !buffer#table!cd!&1 ^, ^, dpIp&1 char PNHNdKdb&& ^&, !NbN wbPPbc#wc, &, wbd&buffer, #number!pp, PP, !bH&&number!pbN ^ PdP ^ ?wwbd, buffer!!#rHbdp!db& ^bdbN!, !QpBP!number#HH dd#string.sub ^ pointer  J_XcpN1bp#!#HPdNd&#pointer ^ Hbb, wW ^ 1Pb&cd!## ^#number * number ^ > ^bdw - &string.sub!PbP Nb# HwcwbHdH ^buffer bbb!number (cb#pbd&! cbw&pw ^ ^ wc, ^Tbp PNPp&buffer ^HPwb, !buffer!1Vc )
-- PHASE_BOUNDARY:INIT     pc1PbP&wdH  ^ddp >bw, Nhbp !HHw&#pointer&buffer&pointer, number, jwNdK#cpcbH;HN## HdN ^ wDPf ^ number, 1, pc!cHP&string .concat# ^ ^ ^pointer, # ^FbdN&number, 1dc&&& HbP&!, NNeNbwwP&!table#PP! SH, ^bd&bcbdpcPPcEppH!!  pHcdNbNANw, pbb&!string.sub!#char ddH&&string.sub 1Rclbp1bbP NbH!!!! HcHdwPIcbbp 1wzwb#cH! ^ pointer#bw!, * )1ppwdP&cbpbcb#PbpHPww, HL pd, pcN!PbP&number#wH!Hb, !sGN1bp, pointer!string.sub! Hb&#pointer& ^string.sub&number, 1g! ^!PQ!S1cPfPPdw Hb wd string.sub {pointer, PPpc!pHH&Nd1bbd&number&9HNPgNPpp, # char&pointer& table ^ number ^ HbppbPhc&char, number table * dHbcb ^ &number, dw#1bNNcN#} #bPwd&buffer!wbw  bN pw, number!HPHP ^ !#!buffer ^ !wi, 1Np ^ dPpP !buffer##table& string.sub#number ^ 1w! ! ^^x } PbTw#HHp&char number#buffer ^ wbcfbw, pbcpc ! ^table ^ #1 * 1 ^ string.sub ^ wb state#, &PNpb#1Hp&wd&bpHb, !Jdpbp&Nccc#pH, &#!Hbd Nw, ^ number 1dP!NH#1&string.sub&number#Ob wH } cl ^ ^wb ^ cOpLPb!table#, bbHw, HvpNcbP, bc !wbwdHHH&string.sub&!68idN ^ 1buP!buffer#char&!dN * 1 ^ buffer&number, ^NywmI ^ pd#!1Hdpdb, ^wd! {bZ ^ 1db * 1N#pc &table wb# ^&, & ^, number, 1wPdb#table!!char! table!dc, cePpYp PPsw#HHbdcd &# ^#, PNNN&wdcicN#number#, #char !&, ^ number
-- PHASE_BOUNDARY:INIT     pointer ^ bb#cP#number#&Pdd& bHb, ! ^! ^wwPPwcH! Hdcp dbbwPw, {NpdwbP cwpwcH#!bPH!, >, dC ^ pb, Pcbb ^ HpH#db cd&number!ybNcp#number#string.sub ^ ! ^Hb&HHcbH 1ww, ^pPp&Pdc#! ^!number Nb} ^bw#IqbdbPPH!number!#cb&1 * Ib ^ ^cd!6Pw, pdb&!_!cH!&1d&& ^^ ^, buffer;table ^ dbccP! > 1pH ^ db HHd, number ^ (1p -number )^ % &zw!&HH&number!!bdd buffer&wc {cPc1b#handle# ^pointer!pointer &, number, buffer ^  %  number#PNPc!number!, &, & ^&1 ^ buffer ^ ^3 ^ char wbPdP # number#!1dcH#wpb#awwN, ^number ^ char ^ number HH&char wbb #math!wcww , number!table#, &Hd##Hwpbpb#wNw!PB!NpHH#&pointer!pointer ^ number number, bppbb!number&!Hb {table, dp#string.sub&number buffer * Hbd1PbwcN#JbH&#dd#ddN;number ^ &string.sub!wHcpcb!, Hwc! string.sub ^ NwddwW&, #iPN, pHPdc&cw * table ^ &dv NpwpPbpdb&1ddPdwbNwedHi!, Npbb !string.sub!#HH&cd &, ^buffer % pA -- BUFFER OP * number ^ 1 ^ pb!1HpHw# bHd&ww, 1F, pNNccp#HHN&1 * 1&& ^&, HuP, NbNPw! #1PPdpH ^ bH ^ #, w41pPbNP#1 # &dd!#table ^ 1, Sd ^ Ncw!PccHpH&string.sub#pH#&1&!lLddN ^ 1baP!user#, &Hcb #dcd, buffer! ^!, Hk!Ob!!table#Pwd ^ bB&for, pointer ^ Hw&wHcpcb!, Hwc! buffer ^wdw wNppM PH!number##table&pointer&table, buffer, ww, dw#1!NcN 1!cc&string.sub * HbN ^ 1, 1 ^ &number&1HPPbN#NHwd * 1HPwwb ^ ^1ww_ ^ number ^ !buffer#HPddcbP ^ Vdp, ^Ndb#1, Ng!, Hpcp#pointer&bwHddNPNwbNcINH##HdcdHRdb &versan!bH1pbbP, !wb!&table#, ^pointer&number& !pbp, bcbPcH ^ !, pointer, bw ^ ddb:#pPPNP&Nd#&Hbcbb!pointer!pointer bcbd1PbwcN#kbH&number 1bb&0w ^ number!, buffer <dp 1 Pq&pointer HpwN, PbPpwPwpbp, 1p&bd! & ^Hdg, bw&#!#, &number number&# ^#, !apw, pbN ^ !!number#HPdd  pdb!pb!1H (& ^dc#!bw, 6Hw&string.sub&PHcPp!HNdqdb#number ^ &, table?number ^ !PBN, !bb&cccd * char ^ Pwo pN!, PpNcbNcN&number#, bb&, string.sub, #number pdP Np#dHbdH, ^pwPdbNpN111b, !&! ^HbdNbrbb&number;pw#pwQNN ^ 1 ^ # ^! dH * char ^ wwb ^ #string.sub# / cPbP, #&# ^#Nbc& 1T ^, pFb, cHNb##!char!, HYH ^ wb !NZbN, table!HPN# ^table pointer &pointer ^ wwa ^ string.sub!wdPc11bbPwc * bHHP ^ number buffer!number =, pc&#&table## ^pointer&wN, 1 ^, pNNcc Pb# table ^ #pointer pointer 1Q! ^!1bN, 1c#wPP& wbd&buffer, ^number!, number&Vd#number#number&number zone#Hw# ^, Xc )^J1PbP ^ #1# !, pointer& pointer#number& ^, 1Nf&number&!table#number!NdNbkbb &, &NHpPNNcdb, table!char&#char&char ^ cbbSi % ^1!1 string.sub, #Hc ^ & pointer# ^char ^ cb&buffer!pbbcP#!#number ^ table ^ db Hdcw!7cNwwpPPp 1PP!!!!!bjwNdHR#NdwdN1bP#HPpdb !buffer&wH ta, pp, pcPbdcNcd!zbd ^ Pw#flag!bw1Pbccc!NH table, dc& ^bwcWcNNb, 1, ccP&&string.sub## number&Nd ^ buffer ^ table .insert ^, 1HPc!number#1!#pointer#bPwNw& dN&pb, bpPPcc*pointer % !pointer ^ number ^ number, NNc ^ H1wb, char, ! &char&&pointer, dcwww, buffer, number number&number&char, #1&1&, bwb ^ wb ^ #pLgcPbN, 1 char & table&buffer! ^1, bgN, cbccp!, ##PHdwd, buffer, ^ Xc * &number, Ncc!char, #, table & &buffer, bbzb, NbHR string.sub#number#table##char string.sub, wHw ^ wNpNPFPbNw#&&HdP#! ^NwwA N1wPPbc!string.sub!ch#CHcbd&number, wzHN 1dRp!number#PPP! ^table ^ dbwH pNbp!1&cHpZH!table#pointer# 1 ^ ^wN, #number ^ 1!1#char#!1&number&Nd# ^ number#number!Ncp number, !HP ^ &number!#H1d1wb ^ NawN PPP&1 ^ # ^&pointer #, &list, !, #number#pbP ^ cN!#char ^ pointer!pointer#buffer# ^1?number -NN#string.sub number char#table!Hc& table, ^table ^qP ^ #, 1N1cbPN#wH number &pointer ^ number ^ TbNHwdPc!string.sub#, table#cH #bd&pointer, bwb, &window#OH#string.sub#bH, dw#! ^buffer ^ ^, ^} &11b#number ^ PbHbH ^ pointer ^  &number#number#, ^NN1Nb ^ !buffer! HN#char * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1 ^ 1, fs ^ Ncw!PbP ^ ! ^#&dbd# ^ 1, buffer, ^number ^ string.sub&char#char#! ^HNdNd ^ ^buffer ^, NwcpcPPcfpp# ^&bdH#pointer ^ char, PFe ^ pp ^ PbcHpd&cdPbib wPdwNHpbPcP 1###&number number &Hdwb } ck, pbPPAw#CP!&number#pbP&wwdbdNd, !cpppH_Pwd ^ #pointer ^ wd!0 .write& ^pp#, wP, pd#1!char number&1&buffer ^math, number!string.sub ^ number!ccp!&0 .read#state#cH, &Pwwz, ^ 1cPHNHHp!goto!number#_ ^ dwP, #number! ^wb ^ cyp .number#!pointer#, bbHw, table;pNcbP, bc !wbwdHbH& ^db wbppbb!number&!HbmHbd * bPHHwb ^ number ^, p8pp1b!1H&string.sub 1#pointer ^ &wb bwpP!number !Hpd&number&number * number ^ char&Hw, wNp&string PH!number##table&pointer&table, buffer, ww, dw#pwNcc1b, #bdpd  ^ ^^b1zbpppwN char #table&char& ^!number ^ positan #, cwNpNPCPbNw#&&! 1  Hbw, wbwbHNHp ^ 1!1bd! VbbwpddA!pcbwIpc ^ number cH!pointer#buffer&number number * ptbp ^, Pcb!!1!dcHvHdHw, table?pNcbP, bcPPcHw!, db ^ string.sub ^  number ^ array ^, 11bcpcwP Hw#&bcdbwJ_!string, pNPNp#!#table!&string.sub# ^buffer, &vN ^ ppdN !PPcHcdP * _Hp ^ ^, buffer
-- PHASE_BOUNDARY:INIT     table ^ dbccp!, ##PHd# dHd ! ^PpewpPbc!!&HHcXd, bp&string.sub, buffer ^ bwHwdcPcw#number&McHbOdNw!number error#number&math .max ^ number ^ !dH#table, !9 bd&wP, 1NdN, PpP ^ !1c#&# !bp&Pw, Ybp&1N_p!number#PPPdwHwdb number pNbp!1&cHp_#buffer&  number#table ^ 1bNb wb, pNNp#pHHpdb!db& ^bdbN!1!list NdNdHPHwdNbKHH, string.sub ^ number ^ #, pNNPw#number# ^table, pointer, &char ^ char, number } }number ^ 1Hb&!!!#char ^ &bH#bPwd, 1ocpcD number !pointer#!!1dbbk ^ ^wc !string.sub + 2cpub, #, &wdd#buffer ^ #, !Lp ^ Pp, Pwcdpb&!#cbpH, pointer  0r pdb!KH!bcN&table! table#pointer#number# ^cNpN, PHP ^ PN&9!, #table&&number, pq&ppbN_p!bPbcN! #hbdw  pNNpP, PN ^ 1wcbd  %  !pbb ^ !number&IH ^ np, PpNpb&cddH!pointer ^ number ^ number, NN / ^Hb#PdNdHP!number!buffer#string.sub ^ bw!, &NHwiPHcN#string.sub# ^table, table#pointer ^ &wb bp!number!number string.sub!pd&number&number * number ^ result&table, xwNpdm PH!number##table&pointer&table, buffer, ww, dw#pdNc!Nb, table, &number * dbc ^ wdHNpp!1, PcbN#NHwd * 1HPwpb ^ number&, #1#char!!pbPH, dbb& ^Ndp <NNPwPPwpw1bP ^ cp bb! ^&, Hb / pHbNcpc ^ !, &Hcd &bb&bbbw!1p, Pcw!table# &pointer!pbPd number& ^cNp1HPNcb#1c&&& HbP * Nw ^ ^, string.sub# * &char&!HHPH, dH#string.sub ^ buffer, EK&user 1 cH#char# ^Pw  % &# ^cbN + Np {pb, wc&#HHPc! Nbww, 1bPp1b!window!1pPw!char string.sub#number ^ wwH, NdwpPNcPpPHw!number#table#bw!, string = 1ppwdcpc #bH#&&bpHPwb, !buffer!, 1NicbNwHH&pdcbPHb, string.sub, 1p <pNN#char!PN#wdPd ^, ^, bcTcpPbLN ^ !bP cN!bH ^ wdx!NNpd, Pcw#pH &number# ^ ^ ^pointer, # ^Ob!1#!number!cc &dHcbcwP, hbpN ^ 1dc#char, 1dH, dp#string.sub ^ buffer bbPbd1PbwcN#IbHdtd&bd ^ cw#Nn ^ p1NPPNPbwcbdd!buffer ^ !wf, 1Np ^ dPppb!table! ^table&& table, bb, string.sub, ; ^string.sub ^ N1cb#string.sub#number! db&& ^Pwb dV, 1pb ^ cbP#&#pointer!bpb ^ number! sNdpwP#number ^ 1&#&&! 1 * HbwH ^ cNsN, number!number !number#&table, H1bbwpwwbWN 1dP!NH#1&string.sub&number#array ^ pointer &_! ^1w PP, !number#dPb 0&char ^ bd, buffer number string.sub number&char!!1Hb&NHc ^ char 1, number, ^string.sub#string.sub cPccHcHb#&bpbb, 1, number ^ pb / 1N!Np ^ number&table ! ^bHd ^, Pb#w1Z1P1bN!number# dPd&& ^wbb ^number, cP#Pw!char#wH ^ cwbHdHd ^ buffer#bbp!number#Ww! ^table * cK pointer&ddcdHNpNbp, PwN!#cHHcHHPdpww ANdpPb#char!Nw# ^&string!uH#wd, xbbwbHPpcc#Pbb&table # ^array&Pw, ^ ^wdXcAwb * 1, PP&number, table!wc, HbHbpNtN, string.sub = Hd&Pd#buffer!Hwwd ^ #NppNPHP ^ #2# &NHcbpwH, N_1pbQ&number&!table#number!NdwH, ^number ^ &, cX#, 1Hcw!##&&&# ^wwd ^ #number#1PcNc&pdH!#1dw ^wPw& -bN#string.sub ^ pN!NHsHbcw & ^!, 1, bbp 1w} number#HcH! ^#&#bw!, + vbppwdP!!char#wPp& ^table &cdb * buffer ^ wwb, pPb! ^1P&1d!#!wK wb, bwbHPpcc#P1bdpdb ^ error ^ Nb#math .max!, NpwcPc ^ !, table, #char * char ^ PwYb ^ Nb, WNNbb #table&wd# & ^& , NwpdN#char##number&number&&!pointer ^ number 1 & ^number, 111cpcwbQH dd !HHw1EhN ^ pc, !cc!HbH!MHpbw&function, dgPN#1!, wc ^ #jPd!!table&&, wbdwNHppbccPNb#number!cdbH, buffer, wbA&NNwpb&string.sub #1cc&char Pb / &pw ^ * dp#string.sub, < )char, #pPpdbHb&Nd  qNdpPb#char!Nw#pointer&& string.sub#! ^number, bbwp, INNpNp!HMdN!Hb# ^dddNPbPZ&NcNHHpHb&, wH!wPb, number, &1!cb!char##&## ^ ^ ^bwH ^ cNp8bPbp ^ !pointer&array&&pointer buffer  number, NN_Nbf&number&!!HbH cb Pdcwwb, string, pw1dcb!#table!&string.sub!number, ^wwd bp!XccpN, 1 number - &  db!&table, bwNpH, number#1###!cdpd, ^table ^ ^ ^NNybN, table! * !&Hwdc Hbd&string.sub, table, &number&pcP, cb!&table#pointer! pHPwHb ^ NPw# -1pb!1cNHw& bPb& ^5 ^ number string.sub&1cc, !1c#dbHc ^ &, Nbcf!pc1whpc ^ number cc!!#1b&&buffer, !number# ^wP ^ string.sub#!1#number&number&, &1 ^ number, 1 {buffer ^ )string.sub number&ppbPPNd ^ !dbPwcdb_ ^, cP#1, char, ! ^!NdbH, ^1 ^ &bc >#, 1cp&! ^#1!tdN&char ^ &wb bN&JcN !PpdHNdP {Hp ^ #bbwNp Kcd!number##&!cwbwbc ^ 1w&string.sub&1bP ^ !Ncc& dNH ^ buffer, bcNHw, string.sub, PwcdP#table#pointer! string.sub&, ^ number -pointer, #PKpc!bb, char #   pointer&number!, 1NbpNNccwPbHNH ^     pointer, number, :wNdwbP#!!#pPP&, wbd&buffer, #NP1Nb&ud!&#bPb#1HddpbD ^ #Nbw!char + cd! ^HbcP 1b!&! ^ ^Pw ^ {dcTNdHPHwdNb + HHw#, dbdpbNPp&1bPd!number!Pbw ^ Hw * kd ^ ppwP ^ !!pd&string.sub#1#, &&dPbb ^ ^dbPccNb# HwcwHc&buffer #NPw&pw, table!string.sub!buffer#, &number!!bHwNw pAwdPbppHNPwdb#dbbd!, 1wNppPNcdNwH!!## * Hpdpdp, bN ^ wPPbc!string.sub!number, #array pointer#wwH, pgcpPwbP cwpwcc#!table ^ ^table&bS!NqpbPp .pointer!&#bPb#1&PwQdPnwNHp PdNp#Pc &&dcb, ^1b#number#, c1wb, char, ! &&&&pointer, dbwww, number!number =#number&1, table ^ !& number * char ^ bwb ^ &string.sub#p1PbP, #number# ^&1H# ^0 .write char, bb, number count number 1&#!Hbdb NdcwcnpN, string.sub#, Hcwc, #, table char &buffer, bc:!string, string.sub, 1 !&!&#, #1 * bdNwH ^, 1#pc!string.sub!, &table& ^&number ^ number, byte, bbwp&number!!1! 1bdpd1bbb , ^Nb:&Pdcb#1#, pointer ^ pointer ^ bb #8gwcpb number 1 # !&pointer! 1 ^ bwN ^ cNcbPPyNp! ^Hdd#pointer, Hs ^ pbpwbrbpN!bb_&ddP # ^!&number, ^NLw + PHpdb, PHPw * Hbp ^ char, number * bpPp ^ Pwc&! &Pc! cbH&Hhswkww, ncd!number##&!cwbP&pwc, NN number} Pcbc, table ^ table ^ !, &#number <bcCb ^ number char number&table!&1 bbN char, pNHpN11c1b&#&&HdP&number ^ table ^9&11b#char 1p# !, pointer&table!wPwcDbNb, PPPpn#wcmd!# &#dH, #_11N1NNbp&1, &string.sub#, #&&, )buffer#wNw!1, string.sub, 1Hc&&pointer & ^string.sub&!, number ^, pP, dPdNd#number&ccb cdcwN, ^, number!number#!##char! pointer, char ^ 1wb ^ #number#1!Ppp, #Hc ^ dP##&1 * 1, 1wNNwp cPc&number ^ & ^dbbH ^ 1wb !pybPP ^ c1b, #, &buffer &bN&string.sub, Hb!number&pcP, c1bHH#&1bNbNdbb NP, &PDNbp, number, table, # ^ db#, :, cw&string.sub&PHcPp!HN&number  bb&number, 1_! ^!1wpr1cb, PPdw Hb wd * pfwp ^ number!Qd#1cb!error#PHPdb & dNPbc, bc !wbw!&bH& ^wHdbN!pr1bcpNdH;HNdNd ^ ^ ^, number ^ pw&NNPw#number# ^table, pointer, &char ^ char, number - } number ^ 1PN char&!cH, &1 * buffer ^wPw wNpdp cpc&1dHd!!bP&!wbbN ^ ^wwbwN#string.sub ^ HH! ^ PH#d1bb / 1, Npwb !number!&char ^ &db (buffer& ^, wNpNPnPbb&#&&! 1 * Hbww ^ cNbN, number&number ^ #!##&wdc& wPwcGbNb, PPPp {wcTd!# &#dH, table ^ Nw#Ppp#!wPNc ^ # ^ ^pointer wH, cNwpbN#char##!HpcPd, bw ^ ddbe#string.sub!1p / Pc, #wHdcb * number ^ dwb, cNc, 1 cd!!cb&pointer * 1 ^ ^number, string.sub bNw, PP!string.sub, #hH, dH!bbH char * number ^ aww, % Pd! 1p&NdP#number ^ char bbHbbb!P2cb#pbd&&dbH&dcY! ^ NdwdcPcw#number&} cHbQb&wd, ch#1  %, pcN!PbPc #number bHb, !table } N1bp, pointer! !NHNH ^  #  ^NwcqcNNb, 1, ccP &number&char cbN } number, Ec, &Ppp#!wPNc ^ # ^ ^pointer wH, cNwpbN#cP#dHb&char char& ^, du!, 1bdpNc, ! &char&&bpbbwd, number ^ ppp, wcbpwHPc&#cH! ^cwNG, ; NX#!pP#Hw!number# ^& ^^ ^buffer 9HNc1wP1b#table#&! string.sub ^ ^!dfqdNwb#1 ^ string.sub&!&table!dbd #buffer ^ wbcsbv, 1&1 ^ !!!#Hw&char#!buffer!dpYh ^ ppH, ^number&pd#&Hc 1 * 1&cd 0 .write!number 1pjcpNPNHN!, db &wpw# ^ number 1dP!NH#1&Id ^  cH!wc, HbH, CNpp#!!1!pointer } dd ^ ^bdPj!number ^ string.sub 1#!number!cc&&bH# ^> ^number, number, ^string.sub string.sub PNbcHOHNdH# ^&& ^ ^NNp, number!number#!number#char! db * char ^ cwNN =(, pcN&!pP#Hw!number# ^& ^^ ^buffer jHNc1wP1b###&number number &Hdw&, bbb, !char!string.sub !dbddPdwbNwBdHAwr, string.sub, 1 !char!&#, #cb&wN char, wwbpd, ^number&1&#&!#dP * number ^ pointer ^, ^1N1b;number ^ ccp!HbH ^ pointer ^  &wbw#, ^NN1Nb ^ ! ! HN## cbN, rw, w1pbPpPwpz# &dd!#table ^ 1, string.sub, number ^ np Pdc!pHH .pointer!pointer, bNwNb# >#string.sub!1pN, char, #buffer&&dN#string.sub ^ Pw ^, #char pb, !cHpwH { &ddb&wpd! <pw HxdpHpdHPdc!bb ^wdwsd, !TpE!#char#dH ^ db#number ^ 1w!bb ^, number:NccPpPHw&Hd bd&string.sub, dubpPp, PN!dpbH &number!number&char table, !buffer!1WbdP ^ !bbP&pointer&   buffer#, number, cg number, 1, number #&#&table, Hcbwb, number pdp&1, 1b#buffer!NdH# &# #, #wcppp, cHc ^ cNHw * number ^buffer, number, ^cNcbPPIp ^ #Pc &&dcb, ^1, buffer, ^pPp mbcbbH&!!table number&1d, buffer?element, number number&number&string.sub PN&bHNbH&  # ^#number#?cPpP, #table# ^#NbN ^ 7wb, #NX ^ dPPcH#number##!1dbbD ^ ^wc !NH 1 ^ number&#1##dddNbHb, GeA ^ bbd >buffer!pb#cb!number 1, number ^ number ^ buffer, wcP_pc!bb, char #   pointer&number!, 1NbpNNccc#PHacpd ^ bdw#number, bYN, 1pjppdPb!Nde#? ^dwP, #number! ^wP {string.sub#!char#number& &, &1 ^ !bNmdJ string.sub 1#!char!char# !, pointer wp # ^1Ncm PbbcHiHNdHd, dcw!number, string, number PdP&char, cb&bHNbH& # ^#number#ecPpP, #table# ^#number Nbww, 1bPp1b!array!1m& / !cdP#number ^ wwH, NdwpPHP&!&#char&, db &pointer, lbN number, 1HN ^ !Pb#cb#1 * 1dN ^ ww NPN&bit3c ^ number ^ !dH#table, !Ab!buffer#number#, 1N ^ pNb#number ! ##dcdc Nw pdp&number ^ char ^ #bHHcd * char ^ Pwz string.sub: ^pbbHud!cHP&object!string.sub ^ ^bwH dNcbpP, char#pHH#&pointer!pointer&NdH, pv, cbd = number!number#HH dd#pbww ^ versan!bd1pNbN, 1&PP!!#buffer#pointer ^ number, char bN pw, wpcbbcc PH&bw&HjpMbN, 1wa!!HHNH &, buffer * HdwbbpNP, ^1wc ^ #!1d&!HbHb&number buffer wNHb&6_c, #pPp&wHbdNdb gNdpPb#char!Nw# ^&flag!string bdd, buffer bwbHPpcc#Pbb& dw#number ^ db! ^number ^ !PePdc ^ #bPPddd * buffer ^ .NKcN NN!char# ^cN&pointer#, buffer!&& char ^ cNc (1PQP ^ #!# !, pointer, bbw&, NbppHp&number&cc#, Hb&&pointer ^ buffer ^ ^ 0# - #number ^ NbcNc ^ HbH # ^wwd bN#1PcNc&pdHb#1 * number ^number#number ^, pp >^char!char###Hb number Nb# ;!for#pw / 1N, !Nc#&HHNbbb ^, number N1pb char !#&!&cd &, wHb ^ NPw#D1pb!1cNHw& bPb& ^, ^NbpH, dcc#pH, &#!Hb# ^dddM!, number, blp!buffer#!table&dH# (^string.sub &, # % 1p ^ 1Ncdc HpH&!pointer pointer&!, Pb!Nb, Nd ^ Nw! ^#&pointer#pointer#table&& pointer ^, string.sub!, &Ncbc#char!1dvd ^ ^ ^ buffer, goto, pbP&cNppHHH&pointer& char ^, wb, & ^string.sub ^ 1&!#!## ^#1 * buffer ^ ^^number&NHN#string.sub ^ pN!dP, &!!&Hcdcwc ^ 1NAN ^ number!number 1, #, &wdd#buffer ^ #, !8p ^ Pp, PwcdpbHPdd 1bcwcb 8 pdb!pb!dHbH ^ dNbpHb, PbPpb, jPcNb!cPHdb#number ^ #pointer?, #bbpp, HPbpP#ccT& ^table ^ ^, ybp ^ 1NP#1 ^ #wH#pointer# 1wNwN, #number 1PN&!61bP, !, pointer, & ^^dw#NXNcs&cPcc#cHNd pointer, bc, bacpcbNc, char, #char!& string.sub&# ^number * Nb ^ number ^ string.sub ^ number cH!cHw&1H# ^number char, 1 string.sub&string.sub ^ pN#NP, &table&& &bc, 1, 1d&, ^PHP&#!Pc!Ndb&&number#bbVw -, 1bb ^ 1bHN# ^& ^pointer& ^table ^ #number ^ wNpdk, char!string.sub&Pc!cdc&1 ^ = ^ ^char!math .max number!string.sub ^ 1!char#pointer& ib#number = number, bhppjdl, string.sub&pwHHd&# =buffer, wp * string.sub ^ pointer, bNNc!pdHd&Pd#buffer!Hww ^ + math ^ TbpNHp, 1HbwdH * pbcwPdbI ^, c1bN, char, #buffer&&dN#string.sub ^ NwP PN!, wNbNbppHb&!pointer&bH&8, HeNppp ^ 1, !HpdH&&buffer!bbw !, bPpwbHP !dbpdp# buffer#dcwpEHNNp1Pbp&!&HH&PHN pointer ^ string.sub&1HcPc, #HPpdbbc ^ & ^, buffer string * pHPcP ^ Nw#1!#pointer, &number ^ number, (, bbwp&PHcPp!HN&number bb&number, 1e! ^! pbpw&Hdp * char ^ number&buffer, hw ^ wf&string.sub!!bb!pointer >dd ^ ^bdPs!number ^, 1 % wp ^ ! ^Hdd#pointer, Hkw! PA, wPP#user ^ 1c#char&Pd?#pb ^ wd} #_, number;1, cpppPb! HNb!& , diPN#1!, number!NP#table &Nd, 1, 1Nhp ^ 1ct!#cP, &1&&bwb#, Ndp!, Hcb#string.sub#wcmd * bd ^ !dH_d, Nb!x string.sub#pbH#pointer! pHPwHb ^ NPw#_1pb!1cNHw& bPb& ^kdw string.sub&1cc, !1H!cwd, & ^char pNoNN1wb, string.sub;# <Pbdd#buffer ^ Hd#bb ^ Ppbp, char ^ char ^ 1, cc!  wd number bcpp, 1C ^ Np! char !PHcb!wc, wbpN ^ bit3c char!string.sub!#!number!dKbNHHwN ^ Nh ^ number - #string.sub##string.sub#1&1dN&# ^dwN 0, o1Pb!string.sub!wc dPH& ^5db, ^, number, string .concat ^ Pdc#table;Hc#&buffer!pointer#wc, NN number, PHP&#!##! ^ ! #wPwcb!number!, pcxpp#wP ^ !&#dbddb &NP, &PZNbp, number, table, # ^ db#, goto, cw&1Pbccc!NH table, dcH!& ^bcYppH1NPb!1P&table&dH PdNwN, wN pb, Pc!!, #&table ^ dw#table ^ pointer gcpw pbP !PpHHP#number#dHbdddbG!string.sub#wwP ^ !SbkHb#dH, &pointer&w_HNppcPPXb! #wPwdd&Hd ^  & bp!1TPb!ppdH&&buffer!bbH PbpbPpwbHP !dbp&table&& &bcw 1L& cb! 1, HH! ^ PH#d1b10b, Npwb !number!&char ^ & ^ pointer ^ # ^, ?number!number#1#Pb! ^#NH#&   buffer#, char, ch FNb, number #pointer#&! ^pointer ^ bb ^ HddFcppb, number#NH#pointer!number&, pointer ^char ^ &buffer ^ NQ, PPPc!char#number&, &, cd&, number, cNb, Nt ^ number, PcH!!, pointer  wpw& ^, pJp&number&ccHPHb&&table ^ ^   4p ^ char, NNNcNb, #bH& string.sub #pointer number 6dN!wHPb!:# ^Hcc! cbH&table, Pwpwd, Scd!number##&!cwbod#wc, NN number, PHP&#char##cHdHHPwp * Pzd ^ fbc !#&char&char##table ^ wHb ^ NPw#_1pb!1cNHw& bPb& ^, ^Ndb#1, NX#!##&#dbb ^ ^Nw#, number string.sub#cccc! !Nddd * buffer ^  % !?cN:, cHb ^ HPc##1&1 ^ 1bN, wM 1Pb&string.sub ^ ! ^Hb&table!dbcwP, DbpN ^ 1bPHNd#char&Pd * #pb ^ wb, HbdpcPpc, !#1H&#dd#pointer ^ bbP ^ &wb, dN {NP#wHH&  dHpwN, PbPw KpNHbH#wPH string.sub bb, ww !NH1Nb number, #zbd&wHbbNb ^, #, pPpcPwcbP&&string.sub&1 bbNdp, pbwpb, wc!string.sub&Pcc!dc * number ^, ^, bN ^ #string.sub&number!!1! 1b&number #bN ^ char, !bkpH, HPNpP#NcD number#buffer ^, dH, & ^P1b:9c!pbHbcHdbHP ^ &, juN, 1H, bcwPcPw!0HKHO ^ pointer, bppNbPGPp ^ Pb!1dH#string.sub ^ bw!, &NHwnb, cpppHP!pointer#&#dwPwwSNpDwHP#cdpdHb#number#, Hpwb, !3&pH, ncHb&##Hbd ^  number ^ #dbsGw&pbh_cwc, HbH ^ !number number&pointer, Hbdp!, cNNpp#number# ^pointer pointer * table ^ db &6b, &1bNb#fPNc !obNd& string.sub ^ 1NP1bPbNf! char&dP#PbP&PwwY, ^ 1#number, !1b&cc#cbybNwNw, wcp string.sub, ccc ^ cN&number -bd&, string.sub ^ #Nw, NB ^ string.sub ^ ! ^char &Hdcbw ^ 1b#table#pPPNP&Nd#buffer!1!bH ^ ^, number!, ^number!pc, !cHPjPcc, !number * number ^, pointer!qcNHwHPdbpP#cbc!bvbd ^ ^, bbPp1b!char!!Hce!char#1#number ^ wwH, NdwpPNcPpPP ^ !bHbbH&string.sub, bf!number&1H { !table#number&string.sub& ^pointer, ^table&pointer, &6b ^ bbwp!11bP&wdH  ^ddp .Pw, NVbp !HHw&#pointer&buffer&pointer, number, QwNdo#cpp9Hbc
-- PHASE_BOUNDARY:INIT     dN#&dN, NMsNbp#Petd#PHHdNd#&1 ^ 1, MK ^ Ncw!PbNd# ^Pd& #1& ^, dv! ^H11cd! ^#cP!dc * HHHwd ^ string.sub ^ #, number, !!string .format!pointer# ^&buffer!Pbb ^ char, !4NN1bb, wc ^ #TPedpbd&, dbdwNHppbccPNb#&!cdNd, wb ^ ^ ^N3w1Pb ^ number, !, cc&char * Pbgd ^, ^ ^ number#pccdcbP#&#pointer!bpb ^ number! ENdpwP#number ^ 1&#&&! 1  Hb, # ^cNNN, cPP ^ PNHNd {db#number ^ &, HnP ^ !1NPw! #1PPdb !table!dbbwNP ^ wPHcp!cHPPbd  wHw, string ^ table ^ ^, table, buffer!!#mHbdp!pointer ^ string.sub ^, bh#number&PpvP!1#!number!! ^^ydcwd PNwpHb cdpp&number!  #&char ^ string.sub, HMNN11bN&char&#HHP#Nb!&, number#buffer&number&pHPPP, !Hbp&buffer Jb&buffer NH1cb ^ Lw# ^char#d1HNbNwjwb wN&1!cbc pbHc#char 1&, ^ wWd ^ bb#char!!pbP&!# ^bp&# 1 HN11pbwNl#Pc&dS#1H, pointer, number, ^ ^Ndp#cGccP&table&dH PH!wN, wN pb, Pcb!!1!&HbQ&cdbdP
-- PHASE_BOUNDARY:INIT     wNHp PdNp#table#&&&dcb, ^1w&bdwNy&number&!!HbH cbbPdcwbw, number&number ^ number!number##number#char!  number cwpwbbPNP, vPwpJ#bP !##HbHdN #Np, #1wNNp ^ number ^ table ^ #  Hbcww, 1w#string.sub#number!cppP#, &wdd#buffer ^ #, PNNN&wdP&cbpbcb#! dHPww, Hr pd, pcHc&#&Hcd, 1b&, eV;&string.sub&1c!1!1#&! ^ !& wp * char ^ number, NbNN, cb!&&string.sub&#table buffer wHcc - ^ ^wb ^ cip  %  Hp!&#, HdHw, HSpNcbP, buffer!PPcHbH, & ^ Nw ^, pHp&number&ccH1Hb&&table ^ ^table ^ &bit3c! ^char, N1bp&!Ncb&number&, bbb ^ bb, 2 ^ string.sub ^ 1&!table!## ^#number pointer&, number! & ^char, c1cpb! - ! ^&!& table, buffer, wbA&NNwpPHP&!&#char&, db &pointer buffer, &number&pcc1cb!&char ^ pointer!table ^pdcbNwNpNd, Pbc&HpH##   ^dw! HN11pbwNg! Hd&!!Hbbwpwwb .number 1dP!NH#1& / pointer ^  cH!wp
-- PHASE_BOUNDARY:INIT     NNd ^ wPQp#1LPp!string.sub!string.sub * buffer ^ ^dPFbN!number!EwbDPcHdcP * wbH ^, dbppNbPDP!!Pw!1! ^#string.sub ^ bw!, &NHw8b, cpppHPdbHNH#dNd!NeNdp ^ PbNP#bHcd! Nbbwbdwv ^ pa, Dcp1dPbPH string.sub bb, ww !NbN ^ 1 ^ number&#1##table ^ HbbPb ^ number ^, &string.sub#string.sub#1 ^ 1N#dc, pointer!#&&char char, cwbpAp ^ char!char number, Hb string.sub * buffer ^ number ^ ^1N11pbwp #!##&#dbb ^ ^Nw# ^^string.sub!string.sub#number#cbHNHN&#pointer * buffer ^ = ScN byte, cHb ^ HPc##1&1 ^ 1bN, wh 1Pb&string.sub ^ # ^HbdH 1bb&! + CNPp ^ 1bN, char, #buffer&&dN#string.sub ^ table ^ &, &Rcp, 1bP&1, HnH&pointer& cw1wb, &number ^ 1!number !pbccN#number number&, ^bw&NpN#memory number !pointer#!PHdbbh ^ ^wc !NbN ^ 1 ^ number&#1##table ^ HbbPb ^ number ^, &string.sub#string.sub#1 ^ 1N#dc, pointer!#&&char char, cwbpvp ^ char!char number, table, dw dHbw#7PpNp&, dc&!bbb!#HP& w2ddNPNwbNcONH##HdcdHpdpwH pNbp!1&cHpoHH&number * string.sub ^buffer table dN&pb, bpHH!char*pointer  %  !pointer ^ number ^ number, NNS ^ H1wb, char, ! &char&&pointer, dcwww, string .format, number number&number&char, #1&1&, bwb ^ wb ^ #phEcPbN, 1 char & table&buffer! ^1, bdN, cbpcH!number#1&1#& & ^HwP ^ NNbN ^ 1 ^ number&#1##table ^ Hbbbb ^ number ^, &string.sub#string.sub#1 ^ cN#buffer# ^& ^pointer& ^table ^ #number ^ zb, #number#char!#string.sub# ^&!! .bd ^ number, #, ^number&string.sub&number!!1! 1bdpd1bbb , ^N1d&cpcb#1#, pointer ^ pointer ^ bb ^ #, #K11pbNP#1 HP!& CHb&  number ^ pdb#!6!cc&&& HbP&!, Nxwp 1b {number!1#!number!#byte ^ Vdcwd PNwpHb cdppHHH&pointer& char ^, wb, &number, 1Hb&char&!char&1&1d& ^ ^^number&NHN#string.sub ^ pN!dP, &!!&Hcdcwc ^ 1N % number ^ number!number 1, #, &buffer &bN&string.sub, table, &number&pcP, cb!&char, dHd&buffer& ^c2b} 1N&string.sub ^ number ^ char&HHH#& ^&number ^ pointer, accumulator! ^&, cNcccPbHlH ^  !  pointer, number, >wNdwbP#!!#pPP&, wbd&buffer, #number!pp, PP, !number#dPbd#buffer! ^pdP Nwpd, bc##number&number&&!db& ^bdb ^ 1wHf#pp!!1l&ddP # ^!&number, ^NFwRn#Nbb#cP&pointer!Pbw ^ Hw * md ^ p1NPPNPb ce!bHd&, wPdwNHppbccPNb#number&#dN * char ^ !deIH ^ HpcQP!11hHNcb, HHwb number, ^wvb!gb!1bHHb!number &&, wY NH ^ bbwpcpwP  %  !byte!element * pointer ^  dpFNNPwPTbpb#pbbd! XbbwpddX&NbwbN#1PP &McdbPbwwNhFbHp#1did!bcPc ^ !pbb ^ !number&RH ^ CpbP !PpH&number#number# &HdpbP ^ pointer ^ H1pcbNd#&HbcbH#number!  JFbd1PbwcN#6bH&number& buffer, char, &9 array:#string.sub, !buffer&string.sub& pointer ^ buffer ^  1, 1NpNw_ cHb&##Hbd ^  number ^ pointer ^  gHa& PHP&#!##cHdHHPwp * PNX ^ :bcbbcP pointer!table ^pdcbNwNpND, Pbc&HpH##  table ^ ww#, &number& 1, cw!dc#&# number ^ number ^ &ddNp, 11Nb ^ !#! &number&cbpbb & >string.sub / 1b * 1NNp!pbw&buffer!wbd&& cb!number!number, 3c!lPcHbc, # & ^ buffer&;!N11bPNbc#char&Pd;#pb ^ wdF#user, number } 1, cpppHP!buffer###dwPww5Np_wHchbN!, # dcd&buffer, dP, HwNN, Hc!char#HPHc!! !&string.sub, CbpNww ^ bit3c&Nd!&#cd1dbHc&  NkP, NbPG !Hb&cbcH &dNddb rbp PP;table!1cN&buffer!buffer bHbw!x#bwp, number#char * 1NP ^ ! ^ table & ^&number# ^^pbp#number ^ ccP&table&dH PdNwdb, number!number& {cpc!ccb&byte& ^buffer!buffer , Nbb&PNNp#Pc !PHc ^ # ^number, cKwN ^ wwcO1Hb ^ char#cb ! ^#&number, ^NQwfPppHb, PdPw * Hbp ^ char, number bN pw, number!MPHcnc!bWbd ^ ^, bbPp1b!user!!HcWc&cwbH ^ pwc3Pbbb Nc!Nb, #, &buffer &bN&pw, ^ pbrcPc!number#;Pp& ^ pointer ^ # ^, LN, &1#pb!1HpHw! - ^table, char, ^bwp ^ number + NCb cH!, number#wwH, string.sub cpPwbP cwpw&buffer#!table!table!, 9, pointer - ^pb, PcdpH#ccH bHNd&number&string!pbp, bcwPcP !!HcbcwP, XbpN ^ 1dc#char, 1OH, dp#, && du (bd1PbwcN#ZbH&number 1bb&nw ^ wbGBydp&PpPC&pointer HpwN, PbPw ^ FbcpNbH!&VdbbpHd ^, ^1pNN ^ 1, number 1, #bdpd ^ ^^b1ibpppwN #oP&&#&1b#bN char, pNHpN11c1b&#&&HdP&number ^ Nwwa N1wPb&string.sub ^ # ##&&dc&& ^&, HFP ^ !1Nc >cbpwH&dH PH!wHb, NPw&lcJd!cHP&element!pb!pointer, pbcwNaNPNp, !buffer#&dpd#& ^, dE! ^H11cpcw1dH * dHbcb ^ &number, ^NCwge!pH!wbHdpdb, ^wd!CcNH, cNNbRP#Hbc!buffer * bd ^ ^, bbPpfb, cHNb#number!char!, Hc&! cbdbbp!number#xw! ^Hkce#table ^ dd number wpHbpPc!Ppb&string.sub&1 * 1, number&number ^ lb, &1dPb!1!, & ^& ^ 1d#, * ^cNbw, 0 string.sub ! char&&!dbbb ^ NbcippH1NPb!1P&table&dH PdNwwb, 0 .read ^ number&PbP#1 #&!& string.sub * 1 ^ 1 ^, 6 ^ ; ^pbN#!string.sub!1& =char, # ^ 1w, ^ ^pHp&char!char#number ^ table&&# #bb, string.sub, NR#, PPp&#lPbc, # pointer ^ wd, #papcN&char!#bHc&# #& ^^ ^, bKH, cbccp!, ##PH goto&Nb, ^ fcS&, ^1 string.sub #number#char&cdNb, buffer, wc ^ &pPpccppNb ^ #, #char number&, wdw NHN&flag, number char&#&Hc number 1b& ^7!number 1p} cpNPNHN!, db &wpw# ^ number 1dP!NH#1&zd ^  cH!wbw ^ math ^ number&PbP#char ^ cb&number& ^ ^buffer&, #, #byte ^ ENPdp, #!number&!cHcbc 1, string .concat, ^string.sub!string.sub number, char, #wHdcb # ^!wp PY, pwbdYb!#HPdNd&#pointer ^ &wb bwb, HNpbY#!PIdd Pb#number!dwBdp&Ppj!cwP, char #cH (dN _ !NgbN, Hc#!dbd&bHPH ^ dp, wpHbpPc!PpbHwd# Nbcw! sZH, #1Hc## .1P&!# ^table!&table table HNp1b, dc&!bbb&wH!& pointer#ddNPNwbNcaNH##Hdcd bdp &buffer!bH1pbbP, !wb!&cdH#table&, bax! ^QbdPPc##!1wd!pointer, ^accumulator ^  number ^ number! ^Hb#PdNdPP!PdH#string.sub ^ bw!, &NHwGP!number#!##1& ^dN #pointer ^, !, #number#pbcNcN!## & pointer# ^! ^cw ^, pHh ^ cPp#Pb!1db&Nbw ^  OPu&, ^1d!char!&# & HNbNwqwb ^ &pPpcPccN# #, &cH * bb ^ char, ccNp, string.sub, Pcb&Hp!#dwHN& ^ ^, ^number pHbccw!1c#pointer# ! ^string.sub ^ ^, !buffer (pdbwc#char ^ number&table&pointer!bbb &b5p41pbp, char&char ^ #1!&dd * 1 ^ 1 ^, / ^memory ^ pbN#!0PcHbc, # & ^ buffer&byte!N11bPNbc#char&Pdf#pb ^ wd + #char, wTb, cpppHP!bHNH ^ &table, pointer;PN#1!, wcd#&&pc!dw&, dbbN ^ bit3c, 1jPM!!ZHNPHd# dHdwbNPw&, table, table!string.sub!buffer#, &number!!bbb ^ number ^, &pbp#1 ^ 1b#buffer# ^& ^pointer& ^# ^#number ^ vNpNp ^ cbc #number!cdw&1 ^ dd ^ buffer&number&string.sub&number#cP!NHdH, H1bdw!number, iNpND#number#!!#pc, ddd * buffer ^ zNhcN NNcpc # table# char cb bppp * 1 ^ char ^ P1Hbdpdw& ^, HNcN ^ wwcPcc#cHNd pointer, bc, b6cpcbNc, char, #char!&pointer&bH ^ Pd!BNpEpb, wc&#!&1& !bb ^wdwNy, table <^number#NbH!&QdbbpHdw&, bbbpwNcp 1cbddPdwbNw >dHcw (, string.sub, 1 !char!&#, #char !, ^, number number&number&string.sub, pb!bcN&table! table#pointer#number# ^cNpN, PHP ^ PNHN&number  bb&number, pointer, number string.sub#cNcc! !Ndpd * buffer ^ xcRcN table, cHb ^ HPc##1&1 ^ 1bN, wZ 1Pb&string.sub ^ ! ^Hb&table!dbcwp 5# ^H1cpNc, ! &char&&bpbbwQ, number ^ p1gbNPwp ^ number&table ! ^bHd ^, Pb#w1D1P1bN!number# dPd&& ^^ ^, baH ^ dbccP!tbpH ^ db HHdwpZHNNp1Pbp&!&HH&PHNbHwNw string.sub = wdPc1b#number# ^pointer#pointer &, wZb ^ flag number#PbNcp, number, &Dd, bHHb, global ^ cNb, KP_N / !dH cp * Pb ^ ^ number * Ab ^ !1NN, char, !&&string.sub!# cbb # } pn1pbbNp#!ccN&number window bd&number!?bNcp#number#string.sub ^ ! ^Hb&HHcbcwp # ^H1dcbc ^ #number&pcb #dcwbw, number&number ^ NNcpb, # ^char& wH#dNbN7ppNbd, number!pP#Hc!string.sub * pHp ^ buffer, ^bPp!1, number&char ^ #wPHdb&number ^ number ^  <number ^ &string.sub#1cp&#number#char&wdb&& ^#bb (1pppwN char #dH!cH * 1 ^ string.sub ^ number +* pHPcP ^ Nw# ^& =!Zbpdd 1bHwNwPPwcH! Hdcp NbP&number, !Nw, 1, ^NppHpw&Hdp * char ^ number&bXPs ^ pwb&number #Pb!&cdH#table&, Pb, pwYbPHNp#bH!&& HH = wp, DcN&1dZP!AbbHw!HbP&Pwpb <Mbwbb#NH!wcb&pointer * 1 ^ ^number, string.sub bpFjctwp, HNHH&, Hb#&table, bwpw#DNi!!5HNPHd# dHdww ^ pw&, number, table!string.sub!buffer#, &number!!bc ^ HdHcb, string.sub, dKS!pointer#PH#pointer!!wb ^ w_ 5NPbdu, Nc1rbP&wdH  ^ddpRdN11Pb, cN#dbb& dw#wwpb! ^string.sub ^ !PgPdc ^ #bPP&wH ^ buffer  #, PNdp11cccb # &dd!&1 ^ lbN, number * pwb&string.sub ^ # ^HbdH 1bb&!7 {NPp ^ 1bN, char, #buffer&&dN#pbb, &wcpcPPcRpp# ^&pointer #, &Rwb ^ &pN = 1P!1N# ^char dHH& ^! 1, 1NpNw, EP !HHcH ^ cw ^ ^sdarPwd, !, table!string.sub!buffer#, &number!!bc ^ HdH ^ pbps#PwN!table >Hd& ^ bHPw? NH ^ bb#pcbNP!char!#&HbHbw!char#bwp ^ number * Nibb&pointer!, !#wwH, p_cpPwbcpcb!, HN## bdN ^ number {Pg ^ number, 1, pc!cHP&9# ^buffer!pointer  Nbbw pHPwc#!&table&!, pointer, bw ^ db#goto#pPPNP&Nd#number!1!&HPd1w1qp_ww3b cH#char# ^Pwd ^ buffer >&list, PNdw , number!table#pHcdP!bbw char, number Nbp ^ pN!pHN&dcw &pointer# NbNqwwwbbP&#!##&number char#buffer ^ wbccdwp, Hc + cN#number#, #1 * 1 ^ string.sub ^ wb window * pHPcP ^ Nw#char!#dP * number ^ string.sub ^, ^1N11pbwNI! Hd&!!Hbbwpwwb_pPm&cFp1b, PP&, wbd&buffer, PNdp11cccb # &dd!&1 ^ pointer, 1, ^NNbp, bcwPbHwH, pointer, wcw& , c1wb, char, ! &&&&pointer, b1wbw, NwN ^ 1bp##Bcc&buffer!, table pointer * number ^ number!pbPbcNPc&bit3c&number * number ^number#number BN, #PEPN!number! ^& &  Nbcwc, NplN, 1cp&#pc#&number#NH ^ pointer ^ number ^ ^ NHpcPwcbP#&string.sub&1 * 1, number&number ^ , &PpPb!1!, & ^& ^ 1b#number#, 1pppNb#string.sub #Pc&pointer (#1H, pointer, number, ^ ^Ndp#char )
-- PHASE_BOUNDARY:INIT     ccP&&number!string.sub cbNw number, ^Ppbp, char ^ char ^ 1, !# buffer&char ^ bd, buffer number string.sub number&char!!1Hb&NHcbb 1, number, ^string.sub#string.sub cPcc#bHb!number number&5wwbBN!number 7#NH!##1dNdNHb&&, number ^ &string.sub /, 1 >, string.sub, !, char ^ &dd# ^: ^cb& =Hp&, acH!NH!& ^ lbpHdwcrPN , ^number ^ cb#HHb&buffer!! ^.wP, ^_bw, string.sub, Pb!&#NPpdP ^buffer# ^, bb!pp, wcapd#cc!dPHpbwdw * pointer ^ dbLNccb#char#, &1 number#wwpb# ^object, NPbPd!number#dH&cd wdPd&b1bHppPbVd!&#bPb flag&Pd  ! dpPpwPN!KpHH#&pointer!dbw number bbppbb!number&!HbLH, dp#string.sub ^ !, buffer ^ number ^ #, string.sub, !!array!pointer# ^&buffer!Pbb ^ char, !ENN1bb, wc ^ #YPedPHH&number&table:pfbN, 1wY!!vP, table ^ #& ! ^bwc, #number#, ^1 ^ cb!Hcc&pHbbZb ^ ; for, number, 1, Pw!pointer#cHwcHbp ^ !number cwNpNbwc !1bPHw# ^  pointer#number#handle!NpwPb, cb#&HNcpdw& wbbcWH, 1b, number ^ char&number &table#char * char ^ PwI * pX ^ pdP#number, pg#, &string.sub!pb!db table dpPpwPN! )pHH#&pointer!pointer&number, Pb&NW ^ HPpPbc, #wP!dpbN ^ pointer&number, &number#, 1yHNHb PwPwdHb&&3w, {string.sub ^ string.sub, wcbbN#HPidd Pb#number!dwNPNcPpP1b&#number!1djb!buffer, wNCNw#string.sub#number!cpb, HH! ^#1Hwd ^ wdNEN&string.sub number 1N#number&state&bH&buffer&number! .1u ^bP (pcp number!!cdcbP ^} dp, ^Ndb#1, Nc!, Hpcp ! ^buffer * number ^b4pdbPP#!!pw&x##bjbN ^ ww, w1pPP1cbpf# !&#1Hb ^ count key, wG string.sub#1&char!##1wdAH#bbdP dNpN111PNbc#char&Pd .table ^ buffer ^ wdA#array, number <PHp&!!#1&PdN&char ^ char, PJD ^ pp ^ PbcHpdHcdP ZHpw!buffer NpwcINo!!NHZHbcw & ^HwP !NNpwP cbpPH!&, pointer& ^ ^wdHGpwBpb + buffer!pbHHd!number number&Iwwb Npp 1cP&!dbP&table# ^table!pointer#, &vSN#1Qb, Nx#Pcdc, #&#number ^ table, &buffer + number, 1pdpp Pd&pcdbPbwwNIabHp#1d8db!cp!& char#Hwpwb Nww!PccHpHHb pH#&!&!RAYdN ^ 1b {number!HP ^ cb!wH ^ buffer ^ wdr#error, wjP!number##!#char! dd&char ^ char, Pdo ^ pp ^ Pd!#!, number / &, pHpdHobwNpH, vcd!number##&!cwb!buffer table, result ^ 1!, Hc#!dbd&wbP&&pointer!dHNpNbp, PwN!HCc, &bd&buffer! ^#buffer 6Hpwb#number&!&number, table, dw dd#wH ^ cN!number, 1wP #string.sub#&table, Hb ^ 1wp, number  %  &ppwbc!!dHbH&#char * char ^ pw bHbpNNPwc #HH&# ^ ^ ^bwH dNc1PPjNp! ^Hdd#pointer, HM ^ pbpp!LdN!NdHPHwdNbiHHw#, dbdpwNPp&string.sub, number Pw * Hbp ^ char, number * bpPp ^ Pwc&! &Pc! cbH&table, bwpwd, ycd!number##&!cw !pointer#number, ^Now1Pb ^ number, !, cc&char * PbId ^ wb ^  number&:ccc!PHSH dP!number ^ HwbDcd, #1#cP#number#&PddP&1 ^ number ^, ^NbpH, dcc#pH, &#!Hb# ^ddd ^ NbPR&cLNHHpHb&, wH!wpqNNd ^ wb&string.sub#1NPbcH#&table ^ HwwH <& ^Op, PpNp#!cd!#!pointer ^ number ^ number, NNZ ^ HbdpN! ^number HHdw #buffer&number&buffer, error, pwbdp#!dcc&number#, bwpw, ^number ^ {1Pb!string.sub!wc & table ^ char ^ ^dwNi, #PbpN!NH_Hbcw & ^HwP !NN1abb?number#pc#&number#NH ^ &pw ^ vbNHwdPc!number#LPp& ^ bbH&pointer, cNpp, 1#RH!##dPd#NH#&wb:jPbwbHPpcc#Pbb& dw#wdc * pointer ^ &, Pa&PwNHHpHb&, wH!wHfNj number, PXVd!bPpH !wbb&pointer, &buffer!ppoNPp!number#dbw&#table#&vdpbpbpNbb ^ jP!1#!number!!number&KdcwN PNwpHb cdppHN&number!PHddwbb ^pbbP!char&#HPWd!pointer#buffer# ^1, ^hNN#memory ^ Pwc###Hb number Nb#:Pw&1 >ObN, 1, #, ! ^dd #number*wc ^ &number&1!cbc pbH &number!number&!, Hb ^ object& ^bP!cK!1HpPd char * number ^ number ^ ^temp#handle pNN#cH!NHNH ^ ^Nbc = number, 1bd} ^string.sub&number&table&## PbNwdw, w1pbPCc ^ !cb!&table#, ^buffer&, 1, #number pcN&!string.sub!1HbH, ^ ^ ^1b#NpN1bd +, string.sub ! ^!1& table ^ ^table ^ & .4?#, ^1cP#!##1dpdN #pointer, number ^ &string.sub , 1e, string.sub, !, char ^ &dd# ^temp ^ cb&table&pHbPl!!NHlHbcw & ^!, 1, bbp 1w:number!#cH!number!! ^bit3c ^ dw ^ ab ^ P1bP!number!!, !zone#char#, HPww, table + pd, pcd!1HPH, dNbdHbw, wbwp#cHp ^ 1bbbd! gbbwpddMb, 11Nb ^ !#! &number&char bbb &Xp:1pdbNNp!pbw&buffer!wbP&& cb!number!number, ic!tPcHbc, # & ^ buffer&0 .read!N11bPNbc#string.sub&HdN * 1 ^ 1 &, &NHpPNNcbc ^ # ^table& 1 #buffer ^ dwbcw ^ 1 ^ Pb!table#1Hbc!bq ^ Pw ^, 1 ^, number, 1bc&!Nbp&number#  &bcw 1NbN ^ PPP PNHdH  string.sub &&dwdb!pP, !PbpNb ^ Pw&number##table ^ wHb ^ NPw# (1pb!1cNHw& bPb& ^, ^NbpH, dcc#pH, &#!Hb# ^ddd ^ (, pp, >string.sub!buffer#!table&dH#rbbw ;PbHbpNNN ^ 1PPp!number#&#table ^ string.sub, 1 dN&pb, bccP!cNcP * wbH ^, dbppP  %   number&cc#, Hbd##number ^ ^, char ^ p1gbNcHc, number;&element!bbd&buffer, pb#wb, PPbP, # ^# ^char, #cH ^wb number&wc1bNbp ^ 1p&pointer# HPdcw!rcNwwpb ^ string.sub #JP!&!!!buffer * wNdHNM, Nbby string.sub#number#&string.sub&1 * 1bN #, SNpwp, pb!1HpHw# bPd&, gbb ^ , 1, string.sub ^ !pointer##dmdc&& ^!, buffer % cN -- BUFFER OP#1#number ^ char ^ #bHH#cbJHwwNw ^ number#number rBP, char table&table&! &1 ^ bbN <table ^, #number#char#PcHpH, table ^ NwwNPN ^ string.sub, number, 1c#char&Pd .table ^ buffer ^ wdR# -, number + Ppp&!##1& ^dNbc&buffer, ^ Nb, xPwP, #!# ^cwdwHdwH dN >wcFNNp!number! ^& & # ^&1d&, bw&1# -1cdbNP cC table&&dpb1IPp1bbj )
-- PHASE_BOUNDARY:INIT     char number&Hw!number * PHP ^ number buffer!pwi, cdp&Pc!char <  number ^ number ^, ^cN&number, PbP ^ PNHNdcdb&&wpb#;wwN, ^number ^ char ^ number HH&char wbb #, #number!pp, PP, !number#dPbd#buffer! ^pdP Nwpd, bc##number&number&&!db& ^bdbXw, char {Ncp PNP! > db ^ wb PN!string.sub, 1&number ^ !wbH&key# (buffer!pointer wbn pPwHPP1NbdPb!pointer!bb!number#dw? ^pE, 3PbbHPPPH string.sub bb, ww !NcpH9cpNPhc#&!!! ^zone ^ dw ^ Lb ^ PbmP, !Hpb&!#char#, &#pointer!bc ^ ^bb!char#Nw# ^&table .insert!string bwd, bHbwbHPpcc#P1bdpd1bbb , ^Nbn&Pdcb#1#, pointer ^ pointer ^ bb # -= wcpb number 1 # !&pointer! 1 ^ bwN ^ cNp1HPNcb#1c&&& HbP number, number, ^number ^ string.sub&char#char#! ^!1dbd ^ buffer ^ ^ Ebh#number ^ NNcdb, table!char&#char&char ^ cbbunx ^ 1!1 string.sub, !buffer&string.sub& pointer ^ buffer ^ 1, 1NpNwx number !HHcH ^ cwbPbcwc, NN number, 1cp !buffer#char&cdNb, buffer, wc ^ &ppj#PwpNb ^ char ^ & ^table * bH ^ char, wRb, #1#char!!pbPH, dbb& ^NdpfNNPwPD ^ pw!bbbd!} bbwpddN .NN1Nb ^ !#! HN##bCbNwNw ^ number number 1NPc!char#Ndj&, cd&, string.sub ^ #Nw, NQ ^ string.sub ^ ! ^char &Hdcbw ^ 1b#8#pPPNP&Nd#&HbcbHPdP, dbd1PbwcN#ZbHdid&bd ^ cw#NE ^ pbNPPNP#9cw!&!buffer ^ !wL, 1Np ^ d1ppb!number! ^&#& table, ^  ^byte!count#string.sub#1b!number!number##!  ! # ^number 1b, NNM#PbbN#buffer# ^&dd dNw!number key number#number!Pcc number, Hb string.sub * buffer ^ number ^ ^1N11pbwp #!##&#dbb ^ ^Nw# ^^string.sub!string.sub#number#cbHNHN&#pointer * buffer ^ ) ocN string, cHb ^ HPc##1&1 ^ 1bN, wk 1Pb&string.sub ^ # ^HbdH 1bb&! { >NPp ^ 1bN, char, #buffer&&dN#pbd, &mcp, 1bp#!wcc&number& buffer, &, &array, 7bPwP, !bP !#pointer&&, wPb&NPNc1pP1b&#wH1dbd, ^number ^ ^, 1w#string.sub#number!cppP#, &wdd#buffer ^ #, !Kp ^ Pp, PwcdpbH#dPbNb&&pointer, bNcN, 1bcPNwHCc!dH&number ^ string.sub, NEdbwpdN#pYbpcKcpdbb ^ &number, 1 - ! ^!1ppLbcP >PPdw Hb wd pNNpP, PNbbb#bPb !bC ^ 1, string.sub dN&pb )&pbPPHPcP * wbH ^, dbpNwb ^ char!Nd#buffer!1#qH &number cbcbdpPPceb! #wPwdd ^ Hd ^  pointer bp!1nPb!ppd&7&number * number ^number#number 9N, #number !1b#Hg!cdb#, &, number&string.sub!1bcb!Ncc&string.sub * HbN ^ 1, 1 ^ &number&1HPPbN#buffer# ^& ^pointer& ^1 ^ #number ^ {NpNp ^ char char #number!#dc * Nwi ^, ^1N > 1!1, cN#Nc#&# !bpd, number, _bp&1Ngp!table!&table&&char, bb ^ &number ^ _ ^ number&number#number#char ^ cb&number& ^bbb , Nwpd, bc##number&number&&!dbb 1, number, ^string.sub#string.sub number, !pP ^ &!&# #bb, number, number - #, number!number#!wPbc, dN&# ^HbNEbe ^ 1Pb * 1N#string.sub# & pointer# ^! ^cw ^, pHO ^ cPp#Pb!1db&Nbw ^  qP >&, ^1 ^ cb!Hbd&char pb, ^ dHu#NdwdP!1bP&cbcHbpbb ^ wb!pHq, number ^ char&HbH# char * number ^ table ^, bRNFwbPdNb#pP#!1#Pbbb ^, ^^ ccFbc#bP, ! table buffer  &, !B1pbbNpc!cHp&, pointer##table ^ number ^ , math .max 1cb&number, !1HbH, ^ ^ ^1b&NpN111b, !number! ^Hb##bAdcwb, ^, 1 string.sub&!!#1&bdN&char ^ char, PrZ ^ pp ^ PbcHpdHcdP * JHp ^ ^, bKH ^ dbccP!DbpH ^ ddb#buffer, dc NpwpPPpbbcP !string.sub!! ^bit3c ^ dw ^ Fb ^ P1bP!number!#Hdi#char#, &cd ^  mNdpPb#char!NwHe&&db # ^HdpuP ^ dp!Nc! <!NHNH ^  #  ^Nb#0HNN1Nb ^ ! ! HN#char * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1 ^ number ^ , ) 1cb&number, PcHwH, pointer, number&number& N111b, !number! ^Hb##bRdcwb, ^, 1 string.sub&!!#1&bdN&cwFwN  %  number (^1#1 cNP#& (&number * number ^number number ;NNcbcPN#array!, Hc#&bpd#wwbN ^ ^, ^1 ^ string.sub !table#char&wdb&#wpw13b_, 1&1 ^ cbP&&string.sub&1 * 1, number ^ number ^ FbN#1#Pb#string.sub#NH## bPd&, Bbb ^ , 1, string.sub ^ !pointer##dLdc&&wPwcrcNNb * 1, ccP &number&char cbNw, number, AcN&1&Pc#number#1H&# ^buffer!pointer, pbcwNONPNp, !buffer#&dpd#& wpb& / #N1b ^ PNbc#string.sub!1dbd ^ buffer ^ ^ x#x#number ^ NNcbc ^ HPc&#char #pointer ^ wH ^ #pppbPdcNP#Hp&number * number ^wbw ZN, c1wpb!db ^ char&#& &pointer#wP, NNdN, NbcdPN#, table  char &wpwb?dNN, pcWcN#HP ^ !&pointer * table ^ ^ bN&pN, pcP! ^##table db#! ^pointer ^array&11b#!accumulator!NHdH, #XbB&buffer, dbbpP, #NbpP#1#, pointer ^ pointer ^ table, dc, #number!pp, PP, !bH&&number!pbP ^ ^number#, Nbw!PHNw#bPd&pointer#!bpdp )
-- PHASE_BOUNDARY:INIT     .sub, PpNp#Pcd!cHp&string&!Ea >dN ^ 1b (number!1#!number!! ^HH&, bYibd1PbwcN# + 1H&#dd#pointer ^ bbpb ^ wH, table, number!table#pHcdP!bb ^wdw ^ cw, key!pPb&#wPH string.sub bb, ww !NcpH, HN, 1&number, !number string.sub#bw!} * 1ppwdPb!char!, HbdP!number ^ !pointer!Rc ^ pp#, number!NpdHwc!ddHp ^ &dwTP ^ dp user!number, 1p#, ! ^dwb ^ number!dd } buffer, 1, buffer;wpwpwHHd&# * buffer, wp * string.sub ^ pointer, bNNc!pWHd&Pd#buffer!Hww ^ _J ^ VbpNdp, 1&1wdH*pbcwPdb  %   Nwwwcm#HP ^ char#cbb! ^Iw1Ypbd1pNbcNc ^ table#table #, buffer, pointer ^, !, #number#pbcNcN!#char pointer!pointer# ^Pdb, CN, #PcpN!buffer! ^&pointer& &number ^, ^, 7#1!1cP 1, HH! ^ PH#d1b16b, Npwb !number!&char ^ & ^ pointer ^ # ^, WN!number#1#Pb! ^#NH## ^ wb#number#, 1pNpNb#string.sub #Pc&de#1H, pointer, number, ^ ^Ndp#chccP&table&dH PH!wN, wN pb, Pcdc # table# number cb bNgpc string.sub 1#!char!char# !, table& ^wP # ^1, 11bpNcw! &number&&table ^ buffer ^ wb, HbdpcPpc, !#1H&#dd#ddcbp ^ &NwwHcpcb!, Hwc! cbH&table, dwN, #buffer!handle!#zone#dH ^ db#number ^ pointer ^, key#1NbcP pbPb! pointer * bHwcw ^  wp!global#PccN# #, dHd& ^! ^#buffer ^ number!number#PPPcp!#!cp * KHp ^ wd ^ buffer& ^dpdDbN&#Pc&du#1H, pointer, number, ^ ^Ndp#cfccP&table&dH PH!wN, wN pb, Pcb!!1!! )#, &char ^ ddPJwNHp PdNp#dc &&dcb, ^1, 1bwN#object PcppH (HNdwd, &QwL bNdwbPHN#1bPP&1&, buffer ^ buffer ^ pointer, bc ^  pwN c1bc&string.sub!1# ^Hp ^  buffer ^number, cb!cc!wbpH ^ # buffer!&!number! !number:1N, HcNPN# ^char ##&#wpw1EbNNI#number#cN!, #, #1 * 1 ^ string.sub ^ wb NP, &P_Nbp, number, table, # ^ db#, +, cw&string.sub&number!!1! 1b&wHcHwd, .NhHN, 1HP#NH#pointer!string.sub!#HNH!wCeNbHp#1dTd1bcp!&dw#Hwpwb Nww!PccHpHcp#flag !Hqwd, Pm#string.sub!wwP ^ !qbs&string.sub#dH, & &wuHNppcPP (buffer!HH#dG!number, pointer ^  #bb ^ number NpNP!wH, char! cbH&table, dpp, #Wc_!# { dH ^ db#number ^ ! ^bb ^ number, ^1d!for!&# & HNbNwBwb ^ &pP, pP ^ pp#!number #1 * table .insert ^ ! ^ NNN, #1#char!!pP, table, dbb& ^Ndp * Pw, Nlbp ! Hd&!!Hbbwz, ^xc ^ !1cPHNH#pointer! !number# )^dwP, #number! ^wbwp#! #Nd!&, &1 ^ 1, jX ^ Ncw!number&string.sub, #1#&pointer ^ pointer#& ^, dl! ^H11cpcwbOH * dHbcb ^ &number, ^Niw:math#pHb, HPPw * Hbp ^ char, number bN pw, number!iP!cpc!bIbd ^ ^, bbP11f ^ ccb###&number number &Hd, pointer ^ 1N ^1 ^ cb!Hbd&char pb, ^ dHf&, Np, number char #dH!cH * 1 ^ string.sub ^ number FNp, &1wNbp, 1PH, dw dHb
-- PHASE_BOUNDARY:INIT         function ^ cNbw, ? string.sub ! char&&!dbbb ^ Nbc_cpPbQypc ^ #bHHcd * char ^ Pwf string.sub; ^pbbHDd!cHp&, pointer##table ^ #wd dNb?PA ^ string.sub#1 ^ 1wdH pbcwPdbxwp#1NPc!!1K&string.sub!table dd1wPD1Nbwmbbp&1pPP!string.sub!number * number ^, pointer!_cNHwHPPb {number#cNc!buffer:bd ^ ^, bbPp1b!math!pbP, !cdP#number ^ wwH, NdwpPHP&!&#char&, db &buffer ^ number ^, &string.sub#string.sub#1 ^ 1b#buffer# ^& ^pointer& ^table ^ #number ^ wNpdF, char!string.sub&Pc!cdc&1 ^} ^ ^byte!user 1, cb#&HNcp number& ^ wci, N11bb ^ !number! Pb&buffer#table ^ !dH, number ^ 1w, _ -number, char table&table&! HN ^ (bbN -table )^, #number#char#PcHpH, table ^ number, NNdNbwwP&!!HbH cb  bw&number, dwH, string.sub, !!array!pointer# ^&buffer!Pbb ^ !pointer!Xp1GfcNvNP#wHH&  dHpwd, 1NPN, 1NcdNb# Hwcw ddH 1 !pOpdb ^ cbpPHdH pointer  #wNwc, global, string.sub, 1 !&!&#, #char 1, www ^ wNNwPPP ^ char, #, !cdcbP ^ string .concat ^ <HB&string.sub&1cc, !1#&!, bb ^  pointer table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ number ^ pbPHcb!bb!dW * Pb ^ ^1 , Nbb&PNNp#table#&&&dcb, ^1w& ^, 1bP number, !HP ^ &number!#H1d1wb ^ NfwN PPP&1 ^ # ^&bdH#pointer ^ char, ph, number#wHPdbN!, # dcd&& ^wvb NPNcbcPN!, !, Hc#&bPbcwbbN ^ ^number, Ncc!1, HdH  string.sub &pointer string, &number&pccPcb!&char ^ pointer!table ^pdcbNwNpNg, Pbc&HpH##   ^dw! HN11pbwNS! Hd&!!Hbbwg, ^Xc ^ !1HcNc !, & } cd buffer&string.sub ^ wb ^ NHN&1&Pc!, #1H&#, bXb&number&, cp1p1b&string.sub ^ #!char dp#char&number number, number ^, Nbp&cpc#number &!&# #bbw ^, No#, ^number!number#!##1dNdN #buffer number, #string.sub!pcb string.sub, #Hc ^ dP##&1 * 1, 1wNNwp cPc&number ^ &table&& &bcw 1F& PHP&!&#cd1db &buffer ^ number ^, &pHp#1 ^ 1N#dc, pointer!#&&char char, cwbplp ^ char!char number, &pointer&   buffer#, number, char; WNPdP ! ##dcdc  buffer, number pdp&1, 1b#buffer!NdH# &# #, #wcppp, cHc ^ cN&buffer& ^ ^buffer&, 1, #count ^ -1PbP ^ ! ^#&pointer#pointer# ^ ^number, number, ^pbp PNbc#number!1dd# ^&& &, &number#pPbNcdc, cb&dHN, buffer, char, &number ^ pdN !number!cHc&number ^cb&NPNcbbNNp ^ !, !cdiH, ^pointer ^  Lpj& 1dP&!&#cdPdb &pointer ^, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer Np, &1#Pb! ^#number&pointer& bpb&ddKHg&1dScpN!1Pc&# !bp&Pw, >wNdwbP#!PHNH&cd &bb&buffer, ww!number, result&pNpJHd&Pd#buffer!Hww ^:3 ^ fbpNdp, 1&cb!pointer!pointer ^ number ^ number, NNu ^ HP  %  number&!pointer#cH# user#string.sub ^ NwP * number ^, cIw!db, HPPw * Hbp ^ char, number bNwb#PNcc#!PRdp#Hbd 1, PNbpb, fPbb&PpcP#string.sub#Pbww, !NcpH, HpIPvc#&!!! ^0 .write ^ dw ^ Gb ^ P1bP!number!#string.sub!window#cHNHPww, Hy pd, pcN!PbP&: number&1&wdpzbN!string.sub&PHNj!bH dP!Hbd * number  ^ wp6bNPNH#string.sub&1cd &bb&bbcp!, 1dad#number#number&number 6#table ^ number ^ , b&number, !1HbH, ^ ^ ^1b&0 .write#N1PpPNbc#string.sub&HdN * 1 ^ 1 &, &NHpPNNcbc ^ # ^table& 1 #buffer ^ bbN#string.sub, m1PbbN#HP !#table#buffer# char, string.sub pHp ^ pNcwHPH ^ & dcwcjPNn, ^1 ^ cd###, cF ! # ^#wb * ^NNp#1 char !#&char&cd * dN ^, number NdN&_ ^ number ^ !buffer#HPddcbp ^, number# HNdlNb, number #char#&! ^ _& wPwcvcNNb, 1, ccP&&number&char buffer&Nd ^ number, wcp! {, cdc HpH&#, beb&number&, cpPp1b&string.sub ^ #!char dp#char&number number, number ^, Nbp&cpc#number table dd !HHwbfAN ^ pc, !cc!HbH&Pbp&#& ^ # bp!1GPb!ppd&string.sub&  bb# ^&RpbPp1b!flag!pb&versan!cdP#number ^ wwH, NdwpPPp !&#char&, dbbbb ^, number, ^bpbMH!!1HHw!1#, &0 .read ^, number number&number&, NN!bcN&table! table#pointer#number# ^cNpN, PHP ^ PN#wdPd ^, ^, bcqcpPb * number ^ !table!&table&&char, bb ^ &number ^ type ^ number&number#number#char ^ cb&buffer& ^ ^buffer&, table, #: ^.NPdp, #!number&!cHcbc 1, temp, ^string.sub!string.sub number, !, #number&ddc wHH, pz!number, pcNNcN!wH &1!Pbdb number, #pNpcb number, !, # pointer&pointer&, char, number number, string.sub cdc&!, !1db&number ^ Hd buffer#number#string.sub#Nccpc, HHH ^ HNbNwswb wN&1HPPN!#number&char&buffer!wb!wb, cI#string.sub#_ ^ number ^ !buffer#table!cdbbcb, wb / Pbw1Td!!pbp#, cw ^Hd ^ bbc * buffer, 11Nb ^ !#! char, dbH ^ ^ ^, * 11NbNP#1 table!table#dwHb&, wN ^ #pphNPbP ^ #number# #number * buffer  ^ number#number!Ncp number, !HP ^ &number!#H1d1wb ^ NvwN PPP&1 ^ HHc!pointer& char ^, wbbHN#p1cNcN1bc dPH& ^Fdb, ^, number, state ^ Pdc#HBHc#&bfd#wc, NN number, 1 Nd#&char#&number!wbbb ^, number, ^bpb + table!!1HHw!1#, &; ^, number number&number&, NNp##pointer!# cHN ^ Hd, buffer&bwpbN#piPNHpdN pointer#number ^ &buffer#Obwp1pjpcb# ^PPdpH ^ bwd#b1wbpwp, number, char ^ cbH, & ^bOb , NwpdN#!xPcHbc, # & ^ buffer& - !N11bPNbc#buffer!1dNd ^ ^ ^ CPCcpb1bp&#string.sub#1&ddNHp ^ pdwDb ^ wbPK&pcb!table!char, #char ^ / char, bb, number object number 1&#!Hbdb Ndc, >, NNNN ^ number#number !NPpc&HNbdd buffer&wcqcPc1b#flag# ^pointer!pointer &, ^number buffer!pwb#cb#1H!&table! >  ^dw! ^1p1bpPwc&#pbbd! pointer ^ 1 ^ &bcIcppb, number#NH#pointer&1& ^ number ^ string.sub&buffer, number ^ PbmJoP ^ pbH cHdd&1 ^ dbN math 1cb&string.sub ^ #dc * dPdcbc ^ number  Nci&cPcc#bcN! ^pointer, dc, Kb, NdN PpP&1, HdH&pointer& cwPwb, &number ^ 1!number !pbccN#number number&, ^bw&NpN#handle char!pP##Hbd ^  number&!wc, NN, number, _Np&#pc#&number#NH ^ pointer ^ number ^ ^ NHpcPwcbP#Hw#char 1, number&number ^ table&wHP#pcc, 1b&pointer& bpb&dd, pointer ^ !1Pv!cbbNP ^ cwd ^  &number#number#buffer& ^ cPH1cHbP, pointer!# ^&#&buffer, dwcwwd, char  %  !, HHPbd#&char ^ pointer * 3 ^ 8pdP Np#Yc &buffer#char&number number, buffer, ^number ^ string.sub * pNc ^ ! Hw&&table ^ buffer ^ wb, HwcpwNbcdp ^ number&!&pointer&&# ^PwN?dm, L1PdbN!, # dcd& ^string.sub ^ 1, pointer
-- PHASE_BOUNDARY:INIT             number, #number <PN!table!, char  %  pointer )#buffer ^ ddbtp ^ #, 1yPcPp ^ Pb&wHbbd& ^ & ^&number& {PPcN#pointer#, #1 number, ^, number NcN&string.sub, Nip#number, &table# ^bP&# 1 ^ 1N1ANbwP #number#&! ^dbb ^ &number, buffer .cpdPNcP!!pwH&dH PdNwN <<Zb ^ wb&char!#1# Pbdwb# ^Nwci! ^hbcN&char#!1H ^ &number !buffer, ^ number ^ Tw ^ HPNpN#cHLHNd pointer, &Wwj bNdwbPcN#1bPP&number! ^Hbw ^ bN .HpNp 1, ! )pdHw#1#buffer& ^^number, ^number! ^d1cpb! 1wH ^ &&bHb#wP + cbbbXNccbp, number ! ! # ^#wc ^ string.sub#pcPwcbP#table#pointer! pHP ^ wTd ^ bb#char!!pbPH, dbb& ^NdpANNPwPP!pbPbP ^ !table#pointer#wwH, string.sub * cpPwbP cwpw&0 .read#!table ^ &# pbpbH1pbbP, !wb!&table number buffer + dN!_NPp!number#dbwdqH#&QdpbpbpNbb ^ xP!1#!number!dH&2&pointer&wvHNppcPPCb! #wPw error&!dcd! (number + Ndp )^PbNP#1H!char! HdndHdwNHppbccPNbHPH ^ dw &buffer, number !NcpH, HcdPpP ^ cz * dbP ^ #, ! wpP, pPccN# #, !number 1, number ^ number ^ buffer number} pc!bb, char #   pointer&number!, 1NbpNNccp#HHN&1 * 1&& ^&, HAP, N1bfdc ^ !&&1&##bb ^ 7c_cw#flag, cHb ^ HPc##1&1 ^ 1bN, wg * 1Pb&string.sub ^ # ^HbdH 1bb&!0 .write;NPp ^ 1bN, char, #buffer&&dN#string.sub ^ Hd!, &Tcp, 1bNH!##1dNdNHbd, number ^ &pJ, 1K, string.sub, !, char ^ &dd# ^4 ^ cb&array&pHbPW!!number#number& db#number ^ 1w! !NH NcpPpPHw&Hd bd&pww ^  number&pcP, cb#buffer# ^&wd dNwdw VbN&, dPdp!HPc!pointer!HN& ^dw, ^4&1#1#number&string.sub, HN&number  bb&number, dbHN string.sub#cNccbdH&&cb1bbdcb ^ number!, PpNcbNcN&number#, bb&, string.sub, #number string.sub Pdc!pHHbdpdwHj ^, HNcN ^ wwP ^ !gbt&string.sub#HHbHH, string.sub, bj, pw, !cbc ^ # ^table& 1 #buffer ^ bbXbe ^ string.sub ^ 1&!#!## ^&number * number ^wbw RN, c1wpb!db ^ char&#& &pointer#wP, NNdN, N1cb#IH ^ &char!!bc ^ HdHOdbpJ#NNN!table >Hd& ^ bHPwdw goto number#PNPcc cN&pointer&   buffer#, char, cm number, 1, number #pointer#&table, Hbbb number, Hb number# (#number#1c#string.sub#, dHd ^ dNwN, wN pb, Pcdc # table# number cb bNVpe string.sub 1#!char!char# !, table& ^wP # ^1, 11bpNcw! &number&&table ^ buffer ^ wb, HbdpcPPcgpp# ^&bdH#pointer ^ char, Puf ^ pp ^ Pd!#!, number + &, pHpd&bb ^ bbHC ^ cpNbH!& >dbbpHdw!4cNwwpbwp 1cP cb# &bit3c&pwb? ^^P1bP!number!#HdI#char#, &dd  jNdpPb#char!NwHr&&db # ^HdpKP ^ dpbNcc!#cHwcpdw& dP ! ^number ^ !1xcNNH##Hdcd !dpdw pNbp!1&cHpM#, &string.sub!string.sub wwbbNb#wPw!cKcd! ^HbcP bbcw!, NXbpbwwP ^ !Abtc! dH, bw&wRHNppcPPib!wcc&1&, buffer&buffer ^, !, #Nwpch!char!1p&string .concat!string.sub * HH ^ pointer& dY&NcP1P1pcb &!# bp&char * number ^ NNN 1bP&#string.sub##! dHbw ^ #number&table&number, string.sub, PwcdP#&string.sub&1 * 1, number&number ^ JbN#1#Pb#number#NH## ^buffer!buffer#number#, 1pppNb#string.sub #Pc&du#1H, pointer, number, ^ ^Ndp#c_ccP&&&dHbPb, wH pNbbqP&number, 1 # &table * char ^Hw, = ^#NcpNP number, #table#&dJd#HH ^ table PNpwPbdX, string.sub 1bH &#bcbcd# ^NH, ^PPN#11cb&1HN wb, number, &number ^ string.sub ^ PbcHpdHcdp, buffer#&table, #_d ^ db!ppp, 1p&bd! & ^Hdm .pw&string.sub#1bc ^ !Ncc&HHbbbb ^ number ^, &string.sub#string.sub#1 ^ 1N#buffer# ^dP#&&char ^ #buffer ^ Qw, #PpPb!pointer#number!#dH * number ^ number ^ ^qb >  pNNccwPbHdc ^ #&&& ^&buffer#zPNN1db, 1b#1&ad ^  cH!wc, table ^ cw, NlcFpIHd&Pd#buffer!Hwwdr&ppw!PHp, 1 cp!_Hg& <&!, eNN ^ Hb#PdNdPPdP#& HHH, string.sub, buffer =, pw, !cbc ^ # ^table& 1 #buffer ^ bbN#string.sub, x1PbbN#HP !#table#buffer# char, string.sub pHp ^ pNcwHPH ^ & dcwcGPN +, ^PHP&!&#char&, db &buffer ^ number ^, &string.sub#string.sub#1 ^ 1b#number# ^dbd &, ^bApi * number ^ 1 ^ pb!1HpHw#   ^table, char, ^bw1Pbccc!NH table, dc & ^&wcN1Nbp&number, char ^ !&&table&#table buffer wd, !bHpbPpPwp {&dd!#table ^ 1, string.sub, number ^ ;pHPwc#!&table&!, pointer, bw ^ db#NpN111b, !&! ^Hb#&#char ^ table ^ &, &;c111bP&1 ^ #dd (pointer& ^ bNyNpipbN&char&#!&1& !buffer ^ string.sub ^ 1, 1 string.sub&string.sub ^ P1b&1c&table&& &bc, 1, 1B&, ^1 ^ cb!Hbd&char Pby&pw ^ Qdp#string.sub} >char, #pPp!&HP&table * Hb ^ Np ^ bP!cF!1HpPdd& bHb * 1b ^ number#geN#cbp!&count&dd ^ bb&number, bhcp!1NPb!bpwH ^ dm#_&# pb!string.sub!, Pj )
-- PHASE_BOUNDARY:INIT             pointer#number#number&number object#table ^ number, 1Fb ^ Kp number&char#!1H ^ &number#!bc ^ number  Nbb ^ 4P!pointer! table &&table, ^ number#SkwcpcPPcDb ^ #ddfd&  ^ bNcNp?pbN&!list#&Hb&# HHpwP pointer / pointer, cb!cc!wbpHd# HP&! ! !N2bN, Hc#!dbd!pHP&& ^PdHNpNbp, PwN!#cHHcH Sdp #bNb!1TbdP ^ !bbP&1d!#!bwb .bcwQwPPwcH! Hdcpdwb ^ number!ddgb, 1, wN!pPPbc cd * number ^ char&buffer, Mw ^ wb!pH1Nb!dldd ^ ^bdPSde string.sub 1#!number!char# #number * pointer  ^ number#NcNcp 1, char, ! &pointer&&pointer, dbwb ^ NNHw accumulator#string.sub#!#cc&string.sub&, bHb ^ bN, wpPp ^ 1, char, PcHcdP string .format& ^wHw&string .concat&Ncb, Pbc&number, &key&& &bc, 1, 1a&, ^number!string.sub #pPc!NHNbNd, wb, &ppp#number cH#wH#&& &&, ^ number  %  pointer, #1#cP#number#&Pd _ * number ^ number ^ ^for# < pNN#! =!NHNH ^     ^NwcTcNNP / 1, ccP&&string.sub## number&Nd ^ buffer ^ ; ^, 1HPc!number#1!#pointer#buffer! ^pdP Nbb&PNNp#Pc &&dcb, ^1, buffer, ^pPp pN!pointer! &string.sub&&#pointer ^ table ^ &fQ ^ char, N1bNc# <cc&buffer!, table pointer * number ^ number!pbPbcNPcHcdP * tHp ^ ^, dN#number >number, !pbpHd#bHHHd, number, wNNbT, Hc#!dbd!1Hp&& ^PdHNpNbp, PwN!#wH#dH 1bcww Zr, pp, pPdbbP&Pd number * number ^ number, temp HNdANb, number #char#&! ^dw& wPwcqcNNb, 1, ccP&&number&char buffer&Nd ^ number, wcpPJ, cdc HpH&#, wb&number&, cpPp1b&string.sub ^ !pointer&temp&&pointer buffer  number, NNZNbQ&cPcc#cHNd pointer, bc  _P8cpcbNc, char, #cH&pointer& cwPwb, &number ^ 1!number !pbccN#number number&, ^bw&NpN#0 char !dH!&Ndd#number ^ number, pd NN, ^1 ^ cd###, cy string.sub&& ^#wbt ^ NNQcP!1b#buffer# ^& ^pointer& ^# ^#number ^ wNpbp ^ cPp&PcH## ^ bd#, string.sub, 1NdpNN#char!!NHNH ^  buffer  ^Nbc .cpPb (xpc ^ #pointer&#&, #kb, wp * string.sub ^ dbbNNPbp (Hd&Pd#buffer!Hwwdg&ppw!PHp, 1 cc!RHp&1&!, / NN ^ Hb#PdNdPb!string.sub&number#string.sub ^ bw!, &NHwnP!number#!##1& ^dN #pointer ^, !, #number#pbcNcN!## & pointer# ^! ^cw ^, pHg ^ cPp#Pb!1db&Nbw ^  iPA&, ^1d!accumulator!&# & HNbNwOwb ^ &pPpcPccN# #, &cH ^number ^ char, cTNp, string.sub, Pcc&#&Hc number 1b& ^0 .write!number 1p / cpNPNHN!, db &wpw# ^ NHbwP#char&#&char, &, wbd #, #NP1Nb&?pointer#:#number&number& ^buffer#buffer * wN ^ # (string.sub -pNPNP )^  # &Ndcbc ^ NY < Nch&cpb##wcN! ^table ^ buffer ^, HXcpw1bp#!#table!&string.sub!number, ^wwd bN#1!PpNP!, Hw&pointer!buffer ^ #number!apq ^ string.sub!, gcd!wH#table ^ #& & ^!, 1, bbpwP#cN!cH!cC * pHH ^ Hbb
-- PHASE_BOUNDARY:INIT             Pp1bb = WcHP&cp!PHPHP ^ number buffer!pc1HDHb / cp!#dp#!number -wd, ^NbwPPbc!string.sub!#number#EHcH, &number, wjHN 1d / string.sub!number#PPP&bHw&1dw pNbp!1&cHpZ#buffer&  number#table ^ dbNbbwP, pNNp&pHHpdb!db& ^bdbZP, ! aP!number#HH dd#string.sub ^ table ^ &, &Ccp, 1bP&1, HHH&pointer& cw1wb, & =^string.sub ^ 1&!table!## ^#number pointer&, number! & ^char, c1cpb!list! ^&!& table, bb, string.sub, ( ^string.sub ^ N1cb#string.sub#number!  ! # ^#wbz ^ NNp#number ^ cw!#table#&1bNbN ^ #buffer NP, &P0Nbp, number, table, # ^ db#, type, cw&string.sub!Pbcc!#table#! ^pointer ^ bb ^ Hbc * cppb, number#NH#number#, &, pointer ^char ^ &number, wcpwp, number, char table&table&&, 1 ^ 1 ^, zw: ^pbN#!uPcHbc, # & ^ buffer&goto!N11bPNbc#char&Pdi#pb ^ wdh# {, waPpp&!##1& ^dNbdb, string.sub, &number, 1Hb&!math .max!#PHd!pointer#bwdb, CNw11wpb!db ^ char&#& &pointer#wP, NNdN, N1cb#string.sub#wc} pointer * bHwcw ^  wN ^ 1C; + cHPdc!cHbpbb ^ wb!pcbH:HbNcK!#dp#!w_wd, ^NbwPPbcc#!HN&1 buffer#number ^ ^, Gb
-- PHASE_BOUNDARY:INIT             NHhdN#NHHpHb&, wH!wHb, 6 ^ number&PbP#1 #buffer!& string.sub * 1 ^ 1 ^, x ^ function ^ pbN#!string.sub!1Hdc, #  ^ 1, string.sub ^ ^pHp&cqc#number ^ Hb&# #bb, string.sub, Nh#, 1Hcw!##&&&# ^wwd ^ #ppp1PbP, #&# ^&1H& ^string.sub ^ 1, 1 string.sub ^ string.sub ^ Pbc###Hb string.sub Nb#  SPw&1tZbN, 1, #, ! ^dd #wVwc ^ &string.sub&1HcPc, #HPpdbbk ^ & ^, buffer function * pHPcP ^ NwHs!#dc * number ^  ^, ^1NPSNPdP ! ##dcdc  pointer pointer, pp, #NbccP Hd#cbmbNwHw, wcpPp, number, char HdH&&, &1 ^ 1, string.sub, number ^ fp PH!char! ^1w& ^=HSdHtd ^, NdwwcH!string.sub#char&Pcb * table ^ #, versan PN!, ^0 .read&pbpwc !number!number * number ^, pointer!EcNHwHNNbx!bPjdd Pb#number!dwNPNcbcPN! !, Hc# bPbcwc, NN, number, 1cP&!&#cdPdb &pointer ^, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer ?Hpwb#number&!&number, table, dw dd#, string.sub, 1NbN, number&number ^ !1c&dpd1bbb ^, ^Nbp#number#cbHpHN&#table ^number &:array ^ 1w, {, number, 1 ^ #dH# -cd&number!CbNcp#number#string.sub ^ ! ^Hb&HHcbcwp # ^H1wb, char, ! &char&&pointer, dcwww, ?, number number&number&char, #1&1&, bwb ^ wb ^ #prucPbN, 1 char & table&buffer! ^1, buffer (number, cbccP!;1pH ^ db * HHdwcZPN5wpb ^ cb!Hbd&char Pbt&pw ^ Gdp#string.sub, 8kc, #pPp!&HP&pointer, Hb ^ Np ^ bP!ch!1HpPddbbcb, w1RPbw1bN#cc!NH table, H1bdwbw ^ zNppwbP!1c#number#, pointer&pointer ^ ^pw, cJ&pd, Pcwb ^ table!table# NH1dewN ^ cN&pbJP!!number!Pwc ^  wbH ^, dbppNbPEbcwPw&!&#bN&1d number ^ 11PbwcN#9bH&bHN, buffer, &, &number ^ string.sub ^ Pd!#!, number {pointer!pointer# ^NdbbNXN, #1PpN!NHyHbcw & ^!, 1, NcpHsfcpPFHdH  cH#dbwcb#pHbpPc!Ppb&0#char 1, number ^ number ^ wNpNbwc !1bP&pointer& bc&# char, cw pHNccc#PHucpd ^ bdw#number, bxppb Pcc&#dPP&, table ^ buffer ^ 9Njcpwp, number, char ^ cb&buffer& ^ ^buffer dbb1NcbPPkNp! ^Hb&table!dbcwP, + bpN ^ 1bPHNd#char&pd, #HHw#, dbd, Nc ^ number, 1wcc&pointer!Pbw ^ Hw * hd ^ p1NPPNPb char#!bHH&, wPdwNHppbccPNb# HwcwHcdN * table ^ PNHwpPbc!!&HHcLd, bp&string.sub & ^cw#result!PbN!HQHd& ^ bHPwG NH ^ bPPpcbpP ^ char!#HH, Hbw!string#bwp ^ PyNKb#cb!HHPbd&number, number;HN 1d / string.sub!number# ^table#&  bH!wdb, versan ^ number&PbP##table#number&pointer&, Hr ^ * db_d ^ bbPy#p11PHbH, ^ ^, char {Ppd1bPc!cP table dd !dbwd?1W ^ pNPp_b!wPPdb# + &&buffer, NbHNchbPP!1#bPKdHH&&pdPbPbPNwb, ) !char#HPH# - &pd#, string.sub !pupdb ^ cbpPHb&!!!bwdw & wpHbpPc!Ppb&string.sub&1 * 1, number&number ^:1, &1dPb!1!, & ^& ^ 1d#, window ^ cNbw, char string.sub ! char&&!dbbb ^ Nbc5cppb, number#NH##HdcdHpwP &gPbH1pbbP, !wb!&buffer& ^ ^buffer&, 1, # =^RbPPP ^ ! ^#&pointer#pointer# ^ number, pointer ^, string.sub!, &Ncbc#char!1djd ^ ^ ^ buffer, accumulator, pbP&cNppHP! pointer& char ^, wb ^ #string.sub# (cPwP, !, # pointer&pointer&, 1, number string.sub!, number#char&number, & ^#&bPbcwb, 1w&1#11cbc, HwH ^ db&#wnbcFb ^ number char number&table!&1 bbN char, cNPp:, pP ^ !buffer#HPddcbp ^, number# HN#pd, pointer!pPpcNcp bb! ^&, HbjN, 1p {string.sub!dPbcN! #array ^ dwP, #number! ^wP!number, #char# table ^ !#table ^ #wd dwbvpPwNp#bH!&& HH >wpb&buffer#N1b ^ PNc&1b&number#& 1&Wwww, number!number ^, wPwpdHHcd 8HcdN * pENy ^ 1 * 1 * number ^ 1bP&&bH&buffer ^ db, pointer ^ Nw, yP&1&Pp!1dPbb ^ bdY, number&pw / PcPpP#number&, !!, pointer, number buffer&wccccocN#number#, #cd ^, ^ ^number ^ wNpNP0Pbb&Hp!#dwHN& ^ ^, ^number pHbccw!1c#&number * dbb ^ char, char ^ number 1dP!1b#wPb&, pointer ^char ^ & number; ^number&number#number#string.sub&cN&pointer#, buffer!&& char ^ cNcsbPKP ^ #!# ! bwwd, cxw ^ HPpc!!, #char!NdN * number ^ wb PNdwHb number##number#ccdd& cw1wbbcw ^ 1!number !pbccN#number number&, ^bw&NpN#array number !pointer#!PHdbbM ^ ^wc !NcpH, HpbP -Hbc > dbP ^ #, ! wpPpcPccN# #, &char#!table ^ char, cNpp, 1#YH!dcNH, & bcb&, string.sub, 1NdpNN#!for!NHHH, #ib - &buffer, dbbpp, #NbpP#PP ^ !1 * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1 ^ 1, string.sub, number ^ Vp Pdc!pHHbdpdwH >^, pointer + ! ^Hbfc!char, #number&number## # ^!wpb, +, pbP&cNppHP& ^pointer# ^bd!sdw, string.sub ^ 1&!1!#& (&number pointer, dm, Fbbpd, bcPp#P1cPdbd, ^ ^^ ^, ^cp#number!cppP#, &buffer &bN&string.sub, NtP ^ Pb!Nw11b ^ char&!number!number ^ Hwp, cNP ^ bPPP ^ !number#&table number#! ^cwH HNd} key? string.sub#1, 1bd! -bbwpdd;!pcbwYp!PP cP!!HPH!number - % NbHp#1ddd!bcp!&#1#Hwpwb Nww!PccHpHHd#NH#&number&!WdtdN ^ 1b (number!pointer! table &#bNbc ^  ^NNdN 1 number##char#cH & buffer, pointer, &6, 41PbbN#HP !#table#buffer# char, string.sub pHp ^ pN!number#number& db#number ^ pointer ^, table .insert#1NbcP PNHpH pointer  #wcwc, number, 1HN ^ !Pb#cb#1 * 1dN ^ ww NPN&? ^number ^ !buffer#HPddcbp ^, number# HN#pd, dcbPPc&!char!table ^ string.sub ^ bw, yw ^ !1cPHNHPN!number## bH!, string, d_ ^ pb, Pcdc # table# number cb bN * dx string.sub 1#!char!char# table, pointer, wdw& , 1bbpN!Hb char### #dcwpw, NHN ^ NNcN!wH &1!Pbb ^ !dwvbK ^ string.sub ^ 1&!1!## ^#1H& ^string.sub ^ 1, 1 pwp ^ PbpcH!&vdbbpHdww ^ 1Ndw ^ math&string.sub&!&table!dbd #bwnbc_bM, 1 ^ 1 ^ 1N#number&string&bH&buffer&wH, Pb!pNbwc !1bP&pointer&   buffer#, number, cy (NPdP ! ##dcdc  buffer, number pdp&1, 1b#buffer!NdH# &# #, #wcppp, cHc ^ cN&number versan bHww& / HNPw!PN!memory!bbw&! bbc ^ #, # ^^number ^ 1bPHbc#number!1dNd ^ ^ ^ buffer, number, pwPdcc!wbHdp !buffer, ^cbNgNNwb PbNP#DH, dH!bbw char * number ^ Rww, _Pd! 1p&NdP#number ^ ! buffer ^ 1 ^ ^wpPbc!!&HHczd, bp&string.sub, number ^, number, 4V!pointer#PH#pointer!!number ^ number ^ char, cINp string.sub, Pcb HPHcdc * number ^, ^ char + &string.sub&1c!number!1#&! ^ !& wp * char ^ number, NbNN, cb!&&string.sub&#table buffer wH )
-- PHASE_BOUNDARY:INIT             cO ^ ^wPPPc!char#number& &, cd wb, cNcpNP, number, !cc&dpH#bwdN ^ ^^number ^ 8 PHcc#wHb## # ^!wp PV, pbP&cNppHN&number!Pb!dwbbb, ^pbbP!char&#HPj&, pHpd buffer wNp!, tcd!number##&!cwbPbcwc, NN number, 1cp #number#char&cdNb, buffer, wc, &number&pccPcb!&char ^ pointer!table ^pdcbNwNpNK, Pbc&HpH##   ^table, char, ^bwp ^ PSNH#!##&#dbb ^ ^Nw# ^^, 11bb ^ char ^ !&&table&#pointer ^ table <, d_ ^ pb, PcHb ^ HPc##1&1 ^ 1, jO ^ Ncw!Pdp, ! ^#&pointer#pointer#& ^, d_!, 111cpcwbuH * dHbcb ^ &wRPEcpcbNc char, #char!  number * char ^ cwNi, 0, pcb&char&!char&number&1d&& ^number!buffer NpwcfNpN!NP, Hb&&bpb#, Ndp!, Hcb#string.sub#wcLd * bd ^ !dHlbpppwi + char #dH!cH * 1 ^ 0w ^, cb!pcbHAH!dcMc ##HdHb, !:hN1bp, dcb#char#, &1 number#number ^ &buffer#QcNNb * 1, !table!&table&&#table ^ ^ ^, 8cw!1!Np#CPp&number! ^table&&dwdbb ^ &string.sub PH!char! ^1w& ^ tH = wpbd ^, number&FcNcNdHPHwdNbBHH, _, &Ndpcb#!QppHN&number!PH pointer# dNdw, 1P, number!table#pHcdP!bbww#, NCcp!, GcppH#NcP&, HLb ^ db {string.sub ^ HpwKP!_bO&1cbbOHH ^ buffer number * PwQb!nb! 1HH&!number &&, wa NH ^ bbwpcpwPh!key!4 * pointer ^  dpANNPwPP!pbPbPwcp bb! ^&, Hb:number, 1pIpp&Pb&FcdbPbwwN?7bHpdNNNdb * table ^ &Pd * bP ^ 1dPe!ww, 1O ^ Np!bH ^ cP 1b!&!, table ^ number, cyjuP!number#HH dd#string.sub ^ NwP * number ^ pointer, wNbcHppHb&!pointer&bH& )wb ^ &number#t1Pb!8# ^Hcc! cbHdcbNpp, #1bX!#list#dH ^ db#number ^ bwcT!NNpbPbDw! ^Hdcn#table ^ dd number wpHbpPc!PpbHN#char ^, ^bmpI * number ^ 1 ^ pb!1HpHw#  #pointer&, char ^ 1p1bpPwc&#pbbd! pointer ^ 1 ^ &bcDcppb, number#NH!, !Nd ^ table buffer wd, !bHpbPpPwpC# &table * char ^Hww ^ zo ^ string, dNHcwpH&string.sub&bd, bw&!, char?table ^ HgppJb##bP! goto * db ^ wb PNep, PH = buffer!#cc!state##table!pointer# buffer bN!1#, wc ^ #OP -dpbd&, pointer ^ dwNHppbccPNb#number!char! table!dcwp7HNNp1Pbp&!&HH&PHNbb&pointer, ^bdN#, 1N cH#wH#&& &&, ^ wid, #1#cP#number#&Pd 7#wwNdw, ^ 1, cw!dbb&# number ^ number ^ &dda&NbwbPwb!number cN! #state ^ dwP, #number! ^wbdc&#pb!&number#, table dp * 4 ^ aw!number!PA!NpHH#&pointer!pointer&1 string.sub, Hbppbb!number&!Hbz& #& Hbb ^ ^, NwcppPHcN!1Hb!&pointer&bH ^ PbN number, pwb&cc!#char &table wb# ^&, & ^, number, 1wPdb###&number number &Hdwb ^ 1NpN ^ 1&number 1, #, &wdd#buffer ^ #, !2p ^ Pp, PwcdpbHw#char dH, pointer  zm pdb!uH!bcN&table! table#pointer#number# ^cNpN, PHP ^ PNHN&number  bb&number, 1t! ^!1Hp {1cb char#cdbPbwwNvkbH1_b&cd!char##dS!pbN ^ PdPj!ww, #, buffer!!#aHbdp!pointer ^ string.sub 1, number, ^string.sub#string.sub cPccHpHb#&bpbb, ), number ^ pw&PPp&#lPbc, # pointer ^ wd, #pIpcN&char!#bHc&# #& ^^ ^, bFH, cPhPN!number! ^&#&  Nd#wH, NNNN ^ number number !Ncc&wHbbd& ^ & ^&number&object#PPcN#pointer#, #1bb ^ pww, &Np ^ bP!cd#1#&!cdcbp ^, number# HNwN, 1, number #char#&table, Hcb!buffer, number string.sub&string.sub&1, 1b#buffer!NdH# &# #, #wcppp, cHc ^ cN&number buffer bHww&;HNPw!PNcw# HbcP 1b!&!, table ^ ww ^ wwcH!string.sub#char&Pcb  bw&we;pH, ^ObN ^ ppHb&!pointer&bH&bit3c, table / Nppp ^ 1, !HpdH&&buffer!buffer&!, !buffer * Nr ^ dPPPw!NHxPHdd&number&pointer * 0 ^ NPp PPcbpPH!!number#1H ^ &pwbC ^ ^P1bP!number!#table!?!pointer!number ^ Hwp, cNP ^ bb PwNwP&!Hdb#!wzwd, ^NbwPPbc!string.sub!HH#rHcHw&number, number:HN 1dspcw# ^&!cd cdb sb! ^number, ! - ^5d!PHcPbd  wHw, LNHw ^, pointer, buffer!!#qHbdp!dbb * 1, string.sub, ^number&string.sub number, cbHpH & ^ ^d1wbAp * number, number string.sub&!table#1H ^ dN&char ^ string.sub, table * NN11bN&char&#HHP#number Nbww, 1bPN ^ ; ^Pbc##1Hc#& & ^HwP !NNpwP c1pPHb&!!!bH 0   wpHbpPc!Ppb&number& ^ wb& ^ nPb!pcbHIH!pointer&string.sub!##!#!wkwd, ^NbwPPdNH# PH&char#number&& ^!, buffer = cN#1#number ^ char ^ #bHH#char bdbd&bPw11bPpcw!&HpPb !bdwbw& ^cNcbpP, char#pHHd#number##&string.sub number, NNJNbwwP&!table#PP!dN * number ^  wb PNbp!, !number ^ PMHPPw * Hbp ^ char, number bNHacPbp, !, Hbd& NHpwN, PbPw Pwpb!Hbp&bd! & ^Hd (, number&1cN1cb#BH ^ &char!!  pointer ^ number&1HPPN!#number&array&buffer!wb&wH, Pb!pHg, cPp&PcPddcbP ^ 2dp )!number 1p_cpNPNHN!, db &wpw# ^ NHbwP#char&#&char, &, wbd #, wwcwwn, !number!table#, &Hd##table ^ dbpb#wNw!Pa!NpHH#&pointer!pointer&string.sub Pb&Lw ^ HPpPbc, #wP!dc * HHHdw ^ pw#pb, !! - !pointer# ^&buffer!number ^ 1d ^, char ^ #pbJccNp, #Pc ^ ddH#buffer#wPhNk& ^db&PbNb#number!!! table#Hd, number, wNNb , HcP#1Hbcz number&&pointer!bNbdw&, bT {cd# PpdN PHPdbAwwbpH, pcb!!#&&table!for bd&number# ^1N_b!1, cN#Nc#&# !bpd char ^ ^Nbp#cbccP&table!db cb#number#buffer ^ 8 ^ pbbHpc!cHp&, pointer##table ^ PbN number string.sub Pdc!pHHbdpdwH: ^, HNcN ^ wwP ^ !7be&string.sub#dH, & ^&waHNppcPPIb! #wPw#char ^ Hd ^, string.sub bp!1ePb!ppd&string.sub& bb# ^&jpbPp1b!} !1NPw&PcwbH ^ pwcIPbbpwNcN 1!cc&string.sub * HbN ^ 1, 1 ^ &number&1HPPbN#buffer# ^pointer ^ pointer dNwNb number pdP!cN!dbP&number * pb ^number ^, ^Ndb#1, number <#pc&char, #pointer&& ^&, table <number ^ !1NPw! #1PPdb !table!dbbwwcpd, Pcw!table# &pointer!string.sub * number ^ ^, ! dNcmbNOp#1PcP!!!dbPwcdbW Nwwwcsb!PPP! 2 * db ^ wb PN ^1bP## #char!&pointer!bb ^ cw#global#number ^ string.sub ^ PbcHPcH##1 * buffer ^wbw ^, p3b, cHNb##!char!, #, ^cdb, by#pbbccp#1bd&#H1bbdq !9wi, string.sub, 1 ^ 1N#number&2&bH&buffer!wb, cf#string.sub# * ^number ^ !buffer#table!cdcbp ^, number# HpbMNPWP #, #&! ^pointer ^ bb ^ HddecpPb? >pc ^ #bHHcd * bdbwH ^ ^& ^wb&cH!Pb!&pointer#, buffer!&& char ^ cNc {1PyP ^ #!# ! bwwd, cGw ^ HPpc!!, #char!NdN * number ^  wb PN!, ^byte!string.sub##&H_&# for, &element, string.sub ^ pointer ^ , wcH#&Pa&, pHpwPbb ^ ! ^dPPPw!NHgPHd# dHd * char ^ PNHwpPbc!!&HHcBd, bp&string.sub, number ^ buffer, number, d9i!pointer#PH#pointer!!wbdw&2pb!pN {, NbbpPD!string.sub#&#! ^char, number HN#pd, dcbHPc&!!!table ^ string.sub ^ bw, Mw ^ !string.sub, number, cw!&Hc&#table bHww, #0&string.sub&3, number, !number#pointer!# #&char ^ number ^ error ^ FNbw!number! ^#, &, HcbcwP, string .format ^ ^number ^ 1dc#char, 1aH&#& Hbb ^ NwcpcPPcFpp# ^&pointer #, &:number, _p ^ pbPNbp#pd&number&number * number ^ 6&table
-- PHASE_BOUNDARY:INIT             9 + &pdbcP##Cbp&NdP#number ^ !, number ^ 1wpwpPbc!!&HHcq !HPw# PqN ^ ^JcPp!table#NH1dbH&buffer&wH, PwNpHc, Ncb_P, &, dwbd ^ cww Hppb!number, ccPNHN&number  bb&number, ! ^^wb, wN ^ char ^ #bHHcd * char ^ Pw ( string.sub / ^pdP#number, pC#, &string.sub!pH&db, + dpPpwPN!_pHHP#Nd, & ^, HNcN ^ wwP ^ !hbMc# dH, ^number&wRHNppcPPcb!1ccdN# ^buffer, &2N ^ pp#number !1PcHcdP * 7Hp ^ ^, bhH ^ dbccP!Cbp&number# bi&char number !NN10bb >number#pc#&number#NH ^ pointer ^ number ^ ^ NHpcPwcbP#table#pointer! pHP ^ bN&pN, pcN!PbP&! number&1&, dpjbN!string.sub&PHNh#HHNdpd ^, wHdds&NbwbN##!number &gcdbPbwwN );bHb_NNP, char HcH&# ^bbd, number, cNcpNP, number, !cc&dPdc ^ pdN ^ , cb&number, !pointer! &table&&table, ^1 ^ &, & * c1P1bP&1 ^ #ddRd&  ^ bNfNp * pbN&!!number#Hc&number, wHw&number!number#, HPHpPHpcP 0#, & db, 2#1cbcN#string.sub ^ HH! ^ PH#d1bb;1, Npwb !number!&char ^ pointer ^  buffer ^ Hwb, bb!1 .PPc ^ !1P, table, dbb& ^NdpQdw string.sub&1cc, !1c#& ^Hcbwb, number string.sub&string.sub&1, 1b#number#, db# &# ^&buffer, Nb, &PPPc#string.sub#1!&pointer ^  1 ^ 1 ^, * number - ^pbN#char##!HpcPd, bw ^ ddb =#string.sub!1p {Pc, #wHdcb * number ^ dwb, cNc, 1 cd!!cb&pointer * 1 ^ ^number, string.sub bNw, PP!string.sub, # (table, dH!bbH char * number ^ kww, FPd! 1p&NdP#number&buffer * buffer ^ 1NpwpPbc!!&HHcgd, bp&string.sub * pointer ^ buffer, Nb -table!pointer#PH#pointer!!number ^  #, char + Np string.sub, pb!!cN&pointer& buffer#, char, char: PdP #pP#!1dc& ^bbcNqNN1Hb, 1c#!#, &, pointer ^pointer ^ &number, wbpbNNcHp number#!#pointer#&char ^ string.sub ^} table + ^ NPNcw# HbcP 1b!&!, ppa, char = lBP!number#HH dd#string.sub ^ dwb } number ), pNPdfb! #wPwdd ^ Hd ^  pointer bp!1 / Pb!ppd&handle&number * number ^number#number LN, #number !1b#Hn!cdb#, &, number&string.sub!1bcb!Ncc&string.sub * HbN ^ 1, 1 ^ &number&1HPPbN#buffer# ^& ^pointer& ^1 ^ #number ^ uNpNp ^ char char #number!#dc * NwE ^, ^1p1bpPwc&#pbbd! pointer ^ 1 ^ &bc3cppb, number#NH#number#, &, pointer ^char ^ &number, wcb&cNpc!wcb&pointer! ^table&pointer&number& ^#NPpNPdP, P1H1dpdwHf ^, dA! ^H1bcy! ^#cP!dc HHHwPNpw#number ^ ( zb#!Hg&1 string.sub#pointer ^ !, ciw ^ pb = number pHPCPb!, #wHp ^ buffer, ^bPp1b!2!!pPwc&cwbH ^ pwcmPbb1p11cbc, table&table ^ db # ^#wbNNNNp#number ^ !!!#table#&1bpbN ^ #buffer NP, &number .Nbp, number, table, # ^ db#, count, cw&string.sub!Pbcc!#table#! ^pointer ^ bb ^ Hbc + buffer, 11Nb ^ !#! &number&char bbbdP, number ^ 8pwTyc!string.sub number#cHd# 1wNwNbb ^ &1PN&!;1bP, !, pointer, & ^^dw#N_Ncl&number!!buffer#cH#pointer#table ^ buffer ^ wb, HwcpcPpc, !#1H&dHN, buffer, char, &ppp1PdcNbpHpcw bHwwP & ^cw!1cPN!, !, cN!#bpd#wwbN ^ ^, ^1 ^ string.sub !table#char&wdb&# ^#, !:string.sub ^ Pp, PwcdpbH#pointer! pHPw wNdpc1wjH#pH!&, dc&number ^ Nwwt NbwPP!char, !&# ^&number!Hbddtw&bbN&, Hc#pP#dc .pointer!#buffer ^ HdHc ^PpH = 2!Ppb#bcHdwHPb, .5N ^ bbNN#cH##& } cP !& ^pointer! table ^ table ^ H1pcbNd#&Hbcb wdP  buffer!bd1PbwcN#XbH&#dd#ddNbPmH ^ pbbP!char&#HPLdpH&&string.sub 1 } c9bp1bbP Nb#number!!! HcHdwP  %  cbbp 1wfw#Lc!! ^#table#bw!, CAbppwdP&cbpbcp#!table ^element&dePiwpNPh <table!PcNH, #   ^table, char, ^bwp ^ PmN ^ 1&&pointer!, number#wwH, pjcpPwbcPc ^ #wH&& bPH!wc, HbH, Ccpp#!bb!pointer / dd ^ ^bdP, &number ^ 1cN#cP#dHb&char char& ^, da!, 1bNpN! ^number & ddb! ^Nwd PNwbpP * cNb ^ # ^&pointer #, &nw& ^&pcW1Pb!string.sub!wPu&  db!&table, 1Nep ^ 1c <!!char#HPH#string.sub&error ^ !dc = dNPp#number!sw! ^Hich#pointer&Hd number wpHbpPc!PpbHHd#buffer * HP ^, buffer ^ ^Hw wN, 1PbPHwd, #! ^cwH HNdPpN#pcp!&state&dd ^ bb&number, ! ^^wb, wN ^ cdHjH&&   dNwNML = buffer, &PPNp!NPpdN! &1 ^ - , NNbNN#char##!Hp!, pointer, bbw&, NbppH, !Pcp!HcP, ## # ^!wp number;, pbP&cNppHN&number!Pb!dwbbb&wbwHcpcb!, Hwc! string.sub ^ NwddwV&, # -1NdpHPHcwcw * table ^ &dW Npwpe pd#GbddPdwbNw (dH , Nb .1 cc!&char ^ &db .buffer& ^, wNpNP -Pbb&table&!#pointer! Nb, ^, ^1N2b!1, cN#Nc#&# !bpd, number, Gbp&1NJp! ^number Hd&char 1bb #, #number!pp, PP, !number#dPbd#buffer! ^pdPf!number ^ 1pr#p1pHHbdpdwHVwPb&NTwb number, char, number ^ Hd&#bobc &, &number!11b ub! #wPw 0 .read&Hd ^  1b, ^pbbP!char&#HP <dH * number ^ string.sub ^ ^number, NH ^ db&PbNb#number!!!, #number ^ wwH, NdwpPdp !&#char&, dbbbb ^, pointer N1db !table!&Pd!number * bdNwH  ^, 1#pc!string.sub!, &table& ^&Nbw, number, ^array, string.sub, Nccc#PH?! ^ table & ^&wcE, Nbp&number, !user!&table&&cb1bb ^ &buffer ^ number!, PpNcbNcN&number#, bb&, string.sub, #number 1 Pd!!#NHdcP * number ^ pw, number ^ ^number ^ 1dc#char, 1E&!&# #bbw ^, NK#, ^1wP#!##1dNdN #pointer, number ^ &pk, 1Y, string.sub, !, char ^ &dd# ^8 ^ cb&bit3c&pHbPn!!NHJHbcw & ^!, 1, bbp 1wnw#Vc!!char!! ^7 ^ dw ^ Rb ^ P1bP!number!#Hd #char# &char&dvPFwpNPi:table#0 .read#&&ddc #wqdp )
-- PHASE_BOUNDARY:INIT             NNPwP_w!wPbHHcp bb! ^&, HbApp?&Np11HcHbdb bb &buffer, ww!number Bc >pointer!PHcPbd  wHw, state ^ Hwpw!cYcd! ^HbcP 1b!&!bNwspPwwcH!string.sub#char&Pcb  bw&ws {wH, ^string! >buffer#!Hn&1 string.sub#pointer ^ !, cow ^ pp ^ number pHbwPb!wHcHp ^ buffer, ^bPp1b!table .insert!!table&2!char#string.sub#number ^ wwH, NdwpP ^ string.sub !pointer#char&1db&# ^number, dK1NcbcN char #dH!#1d, dNwEw = cN&function ^ Pd#buffer#&table pointer &number ^ number, 2, bw&string.sub&number!!1! 1bd#HcbPb, number ^, ^, NbNcrcbpwH&pointer!bbb &buffer, Dw ^ wP5pH11b!didd ^ ^bdPIbNcb!PNcb#bbw& ^ )HFwphd ^, wwwwcH!string.sub#char&Pcbbp&: ^, bqN, number&NNPw#number# ^table, pointer, &char ^ char, PSDw ^ 1PN pNbbc pointer * pointer ^ !wN, dbPpwPpc !NP ^ table ^ ddb#buffer, dE / pw&number, / dp&!&HH&number!!bNwOwb wN&1!cbc pbH &number!number&char table, bb!1JbdP ^ !bbP&string# ^  pointer#number#4PpNp&, dc&!bbb!1b!& w6ddNPNwbNcoNH#number!Nd ^ table buffer * wHRcz ^ ^w1bp#!, cN&number element bHww&6HNPw!PN!byte!bbwd / table#bbdN ^bpN ^ 1bPHNd#number!1dd# ^&& &, &number#pPbNcdc, cb&table !, ^number, number ^ #number#1!Ppp, #!char ^ !!table# ^&wA, #NIN Zcp1db, char&cw * table ^ &pointer / NpwpidpbPNH!cB * dbP ^ #, ! wN ^ 1RqZp!Pdc, dP!number ^ Hwp, cNP ^ bP pc! ^number, &number# ^buffer&pointer#, buffer ^ cpp 1, cb#&HNcp NbP&number, ! ^wwb Bp!buffer#!table&dH#8bbw ZPbHpbNNNwb&Pp!number#number#table ^ string.sub, 1 dN&pb, bpPH!char dB!pointer ^ number ^ number, NNe ^ HbPpNc, number HHdw #buffer&number&buffer, <, pwbdp#! ^cc&number&, bPb ^ bN, wpPp ^ 1, char, PcHcdP user& ^^ ^, dN#number gPbb&##!1dbbpbwd +, Ndp!, Hcb# + table ^ &char!!bc ^ HdH + pointer, pi#NcN!HcHd& ^ bHPwb, !buffer!number ^ char * pc!dbP&wdH  ^ddpxdN11Pb, cN#dbb& dw#wd&buffer!kb ^ !POPdc ^ #bPPd!table ^ &1dwb ^ + d1Cb&number ! cN&number key bd&, number, cNNpbN&char&Pb&1dp wb&wpdbN!pdPbP&1c#char&pd, #HHwd ^ number ^ #, pNNcN# {bPwd&buffer!wbw bN pw, wpPP!char ^ dp!buffer ^ !we, 1Np ^ db!cc!wbpH ^ # HH&, dbbb ^ wwpbbc ^ pPHb&!!!bHdw buffer wpHbpPc!PpbHb#char number 1w ^ wNNwPPP ^ char, #, !cdcbP ^ % ^ number 1Pbcc !1c#&table # ^3&Pw, ^ ^number#, #number ^ pP#number#, Pd ^ bdw pc 1 NHpwH!table#pointer# cd&number&SHNPENbw!number! ^#, &, HcbcwP, string ^ ^number ^ 1dc#char, 1 (table##& Hbb, #, NwcpcPPcnpp# ^&bdH#pointer ^ char, PMf ^ pbPN !XbccNc! number ^ - ^bdwNp, #1wNNp ^ number ^ table ^ # Hbcww, 1w#1#number!!string.sub! ^table!char = dbww#number ^ ^ number&1!cbc pbHw#char#number& number, Hz, pHb#vH!dcpc##number#! ^array, number HN#pd, dcbPPPwcp bb! ^&, HbtN, 1pIpp ^ Pb&ecdbPbwwN = hbHp#1d <pointer!bcP!&#string.sub#Hwpwb Nww!Pp!number#dbw&&table#&Pdd * table ^ pointer, NwwPH!&1cH, dp#string.sub ^ number, buffer ^ number ^ wwzPdcP!#table!Pw &&# ^!wN state, SbPj!!!, HNdNH#buffer#number!, string.sub ^, number * for ^ Pbc##NHc#& ! ^bwc, #number#, ^1 ^ cb!Hcc&char pb, ^ dHNb, N1Xb char&!&char ^ & ^ bbH&pointer, cNpp, 1# >table!##dPddb&number&, dp % bN!string.sub&PHN_#HHNdpd ^, wHddM&NbwbPw#!number cdcdbPbwwNKgbHpw, bP pbH cc# ^ dwDw&, number VNPN!memory!bc&dTH#table ^ dHb#number#string.sub!PpP ^ !!1B&ddwb#buffer ^ &, &number!11b Rb!wccc #!&char ^ char, Pxe ^ pp ^ PbcHpdHcdp, buffer#&table, #Wd ^ dONpP!Hbp&bd! & ^Hde, bw&string.sub#N1cb#3H ^ &char!!bc ^ HdHb, 1pc#PbN!table -Hd& ^ bHP ^ ^buffer ^ number&, #1#cP#number#&Pd&, &1 ^ ^, ^NbpH, dcc#PHycpd ^ bb ^ HddFb, 1bHt ^ string.sub&pwH&dH PH!wdb, number!number&8cpc!ccb&5& ^buffer!buffer , Nwpd, bc##number&number&&!db& ^bdb_wb! = number#NdHPHwdNbaHH, array, &Ndpcb#!0ppHN&number!PH, wwbb*table ^ pbbP!char&#HPudHH&buffer# ^1, ^jN, cb pb!buffer! ^table ^ &&buffer#buffer# ^^ ^NNbN ^ PdN&1c##! ^ number&#wpwbNBNN % #number cN#number# ^dbd bN char, pNHpN11c1b&#&&HdP&number ^ number ^math&11b#! / !NHwH, #qbh&buffer, dbbpH, #NbpP#1#, pointer ^ pointer ^ table, dce?wcpb number 1 # !&pointer! 1 ^ bwN ^ cpcbPcSc #PbwdH * buffer ^ char ^ buffer#?#pPPNP&NdHp!1dNd ^ ^ ^ buffer, Nc, ^number!number#!##1dNdN #pointer, !, #pP, 1d, cNP#table #number * buffer ^wdw wNpcp number char#table!Hc& table, buffer, ww, dbbp#number!cppP#, &wdd#buffer ^ #, !Qp ^ Pp, PwcdpbH#pointer! pHP ^ wxd ^ bb#cP#number#&Pdd& bHb 1b, ^number} pP!number * #dHP&# !#number ^ ^, Kb )
-- PHASE_BOUNDARY:INIT             ppRdNbpwPcPPdw Hb wd pNNpP, Pc!1wP#!string.sub#pointer#Hwpwb Nww!PH!number! #, dF!dbbdpw, bwpb, dc&string.sub!Hp!Ndbd ^ buffer ^ ^ kbX#number ^ NbcPc ^ # ^table& # #buffer ^ bNRdw, 1!string&pcPcHc#1 * buffer ^number!number ^, pdp number char#HNHc& &number ^ string.sub ^, ?#1cbcP 1, HH! ^ PH#d1b1Xb, Npwb !number!&char ^ dPH buffer& ^char Vb, #1cpc!number!, table, & buffer&buffer& ^, ^1NwN, number!number 1##&!, pointer &&wPwcEbNbD&Pccb#1#, dwd ^ bb #5mwcpb number 1 # !&pointer! 1 ^ bwN ^ cpZwwPNP ^ ### !Id, number&number&buffer, 1bbpN!Hb char### #dcwpw, NHN ^ NNcHb, # ^table& 1 # ^  pNNw, string.sub&positan!!number!cHb&1#PbPdZ, number ^ lp!, number#pH##Hb number number&1d&, Np number ^ number&# {number#!number!!bwd, table ^ &Ndb&cpN!#Nc, dP#dbd&pointer, PNc ^ bPPpc#Bb, char # buffer!buffer#number#, cw string.sub, 1c!string.sub!1c#&# !bpd table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ NP, 1&Pc!, #1&buffer& ^bPb bNadM 1pb&Nd!dP!dP#!bbdN ^bwNw, # ^ HP ^ &number!#H1d1wb ^ NiwN PPP&1 ^ HHH&pointer& char ^, wb, & ^pointer, NN&char&#!&1& !buffer ^ string.sub ^ 1, 1 string.sub&string.sub ^ Pbc###Hb number Nb# ^bit3c! =#string.sub#1b!string.sub!number##! pointer * bd ^ !dHq1pXb ^ PcN!#buffer# ^& ^pointer& ^1 ^ #number ^ w1wPb#Pb#number#NdH# ^table!&char ^, ^NbpH, dcc#pH, &#!Hb# ^dddCb, number &Nbp, 1, PPdw Hb wd pNNpP, Pc!#wcbc ^ #&HdHw, table <pNcbP, bcw##HN&char !HWwH HN wPbNN (!cbbHc!table, &PwcbIN!wbPiNH#bPPdb#, buffer >^ table bNwFcowpEP {Pe&pointer HpwN, PbPwbEwpb!Hbp&bd! & ^HdJ NpwpG&pdPNH!ce * dbP ^ #, ! wN ^ 1JsxpHPdHwcHbpbb ^ wb!pbp ^ number ^ char&HbH#& ^&1 ^ number ^ ^, ^} &1#1#number ^ PNHd!, !table&dcbctc, 11ob ^ !!! char, &, buffer ^ &wN pNd, 1&Pc!, #1!#  &char ^ number ^ , array 1&1&number, PbHwH, bH pointer#number& ^, 1NA&cPccHpHb#&buffer b1wbw, NwN ^ 1bp##8cc&buffer!, table pointer * number ^ number!pbPbcNPcHcdP * EHp ^ ^, dN#number _c!char###Hbd ^  Nb# ^, wg#string.sub#1b!number!number##!  number&&wK 1b, number, string.sub, number ^ cd!#& {cH&buffer&wH, Pb!pNbwc !1bP&1d!#! ^HbTbbbwbHPpcc#Pbb& dw#wd!buffer! ^^ppwbc!!string#1&pcdbpb wb, #6&1p, Pcb!!1!!pH;bPHw, H_pNcbP, buffer!PPcHbH, & ^number!number#NPNcY cPccHpHb!number number&rwwblNbw * #NH!HPNc# string.sub&# ^number * Nb ^ number ^ string.sub ^ number cH!cHw&1H#bPwd, 1QcpcJ number !pointer#!!1dwd, buffer, ^ Gcm&number, + ;number#1, table, &number * dbc ^ wdHNpp!1, PcbN#NHwd * 1HPwbb ^ temp number#PNPc!number!, &buffer& ^&1 ^ buffer ^ ^Ldr wbbbNH#!PHdP#1H, dz, .buffer& ^, 1dN, !!1&cc#char cdbw;number ^ number!number 0 .read, number, !number#dPbd#bPwNw& dN&pb, bp!number!HdcP * wbH ^, dbppP_ NPbcH#Hwdc * wb ^ &number?YwHw ^ byte#gb!!table#Pwd ^ buffer / &table, string.sub ^ Hw pointer, number!table#pHcdP!bb ^wdwNf, HzSd!#function#dH ^ db#number ^ 1w! !NHP:NcNwpPHw&Hd bd&pwwQ ^ string.sub!wdPc11b, cP!PHc& ^&pointer, PNc ^ bb PwNwPc!!db#!number:wd, ^NbwPb&string.sub ^ #&char#&number * dbb ^ char, char ^ number 1dP!1b#&!Nd&table bHww, #error&string.sub& ), number, !number#pointer!#pointer#bPwNw& dh, :1P, string.sub ^ ! ^Hb&table!dbcwp, function# ^HbNpNc, number table dd !HHwbW <number ^ pc, !cc!HbH!1Hf&# ^bd!NJNdp ^ PbNP#1H!char!#number&wwPdwNHppbccPNbHPH ^ dw &buffer, number !NcpH, HcdP (c_cA * dbP ^ #, ! wpP, pP#pp#&number #1 * flag ^ ! ^ NNN, #1#char!!pP, &!# ^Hb&number ^} ^Nb1HPbcbp!&CdP ^bbd, number, >bp&1NFp!PP cN!bH buffer wd, !bHpbP >char ^ !cb!&cdHHc&, buffer:math .max! ^gbdPPc##!1wd!pointer, ^string ^  number ^ number! ^Hb#PdNdPP!PdH#string.sub ^ bw!, &NHw3Pbp&!char#1H ^ dN&char ^ string.sub, HyNN11bN&char&#HHP#number 1&, ^ number&zone, number#math char !dH!&Ndd#number ^ number, string.sub ) NN, ^1 ^ cd###, cfd ^ && ^cwb <&NNKcPc!number#8Pp& ^ bbH&pointer, cNPp /, pcPb HKcc#number#! ^number, char, bbwbpN#cwbNP ^ ! ^pointer ^ & ^Hwc7wNbf#number#!PHNH&cdbpdbwNw ^ number#number 1wN!#dcbH ^ !dbHb&, !, # ^HpHkP!pbP&:char, # Hb ^  number#NcNc, #temp ^ pb#!!1 !# ^^dd * bcbd1cN1Nbb ^ #number& ^ !#pointer ^ cb1fw ^ wpw, wcH#&number / pointer table& ^#db, ^, pdp number char&number, &string.sub&&buffer&buffer#, Ndp!NbcbPNHHc ##&# ^#bcWp {, 1Hb ^ 1N#number& * &buffer!wb&wH, Pb!pNPWPbNw#&&HdP#! ^Nwwe NbwPP!char, !&# ^&number!Hbkd eZ, pHwbPw1cbwcC! ^#mbdw pNNpP, Pc!1bPHPb !bv ^ 1, string.sub dN&pb, bcwP!number !char!pointer ^ number ^ number, NN; ^HPVP&!pointer#cH# temp#string.sub ^ NwP * number ^, wPp;buffer#!table / &1 string.sub#dw} wNFN + ^1#1 cNP#&string .format&number * number ^number number * number, c1wpb!db ^ char&#& &pointer#wP, NNdN, Nbcx#!#, &number number&# ^#, !2pw, pbN ^ char !#&number&char number, ^bw ^ wbpbp ^ Pdc 1b&pointer&  table&# 1, char ^ #1pN#cwbNP ^ ! ^pointer ^ & ^HwcBwN1e#char#!!HpH ^ pointer!#7 ^ dwwM# (^, &1&char!#1# Pb string.sub * 1 ^ 1 ^, zone&char ^ pbN&!string.sub!1HbH, ^ ^ ^1b#NS, cbbk, string.sub number table #& !bbwb, NwcpcPPc {pp# ^&pointer #, & >number, _p ^ p1PNb1Nb PLdd Pb#number!dwN!number, PqP * char ^ table!PHd# dHdwbNPw&, char, table!string.sub!buffer#, &number!!bbb ^ number ^, &pbp#1 ^ cN#buffer# ^& ^pointer& ^# ^#number ^ , &PpPb!1!, &number& ^ 1d#, string .concat ^ cNbw, goto string.sub ! char&&!dbbb ^ NbcCppH1NPb!1P&table&dH * PdNwbw ^ versan ^ number&PbP#char ^ #number&buffer& ^ ^buffer&, #, #list ^ pbN&!string.sub!1HbH, number ^ ^1b#number#string.sub!PpP ^ !!1q&ddwb#buffer ^ &, &number!11b Bb#string.sub#1&1&, buffer&buffer ^ wb, #ppp1PbP, # ^# ^&1d&&, wHw& (&NcPPPbc&number ^ &!# bp&char * number ^ NNN 1bP&#string.sub##! pointer * bd ^ !dH = 1pppw3hc #dH!cH * 1 ^ string.sub ^ number Iz * pHPcP ^ NwHz&&db # ^(Hdp -number )^dpbNcc!#cHwcpdw& dP ! ^number ^ !1WcNNH##Hdcd !dPd ^ pNbp!1&cHp} #, &string.sub!string.sub * wddbNbb ^ 5bdPPc##!1wd } table#bc ^ number  1b!pN!pointer! table &#bcbc ^  buffer, NdN PpN#1b#char! db&cwtwNvHf, IcP!number, !, # ddd&, 1, bwNpH, number#1###!cdpd, ^table ^ ^ ^NNNpwP c1pPHb&!!!bp, fbc ^ global ^ PbwPHc #dPpdd * 1 ^ number ^ NNd ^ bb PwNw#pointer!!#number#!wcwd, ^NbwPPdP ! ##dNdc*number  %  cN ^, NbdN, !!1&cc#char * cd1wjw ^ number!number 5, Pb#string.sub# table ^ pointer ^ &1 ^ 1, string.sub, ww 1!1#char#!1H ^ &Nd#  ^ number#NcNcp pNc, ! &pointer&&table ^ ^ ^wb + HNbpb, !! % #PH ^ &1# ^buffer, &QN ^ p1Hb&char&!cH, &1d&& 1Z ^, pHe ^ cPp#Pb!1db&Nbw ^  vPY&, ^1 ^ cb!Hbd&char Pb {pw ^ Tdp#string.sub, 0 .write * char, #pP, ! HddNw; oNdpPb#char!Nw#pointer&& string.sub#! ^number, buffer&number!, oNbpNp!HVdN!Hb# ^ddd ^ NbPB&PHNHHpHb&, wH!wbw ^ ) ^number&PbP#char ^ #number&number& ^buffer buffer * wN ^ #pgpNPNP ^ #buffer# &NHcbw 1, db ^ number&key&number&1##PHNddd, dbwxR!2, pNPNp#!#table!&string.sub#, buffer!pointer ^ number, #pNpcPwP, #!# ^cwdwHdwH dN / wcANNp!number! ^& & # ^&1ww ^ 1Ndw ^  string.sub&!&char#&PdNbdb, bbaep!string.sub, PN!NP#table#pointer! string.sub&, ^ bN&pN, pcPb #&Hcd, 1 ^ buffer ^ ^_Pz wbbbNH#!PH&number#1H, dhw string.sub&string.sub&string .concat pN#buffer!NdH# &# #, #wcppp, cHc ^ cN&number string bHww&GHNPw!PN!_!bbw&& HbP&!, NNfNbwwP&!table#PP!dNbobb&number, &number!11b Zb! #wPw#char&1dbbP_H ^ pbbP!char&#HPu&, pHpd&buffer! ^&, !1b !#x#dH ^ db#number ^ 1w! !NHInNcN, 1bcbc > dbP ^ #, ! wN ^ 1atrp#Pccb#! dHPww, table ) pd, pcN!PbPc #HH wd, (PbwbHPpcc#PbbdPd ^ bw ^ &number * NP ^ !1cPHNH#pointer!table .insert! table&&!&bE!NBpbPpOd!bHcH, dbbPHw, Mb!NHJNPp!number#dbw&dH#&?dpbpbpNbb ^ ;number!1#!number!!number& % dcwP PNwpHb cdppHN&number!PbVdb # bp!1 / Pb!ppd&list&number * number ^number#number _NNcbcPN!, !, Hc# bPbcwc, NpLN, 1cp&#pc#&number#NH ^ pointer ^ number ^ ^ NHpcPwcbP#table#dPbNb&&pointer, &nb ^ bbHp!pwbP&wdH ^ddp, wN ^ 1!, pointer!pPbPw!char#number&!dPdd} PpcwbP cwpwcc * HH ^ bb&bK!NnpbPpRd!bcb&number& ^buffer#buffer, rpw ^ 1!1#char#!1&number&Nd#& number!number#Ewwb PNb##table!Ndbd ^ ^number ^  ^NNpN 1 number##!#cH #, bHd ^, Pb#w151P1bN!number# dPd&& ^^pointer:8h&number 1 pN!NHaHb#&buffer <pointer#wc, NN number, PHP&#string .format##cHdHHPwp * P_d ^ Sbc !#&char&char##table ^ wHb ^ NPw# + 1pb!1cNHw& bPb& ^, dpyp&1 char PNHNdfdb&& ^&, !NbN wbPwbc#1#, pointer&pointer ^ ^ ^, number >cw!1!Np#?Pp&table! ^table&&dw&, cp1pbDcN #!char dp#char&number number, number ^, Nbp&cpc#number table dd !HHwbYp / ww_b cH#char# ^Pwd ^ bt&global * pointer ^ dw, pw, number!table#pHcdP!bb ^wdw ^ PbHl ^ PbNbH!&_dbbpHdw!rcNwwpPPp 1ccNcb#, Hb&pwbn ^ ^P1bP!number!#pdB#cHpHPww, HD pd, pcHc&#&Hcd, 1b&, Nbp PHp ^ #PP#!1H1bb Nww, pPp&number ^ cdH .table&&   dNwN0cWb, &PPPc!char#number& &, cb&number&, cp1p1b&string.sub, ! ^#&dHd#& wPb&number + wb number, char, number ^ Hd&#bXbc &, !Nbpcb#char#1 ^ # ^&bdH&char ^ char, pZ, number#wHPwP, !, # dcd&, ca&pN, c1wpb!db ^ char&#& &pointer#wP, NNdN, N1cb#string.sub#wcOd * bHwcw ^  wN ^ 1RDocbP&char, ! ^!number ^ Hwp, cNP ^ bPpPb!1!, &&& ^ 1b#number#, 1pNpNb#string.sub ^ ! ##pointer!dc&&wpb#BwwN, ^number ^ char ^ number HH&char wbb #, #NP1Nb&Dd#result#number&number& ^buffer#buffer wN, cNcpNP, number, !cc &&dc ^ number ^ 1b#9#string.sub!1prPc, #wHdcb # ^!wp number {, pwbdFb!PHd&1dcbcd number >dN! (1PP!1#bP  %  dpH&&pdPbPbPNwb, + !!char#HPH#count&? ^!dLgdNPp#number! =number! ^Hicy string.sub&Hd#dHNpNbp, PwN!#cHHcHHNwp #, bb!1 (1dP ^ !bbP&string.sub&   buffer#, char, cC JNPdP ! ##dNdc  pointer table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ versan ^ pdP#number, string.sub;table!table#pointer# 1 ^ ^wN, #number ^ 1!1#char#!1&number&Nd#  ^ number#number!Ncp number, !HP ^ &number!#H1d1wb ^ NGwN PPP&1 ^ # ^&bdH#pointer ^ char, string.sub =, number#wHP#cdpdHb#1H&&table&HtpabN, 1wI!!number! ^table ^ &&buffer#buffer# ^^ ^1NbN ^ 1 ^ number&#1##table ^ HNbN ^ number, Ab ^ P1db char !#&number&cd dNdp, cJNp, string.sub, !!1 PPcb# bPd&, obb ^ , 1, string.sub ^ !pointer##dedc&& ^&, table * number ^ !1NcJcbpwH&pointer!bbb &buffer, qw ^ wLcpH!bb!dedd ^ ^bdPqdV string.sub 1#!number!char# #number * pointer  ^ number#NcNcp 1, char, ! &pointer&&pointer, dbwb ^ NNHw object#string.sub#!#cc&string.sub&, bHb ^ bN / NNwb PbNP#1H!char! Hw + char, bPpwbHP !dbp&table&& &bcw 1  %  & PtP&!&#cd1db &pointer ^, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer string .concat * pHPcP ^ Nw#bHcdc * number ^, ^ cw 1Pbccc!NH table, dc&&wpb#DwwN, ^number ^ char ^ number HH&char wbb #, #number!pp, PP, !number#dPbd#buffer! ^pdP Nwpd, buffer!##!&string.sub& ^ !HCwd, wN#number ^ object&number&!!HbH cb * number ^ #wN, cN!wxPpNH!dcb&number 1bb& / wb ^ &wp, PNPNP!wH, char! cbH&Hbqwp, #1!string!#temp#dH ^ db#number ^ 1w! !Np, number { Aw#HHp&char number#bwpw1sbS, 1&1 ^ cb!#table#&1bNbN ^ #buffer ^ number!number#1#Pb#string.sub#NH## bPd&, Kbb ^ , 1, string.sub ^ !pointer##dkdc&& ^&, !NbN wbP cwpwHd#HH:table!, {, dh ^ pb, Pch!, HHPb number&cdo #buffer!wH, !, bc!##1w& ^ LHSd#Id ^, NwwwcH!string.sub#char&Pcb wdcwbw, number&number ^ NNcPb, HHH&pointer& cw1wb, &number ^ 1Hb&!tbccN&1H&bd 1, number string.sub!string.sub ^ pb!number! ^table ^ &&bHb# ^^ ^NNd number!number&1ccc&cHbbnb ^, !, number, pbcpc ! ^table ^ #1 * 1 ^ string.sub ^ wb Np, &1#Pb! ^#number&pointer& bpb&dd, pointer ^ !1P_!cbbNP ^ cwd ^ &number#number#buffer& ^, 1dN, !!1&cc#char * cdbwVw ^ number!number 6, Pb#string.sub# table ^ pointer ^ &1 ^ 1, string.sub, ww string.sub PH!char! ^1wdTH#bc ^ number , pHp&cJc#1HHH!Pbp&Pwd, ^ wbb number##char#cc#! ^bHd ^, Pb#wb * 1P1bN!number# dPd&& ^^ ^, buffer / table -- BUFFER*OP ^ dbccP!GbpH ^ ddb#buffer, pointer / NpwpxbpbPNHocT * dbP ^ #, ! wN ^ 1 + 0 .write ) string.sub!Hdc, &number!number ^ Hwp, cNP ^ bbHc##WbP&!# ^table#dbdw ^ number ^ wwPbwc, string.sub!Hc&table!HbP, pb# ^number ^ !number} Pdc ^ #bPPddd * buffer ^ RN .cN NN!char# ^cN&pointer#, buffer!&& char ^ cNc {1P / number ^ #!# !, db ^ string.sub ^ number ^} ^, 11bcpcwP &!&# #bbw ^, NJ#number 1 number##char#cH HN, buffer, pointer, &number ^ 1!number !pbccN#number number&, ^bw&NpN#_ PH!number##table&pointer&table, buffer, ww, dw#string.sub#PP!number!&1ddMdNbNb ^, #, NNg#char #1P#&table#char bH, pointer buffer type, &1!Pb!buffer#number!cdcbP ^ Kdp, ^Ndb#1, NS!, Hpcpdw&  number, bJpdbPP#!!pw&number&char cbNw number, 7cN&1&Pc#1#1H&#, ^buffer&, table, #number 1PN&!Y1bP, !, pointer, & ^^dw#number (NcD&number&!!HbH cbbpb1wbw, number&number ^ 1bP#!##1dNdN #pointer ^ number, #string.sub!pcN&char&#HHPc! number ^ 8 ^ bdwe&pHbP =!!NHgHbcw & ^HwP !NNpwP c1pPHb&!!!bH, 3bcb, wb = 1M (!pointer#PH#pointer!!wbdw&tpb!pdd, NdbpPT!string.sub#!#! ^element, number HN#pd, dpNb, Pw# < number#wwH, pEcpPwbcpcb#1#, pointer&pointer ^ bb & % pA1pbp, char ^ char ^ #1c# string.sub * 1 ^ 1 ^, ewK ^ pbN#cP#dHb&char char& ^, dk!, 11wb, char, ! &char&&pointer, dcwww, string .format, number number&number&char, #1&number& buffer, pointer, & =, pcN&char!#bHc&# #& ^^ ^, bjH, cbccp!, ##PHdwd, buffer, ^ ic_&number, Nccwc, #, table  & &buffer, wbjwt, string.sub, 1 !pointer!&#, &cH&buffer&wH, Pb!pNPgPbNw#&&! 1  Hbw, wbw1dNHp ^ 1#cP!&!table ^ string.sub ^ bw, tw ^ !1cPHNHb, cb! ^bwdbwH pNbp!1&cHp  %  #buffer&  number#HwqbNbww#, pNppHpHHpdb!db& ^bdb ^ 1, : <!!pb##bP! 0 * db ^ wb PN!string.sub, 1&number ^ !wbH&pointer#byte ^ buffer, bHN&, Pc#pv##Pb&char#table ^ PdP, table ^ 5bP, bcNb#HpH1dbd, ^ ^ ^, 1w&pd11cbc, table ^ table ^ db&#wnbc >buffer ^ number char number&table!&1 bbN char, bwbpNp ^ char#char number, table ^ # ^buffer!buffer#number#, 1pNpNb#string.sub #!##&number#1H, ^Nb#6b, N1bb ^ !number! !number& ^pointer * buffer ^ 5!6cN count, cHb ^ HPc##1&1 ^ 1bN, number ( 1Pb&string.sub ^ #dc !PHc ^ # ^number, clwN ^ wwc!1Hb ^ char#cb ! ^#&number, ^Nrw?PHpd1PbHdpdb, ^wd!3cNHwHNpb?#bP;dd Pb#number!dwm ^ pO, lcHb&number, cwcwbH ^ pwcuPbbbPNcN 1!cc&char pb, ^ (dH + number )^bp&:buffer!1bcc ^ & ^ bbH&pointer, cNpp, 1# )table!##dPd string.sub&Pd& string.sub Hpppbb, cwp!Hw&# Hbb ^ char, wbhN, 1p / string.sub!dPdcHcdbPbwwN = ObHp NNc, char table, table&# ^ dwVw&, number ANPN!versan!bc&&1H# ^char ^ number, 1 , 1Pbcp!number#&&pcbb! ^pointer, 1, &wcpcPpc, !#1HH ^ HNb, buffer * number ^, &number ^ string.sub ^ PbcHpdHcdP } Hp ^ ^, dN#number YP, !pbp&pointer#buffer&number& dyQdNPp#number!Mw! ^HncJ * table ^ dd, char ^ number ^ PbwPHc #dPpdd * 1 ^ number ^ NNd ^ bb PwNwH!!table#number#!w_wd, ^NbwPcbp ^ #&char#&number * dbb ^ char, char ^  number 1dP!1b#char!Nd&table ^ wdS!NNpd, Pcw#pH &number# ^ ^ ^pointer, # ^tb, number&!cP1HbdpdwHL ^, HNcN ^ wwc&1##char!NdNb?bb&number, &NHpP, !cwb, Hdc&#char#pointer ^ char, PBn ^ pb!number !pbccN#number number&, ^bw&NpN#0 .read cpb&##Hbd ^  number ^ PdbNiw&pbmjcwc, table!table ^ !number number&pointer, Hbdpk, cNNpp#number# ^pointer pointer * table ^ db &yb, &PbNb!dPNc !zbNd& string.sub ^ 1NP1bPbNG! char&&number#PbP&PwwB, ^ 1#number, !1b&cc#cb_bNwNw, wcpHp, ccc ^ cN&number _ bd&, string.sub ^ #Nw, N_ ^ string.sub ^ ! ^char &Hdcbw ^ 1b#Kw, c11b, !&! ^&!&# wbc  .PGcpb1bNP!PPg&number#Lb!&  #bHNH, Na#!pP#Hw!number# ^& ^^ ^buffer QHNc1wP1b##number!cdbd, ^ ^ ^0! } #pwbcp #number#char&bdbHP&, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer Np, &1#Pb! ^#number!cdb&1 ^ buffer ^ ^, ^math .max&1#1#number ^ PNHbH ^  PH&dcw# ^^number&:#cpcb#dHN## 1bNwNw ^ NbN 1Npc!pHH&Nd1bbd&number&sHNPhNcNP ^ ! ^#&pointer#pointer# ^ 1, buffer, ^number ^ string.sub&cbc#! ^!number&wbPb ^ ^ , wcpcPPczb ^ # ^&pointer #, &count number#pbcNcN!#char ^ pointer!pointer#buffer# ^1, ^XNN# } number !pointer#!PHd1bg ^ ^wc !NbN ^ 1 ^ number&#1##table ^ Hbbbb ^ number ^, &string.sub#string.sub#1 ^ pN#buffer# ^& ^pointer& ^table ^ #number ^ wNpNPZPbNw#&&HdP#! ^Nwwa N1wPPbc!string.sub!HH!number#&&!pointer#ddNPNwbNclNH##Hdcd * bdPd ^ bd ^ table ^ wPHcp!cHPPbd  wHw, QNHw ^, #Nbp pH&string.sub&bd, bw&!, wG#pH1bPc!wbVH, dp#string.sub ^ number dbcwp, string.sub, !!flag!pointer# ^&buffer!Pb! ^, number&, ^NwwHPdpl#pc &buffer  ^number&table, PwNwd, bNdNb#!&#cw ^ ^WdW, bwH 2&fw#HHp&char number#buffer ^  ww*wNd  %  #number ^ string.sub#pb&!dW * 1 ^ string.sub&pointer, bwbpNp ^ char#char HPHcdb 1&PwPbCNw, :number!number 1#PH&#db ^ number ^ number 1b&pP )&cDp1b, char, &, table ^ bd ^ #rLSc, &1&char!#1# Pb string.sub * 1 ^ 1 ^, positan&string ^ p1b#char#!1&number&Nd#& ^number!number#byte#NbPpPNc#number &number#&bT&1d, buffer, ? ^1dP##0 .write#char!&pointer&bH ^ Pd!7NNwb PbNP#1H!char!#, pointer: ^wdwNHppbccPNb#number!cdbd, ^ ^ ^^NNP PHP&!&#cd1db &pointer ^, table, &string.sub *, cNNcbP&Hd#1 number, number!number ^ wbpPp ^ number ^ char&HHH#& ^&number ^ pointer, % ! ^&, cNcccPbHCH ^  !  pointer, number, Xbp&1NAp!number#PcN! Hbbb&bg!NMpbPpTd#string.sub# &bd# &wpdP9bN!number!Pp1xb * 1wdH pbcwPdbNpN111b, !&! ^Hb&# #bb, number, number * #, ^1 number##!#char!&pointer!bb ^ cw#state#number ^ string.sub ^ PbcHPc&handle&number * number ^number#number } number, #number !1b#table:!cdb#, &, number&string.sub!1bcb!Nccdc * number ^ ; ^, number wpHbbccc number#table#dPbNb&&dG <INpNp ^ char#char #number!#  ^1d#, state ^ cNbw
-- PHASE_BOUNDARY:INIT                 .sub!number# ^table#&  bH!ww * wN ^ wdb, number!char, Ppdc!wbp&pointer, wb!Nb, pP&Nw!, Pd&#Hc ^  ^number, number, ^string.sub#string.sub PNb##HHNdNd ^ ^ ^, NwcpwNbcdp ^ number&!&pointer&&# ^PwNgd_, IbPwP, !, # dcd&, ^1, 1 string.sub ^ string.sub ^ P1b&##Hb string.sub * Ndcww ^ 1Ndw ^ handle&string.sub&!&char#&PdNbdb, bbXw;, string.sub, 1 !char!&#, #char !, ^, number number&number&string.sub, pb!bcN&table! table#pointer#number# ^cNpN, PHP ^ PNHbH ^ pointer ^  &wbw#, ^, 11Pb ^ char ^ !&&#&#pointer ^ dNwdb, number!number&xcpc!ccb&goto& ^buffer!buffer, Qbw ^ string.sub 1#!number!cc&pointer&table# ^versan ^ number, number, ^string.sub string.sub PNbcHyHNdw# ^&& ^ ^NN number!number##number#char!  & char ^ cwNNv {, pcN&!pP#Hw!number# ^& ^^ ^buffer _HNc1wP1b##number!char!wH, wNwH NHp#, HcdPpP#!number!!buffer {wNdHd#NdwdPbbPP&cccHbpbb ^ wb!pcbHuH!dc / !##number#!wawd, ^NbwPPbc!string.sub!HH MHc&string.sub&number, number;HN*1d  %  string.sub!pP table, &cb&bb #, #NP1Nb&Ad#dcb&#& ^ #buffer , Nwpd, bc##number&number&&!db& ^bdb ^ !, PbdtP!number#HH dd#string.sub ^ dwbvPs, pNPdJb! #wPw buffer&Hdcd!NGNdp ^ PbNP#!char ^ !1#number& ^^dE -accumulator&number 1 pN!NHdHb#&bP&string.sub, dbpN!number Nb!1#pHw&& string.sub#bw!, dNbN& {cPc!string.sub#, table#cH ddNd#bpwNpNPWPbNw#&&HdP#! ^NwwM N1wPPbc!string.sub!HH#versan#table#wwH, pRcpPwbP cwb char!#!table ^ ^string.sub&bZ!NQpbPpLd!!Hc&number!string.sub ^pointer * cbd ^ buffer, NbNp!bH ^ cP 1b!&!, table ^ wwdwwcH!string.sub#char&Pcb * Ndcw ^ buffer, 6b1pb * number ^ ! ^cb&1 string.sub wd ^&pc;1Pt!!!, HNdNH#buffer#number!, string.sub ^, number, 1bc&!NbpH## (bbdcwcXPN + wpb )^cd###, cf number&& ^#bb ppw_jc #dH!cH ddNw! ^ ^bb#char!!pbP&table# ^bP&# 1 ^ 1N1VNbwP #number#&! ^ pointer& ^ wcL, N1b&mwc, number Hc!pbkbNwww, ^ pI, bcdpbHHc##1HP ^ 1 ^, string .concat ^ array ^ number, * cN !wc & #char ^ pdb ^bpN string NPbc#!&cdw#pb ^ count! ^!string.sub!, !char?#NbH&NHN ^ # ^#ppp1PbcNP#table ^ &Nd 1, 1NpNwX number !HHcH ^ cw ^ ^.dIb#wc, #NPp #21ddPdwbNwadH0Pp1bbgt!PP&char!!buffer#pointer&bd SBdp, pcN!PbPc #&table ^ wd, ePbwbHPpcc#P1bdpd1bbb , ^Nbp#number#cbHNHN&#table ^ ^ ^, K11pbNP#1 #table&wd# & ^& , NwpdN#!string.sub!1HbH, & ^ ^1w#positan#NbPNPNc#number ^ table &#buffer!bc &, !Nbpcb#char#1 ^ # ^&bdH&char ^ char, string.sub}, number#wHPwP, !, # dcd&, ^1, 1 string.sub ^ string.sub ^ P1b&##Hb string.sub Ndcwc / PNEwpb ^ cb!Hbd&char pb, ^ dHT#NdwdPb1Pb ^ char ! !number ^ Hwp, cNP ^ bb PwNwPc!1#char ^ Pd&ww Hpppbb, cwp!HpdN pointer#number ^ &buffer#DcNNb * 1, pP#1#, pointer ^ pointer ^ bdw  pNHN&1&number#1 ^ HP&cdw&1 ^ 1, string.sub, ww string.sub PH!char! ^1wdc &bb ^ #, HbppP, dPdbcHSHNdNd ^ ^ ^, number?cpcbNc, char, #char!  number * char ^ cwNNR_, pcN&!pP#Hw!number# ^& ^^ ^buffer fHNc1wP1b##number!cdbd, ^ ^ ^?! + #pwbcN!!!Ppd >#pbH& ^ &bdN&pcc1c1bcP pointer!table ^pdcbNwNpN >, Pbc&HpH## bpd&number#, 1N ^ pNNcc!PbHbH ^ pointer ^  &number#number#, ^, N1bb ^ !Pb&cc&#table ^ bb #Ip41pdbNp#!!#number&number& ^bbb * wN ^ cNwJbPdN ^ 1&char&&&table#bP ^ number, pointer , 11wb, char, ! &char&&pointer, dc, &NNwcpwNbcdp ^ number&!&pointer&&# ^PwNfdd, % 1PwP, !, # dcd&, ^1, 1 string.sub ^ string.sub ^ P1b&##Hb string.sub * Ndcww ^ 1Ndw ^ versan&string.sub&!&char#&PdNbdb, b1cwZ, string.sub, 1 !char!&#, &1 * 1, number ^ number ^ Zb, &1#Pb#string.sub#number!cdw&1 ^ dd ^ buffer&number&string.sub&number#cP!NHdH, Hbbwb, number pcp&1, cb#1#, pointer ^ pointer ^ bb &, #Q11pbNpc!cHP&function!string.sub ^ ^pointer, # ^SbpP cc!&HdcP * XHb ^ wb#RHp#number;nP!!number ^ char!!HH!HHwp = 1bdp&1b6b1bc!!  5#dwPwwVNp?wHP#cdpdHb PH&table, dddwNHppbccPNbHPH ^ dw &buffer, number !NcpH, HcdHpc#!number!! ^= ^dw ^ jb ^ P1db char !#&number&cd, ^, number number&number&string.sub, pc!number!, table, & bdb& ^, ^1NbfNPHN 1#char#&#Hcbpb table, ^, NpwcPc ^ !, table, #char * char ^ Pw?buffer ^ ;number, 1&Pc!, #1&buffer& ^ wb db, buffer ^ Hb!yHcH1bP, !id, number&number&buffer wNbbpN!Hb char### #dcwpw, NHN ^ NN!number#yHb&# list#dwP, HNNN#J1Pb!5# ^Hcc! buffer ^ ^^number&NbN#string.sub ^ PN!number! ^& &  Nd#, x, NNNN ^ PbP !Ncc&wHbbd& ^ & ^&number&temp#PPcN#pointer#, #1 * 1 ^ string.sub ^ number Jq * pHPcP ^ Nw# ^& (!IH&dH, vPbwbHPpcc#Pbb& dw#wwIbH ^ number ^ ! (number + Pdc )^ bPPd  %, ^table&buffer, Pwc, number )^number!1!PHPbd!buffer#Hww ^ yV ^ ;, &NHcwpH&string.sub&bd, bw&!, buffer, ^number ^ string.sub&cbc#! ^HNdNd ^ ^ ^, Nw#pcbN!6c, cb&; !, ^number, number ^ #number#1!Ppp, #pointer# & pointer# ^number ^ cw * wNbcP ^ pN!dP, &!!&Hcdcwc ^ 1N_N ^ number!number 1, #bdpd  ^ ^^bb {1pppwN char #table&char& ^!number ^ number ^ char, char} Np string.sub, Pcc&#&Hc 1 * 1b& ^table&1Hb#string.sub ! Hd&!!Hbbw -, ^ic ^ !1pN, char ^ !&&1&#table bw &?py1pbp, char ^ char ^ #1!# string.sub * 1 ^ Pd, buffer * global ^ 0bPPp ^ #table#&&dd#& ^^ww#key#NbPpPNc#number &number#&buffer  %  &1d, buffer, user ^1dP## % #char!&pointer&bH ^ Pd!ENpnpb, wc&#HHPc! number ^ _ ^ bdwk&pHbPk!!NHaHbcw & ^HwP !NNb }  number!&HH&number!!bN ^ number, Gb ^ P1bP!number!#table!string#cHb&char&dXPLwpNP >.table!##dPddb&pd& &bwbwbHPpcc#Pbb& dw#wdd * number ^ buffer, 11Hcp!buffer#!table&dH#7b, wp * string.sub ^ number, #Npp#!bb!dDdd ^ ^bdP + 1N!number!PHpwPccP!pointer!pointer ^ number ^ number, NN } ^Hb#PdNd#buffer!number#pH!HH, string.sub, bu, pw, !cc!HbH!number#pointer&#pointer ^, string.sub bp!1EPb!ppdHbdcd, b1wPdwNb, #1cPN! !, !1ddbbb ^ wNjpbbp!Nccwc, table&table ^  pb ^cw&ad ^ PbwN ^ !!!#&number!1H_bN char, &tbwPP!string.sub!pwb ^ &wdH  ^ddpeNNPwbbwpw#!##dN#1H, ^number 1NPNwbNc } NH#buffer!number&, pointer ^ ^ buffer ^ versan ^ pdP#number, string.sub
-- PHASE_BOUNDARY:INIT                     table!table# NHbdNwN ^ #NP / NPN!key!bbw&& ! ^1 ^, cGHwgbpp;!pointer! &char!#Hbbcd#sHNppcPPmb#scc&1&, buffer ^ buffer ^ bNQNNwb PbNP#pointer# dc##&char ^ cb BH, cbccP!5bpH ^ ddb#buffer, dh, bN 1P, HcdPNPdcb#buffer#buffer ^ !, # wN ^ 1 * sJ!pPHcccHbpbb ^ wb!pc1HdHp, cs!#db#!whwd, ^NbwPPbc!string.sub!HH# % HcH pointer#ddNPNwbNctNH#number&1db#ubH &bc ^  wdx&pNpT#pointer& !pbN ^ PdPb wbbp, buffer!!# -Hbdp!pointer ^ ; ^number, number, ^string.sub#string.sub PNb##HHNdNd ^ ^ ^, NwcpwNbcdp ^ number&!&pointer&&# ^PwNfdy, 5bP;!!!, HNdNH#buffer#number!, string.sub ^, pdp number char#HNHc& pointer, buffer, ^ 6&9&number, Nccbc, HwH ^ HNbdd buffer&wc8cPc1b#0# ^pointer!pointer &, ^ (bcp + number )^1 ^ pb!1HpHw#   ^table, char, ^bw1Pbccc!NH table, dc & ^&wcN1Nbp&number, char ^ !&&table&#table ^number &5g ^ 1w, object, number, 1 ^ #dH# > cd&number&SHNPw!PNcw# HbcP * pointer  ^ number#NNNcp pN!string.sub! table &#bcbc ^  buffer, NH, ^PPN#11cb&1HN wb, number, &number ^ string.sub ^ PbcHpdHcdp, buffer#&table, #Fd ^ pointer?cppb&#wPH string.sub bb, ww !NcpH, HcdPpc#!number!! ^accumulator ^ dw ^ 4b ^ Pb = number, !HpbHP#cHi&Pd!bc ^ buffer ^ bb!char#Nw# ^&bit3c! >table wd, ?PbwbHPpcc#P1bdpd1bbb , ^Nb )&Pdcb#1#, pointer ^ pointer ^ bb #, PNdp11cccb # &dd!&1 ^ number ^ , = 1cb&number, !1HbH, ^ ^ ^1b&_#N1PpPNbc#number!1dd# ^&& &, &number#pPbNcdc, cb&8 !, ^number, number ^ #number#1!Ppp, !, Hbd& NHpwHw&user&Ncb, Pbc&! ^table ^ &&buffer#buffer# ^^ ^1NNN ^ PbP 1, HH! ^ PH#d1b1Sb, Npwb !number!&char ^ & ^ bbH&pointer, cNpp, 1#mH!##dPddb ^ Pd& number Hpppbb, cwp!HpdN pointer#number ^ !buffer# ^PwH, HN&string.sub ^ pwHHd&# + buffer, wp * string.sub ^ buffer, bPBgd#number#number&number temp#table ^ number ^ , 0 .write 1cb&number, !1HbH, ^ ^ ^1b&array#N1PpPNbc#number!1dd# ^&& &, &number#pPbNcdc, cb&string !, ^number, number ^ #number#1!Ppp, #pointer# & pointer# ^number ^ cw wNppp number char#HcHc& table, ^table ^zP ^ #, 1N1cbPN#wH  number &pointer ^ wdNFN&string.sub number 1N#number& &bH&buffer&number!Jb - ^bPpPb!1!, &&& ^ 1d&wd, 1NbN, number ^ number ^ !1c#dKHcbb&, ^ number 0 .read&number!cb#bHN#char * char ^ Pw <  pi ^ pbbHad!cHP&result!string.sub ^ ^bwH dNcbPPJNp! ^Hdd#pointer, HQwp, ucN&1dWP!!1bHw## table ^ #, 3 PN *, ^?!NH1HbH&string.sub 1#pointer ^ &wb bwPl!number cdpd&number&number * number ^ global&table, #rd ^ doNpP!pbp&bd! & ^Hdk;!global#string.sub#1bc ^ !number##table pointer  #wcwc Np, 1 !pointer!&char ^ pointer!table ^pdcbNwNpNv, Pbc&HpH##   ^table, char, ^bwp ^ PaN ^ 1&cH!, dw#wwH, phcpPwbPH!#HzPPdbH ^ &Hd ^  ww {, char, PPw!, 1!&cdH#table&, jp ^ #number!number!cTcd! ^HbcP !& ^^ number#NNNcl&Pbb#HQHNdNd ^ ^ ^, Nwcb (1NcHp ^ number&table HNbpd, !, #NwpcN cb!cHc&NbQ, ^cb&Np, #1wNNp ^ number ^ table ^ # Hbcww, 1w#pPPdcb!cHc! pointer * bd ^ !bb -pointer, Np, 1 !char!&&string.sub&1 dbN #OCxNpHp, Nl! -1b&pointer!bbp&# 1bPNbN, number ^ number ^ string.sub, PcdMHcbb&, ^ number 0 .read&number!cb#bHN#char * string.sub ^ HwN, 1Nb, &1&cH!PcN&Ndwb ^1dP <!number ^ string.sub 1#!number!cHwH, ! ^ 1, buffer, ^pPp SbcbbH&!!table number&1d, byi, number number&number&string.sub PN&bHNbH& # ^#number#scPpP, #table# ^#number * number ^ char ^ bdwm&pHbP * !!number#number& db#number ^ 1w! !Np * 4rbjw#HHp&char number#buffer ^ ww wwca!number!number!table .Hd& ^ bHPwb, cN!pN1bcbNw# ^&goto!type bdH table Hpppbb, cwp!HH!, pointer ^ &wbw# ^ Nwu&cpcb#1#, pointer ^ pointer ^ bb #ipGbpd number * char ^ cb&number# ^bHb&, positan, #number ^ pwb#char#!1&string.sub&Nd#& wPb&N5wb number, char, number ^ Hd&#bZbc &, !Nbpcb#char#1 ^ # ^&bdH&cwfdwaNv ^ 1#1 pa!, # pointer&pointer&table 1r1Nppwb&cpNbH!&pointer 1 &dcwczpN, string.sub#, HcdPN#, table char &pointer ^, 6 ^ pPpcPccN#, #, &cH& ^number ^ char, buffer ^ Nw ^ string.sub, pc!!number, &pointer& bpb&, -4j&string.sub&1c!number!1#&! ^ !& wp * char ^ number, NbNN, cb!&&string.sub&#table buffer wd, !bHpbPTc ^ !cb!&cdH#table&, b_dX ^ ubdPPc##!1wd!pointer, ^9 ^ number ^ number! ^Hb#PdNdPP!Pdp#string.sub ^ bw!, &NHw .number!NP!##1& ^dNH! ^cwNX, type NN&!pP#Hw!number# ^& ^^ ^buffer xHNc1wP1b##number&ddb * char ^ char, Ndp!NbcdPN#, table char &wpwbFdNN, pPpNw#bPwdP#&&cd!, cyNp, string.sub, NNp#Hp!#dwHN& ^ ^, ^number pHbccw!1c#pointer# ! ^string.sub ^ ^, !bkpdbwc#char ^ number&table&pointer!bbb &bCp ^ 7pbp, char&char ^ Pp&number& ^buffer buffer * pointer ^ ^cNw} 1PdN ^ 1&char&&&table#bP ^ number, pointer , 111cpcwbkH dd !HHw1yprww3b cd!!1H&1 string.sub number&hw * LHpcp ^, wc ^ #QPh!bHP&number char, dbPpwbHP !dbp&NdP#number ^ !, number ^ 1wp, &, table!string.sub!buffer#, &number!!bpwN, pointer wNdg#NPp, 1Hc&!pointer!wbHw& accumulator (, pp, pcP#bcN!function#table#!wIwd, ^NbwPP!char, !&# ^&number!Hbddf, ( ^ ppc&number#cb# ^HN#char !dbwbw ^ 0 ^ number&number#number#char ^ cN&buffer& ^bP&& char, #number ^ pbN#!string.sub!1Hd&NH#buffer! ^number, number, ^pbp PNbc#number!1dd# ^&& &, &number#pPbNcdc, cb&number!buffer, buffer, char, & ^wp ^ 1&!#!#number&#number pointer&, number! & ^char, c1cpb! * ! ^&!& table, ^  ^, state#1Nbccwc, table!table ^ !number number&pointer, HbdpG, cNNpp#number# ^pointer pointer * table ^ db, wwbpd, ^number&1&#&!#dP * number ^ pointer ^, ^1Nd >Nb, number #char#&! ^dw& wPwcGcNNb, 1, ccP&&number&char buffer&Nd ^ number, wcpPh, cdc HpH&#, wb&number&, cpPp1b&string.sub ^ #!char dp#char&number number, number ^, Nbp&cpc#number &!!number #bbw ^, number ^ !pcbNc, char, PN!& string.sub&# ^number * Nb ^ number ^ string.sub ^ number cH!cHw&1H#bw char, 1 string.sub&string.sub ^ char!char##wHc!! !&string.sub, 6bpNHw ^ list&Nd!&#cd1dbHc&, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer Np, &1#Pb! ^#number!cd!&1 ^ buffer ^ ^, ^ } &1#1#number ^ PNHbH ^  PH&dcw# ^^NbC#cpcb#dHN## !bNwNw ^ NbN 1Npc!pHH&Nd1bbd&number&XHNPeNPq!NpH&_&& number ^ cwH, dbpN ^ 1bPHbc#string.sub&HdN * 1 ^ 1 &, &NHpPNNcN!wH &1!number * number ^, pointer!VwN#1bcb!!#HP } &  db! 1, 1NpNw, lP !HHcH ^ cwbPbcwc, NN number, 1cp #number#char&cdNb, buffer, wcbbN&pccPcbP#table#pointer! pHP ^ wid ^ bb#cP#number#&Pdd& bHbww ^ !wc, !, pointer!number!wHNd - !Hb# ^ddd ^ #wdVdN, !Ppw&Hdp * char ^ number&buffer, 2w ^ number: NwbwHpPb !buffer <^1, string.sub dNb1cb, cb#Pbw&&table#bc ^ number , pPb ^ number#char #bP!pointer #number ^ !, char ^ p1gbNcNc, P_&number& #, & ^, NPPbN#HP & #&&1&table, dNbN ^ 1NcpNbHz!char!wH, ^3w, hHbbp#Ncc1bSHrcQddb &string.sub, ! ^ pp, cNNbN#buffer# ^& ^pointer dNw&number NPN&for ^ number ^ !buffer#table!cdcbp ^, number# HNwN, 1, number #char#&table, #GH#pointer, number, ywNdwbP#!PHNH&cd &bb&bb& ^&, dNNc!pzHd&Pd#buffer!Hwwde&ppw!Ppp, 1&char#!THp&#&!, :NN ^ Hb#PdNd#buffer!string.sub#1HHHH, string.sub, bZ, pw, !cH#number# table } #pointer ^ buffer * phPw ^ pwP ^ !!pdH!#1#bHwdddw + Hp&, vP, !pbpHw#pointer&number&dd_?dNPp#number!ow#tc#&cdNb buffer table, &pmp#9HcHbP&string.sub!number dH, pointer  bm number#PcPcp#1 ^ &table# ^bP&# 1 ^ 1N1kNbwP #number#&! ^pointer ^ bdw#number, buffer .number, 1p <, string.sub PdHdcdbPbwwNg;bHpPPbcbp } #table!&#!HH&pointer  buffer, ^CpdP Np#NHPcP# &buffer ^ bdbN!pj1bcpNdHyPwdNd ^ ^ ^ bok, number number&number&string.sub cb& + !, ^number, number ^ #number#1!Ppp, #!char ^ & pointer# ^number ^ cb&Db, #P_PN!number! ^& &  Ndc, key, NNHw ^ 0 .write&number PNHp!  ! # ^wwc ^  NbpcPccNHE#, &cH& ^string.sub #, number ^ Nw ^ > ^number ^ 1 #HHcdw 1d#wPxdNbpcPcp ! Hd&!H1bbwA, ^nc ^ !1bjdc ^ !&&1&##bb ^ Qc .cw#buffer, number, !number#dPbd#buffer! ^pdP Nwpd, bcP#dHb&char char& ^ ; do!, 11wb, char, ! &char&&pointer, dcw!number, table .insert, number number&number&char, cb&6 !, ^number, number ^ #number#1!Ppp, !, Hbd& NHpwP, ^for#number 1bY!!Hbw&positan#& pointer ^ &, string.sub !Np FHNdb!1d&number char#buffer ^  ww wNdt!number ^ string.sub!pb&!di * 1 ^ string.sub&pointer, bwbpNp ^ char#char HPHcdb 1&PwPb * Nw, EP!number 1#PH&#db ^ number ^ number 1b&pPF&cjp1b, char, &, table ^ bd ^ #uEzc, &1&char!#1# Pbd  number&  # ^!number!number!cicd! ^HbcP  % buffer, wHdbmP, cApNPp!number#char cb ! ^#&number, ^NgwrA#pH!HbHdpdb, ^wd!Gb ^ dp ^ 1&!1!#Pb& pointer# ^char ^ char # ^, NbPpP * char ^ # ^!1dbbpbw  Spw&string.sub#1bc ^ !Ncc&HHbbbb ^ number ^, &string.sub#string.sub#1 ^ 1N#buffer# ^dP#&&char ^ #buffer ^ + number, #PpPb!pointer#number!#dH * number ^ number ^ ^obd * pNNccwPbHdc ^ #&&& ^&buffer#RPNN1db, 1b#0&!&, number ^ number #, #number!pp;, number, !bH&&number!pbH&!number&, cN, pbIHc#!1&number&number#1& ^, pointer;! ^H11cpcwbCH dd !HHw1_pgwwFb cd!!1H&1 * Mb ^ ^cd!XcNHwHNcpPPHc ^ dp!buffer ^ !we, 1Np ^ dbbccc, #1&PcwbA&!number! ^NNpbNPdFw!bc#!count#pHw&pwb =^ ^P1bP!number!#number! % !table!number ^ Hwp, cNP ^ bb PwNw#buffer!table# ^table!Hb, !IyN1bp, dc!#cHwcpdd& pointer# ^bbw , Mpcb# ^PPdb !table!dw ^ {Nj ^ wPHcp!cHPPbdw&char ^ 1 ^, positan&type ^ 2NPpp, #table#&&&dc ^ 1 ^ 1w& ^^pHp&cgpcPNHb#& Hdbwww, number!number ^ Nbcpc ^ # ^table& table #buffer ^ bNgdw, 1!6&pcPcHc#1 <  ^number!number ^, NbPpP * char ^ # ^!1dbbpbw  string! ^Pp#1bc ^ !NP!&cdNb, buffer, number ^ &number!1bPcc###char ^ & ^ bbH char, cNpp, 1# {table!dcNH, & bcb& ^, ww 1Pbccc!NH, table, dc&&wPwcMbwN, ^1, 1c#Pc, ddd ^string.sub ^ &buffer, .wN&1&Pc#number#1H&# ^buffer!pointer, pbcwNKNPNp, !buffer#&dpd#& ^, dV! ^H1bcu! ^#cP!dHH, buffer ^ ^} 1 <#1FbNcHc, PJ&window!bbd&buffer, pb#wb, PPbP, # ^# ^char, #char ^ element char, bb, number ? number 1&#!Hbdb * NdcwcRPN8wpb ^ cb!Hbd&char pb, ^ dHx#NdwdPbbPP&char&!table!number ^ Hwp, cNP ^ bPPP ^ !number#&table  number#! ^cwH Hwc, ccHp ^ #pbbd! 0bbwpddCbpcp, Pb!PpwH&## cbNw number, NPp ^ 1#number !bb!& !wb!pointer wcbpp?pNPNP, 1  %  HwH, pointer, table pointer#number&buffer wNbPpN!Hb table !&HbHHwd / 1i ^ pNPpGb#Tcccw#, bi ^ table bN#ycPbp (#TPY&pointer  Hpw!buffer NpwcXNpN!buffer! ^table ^ & &number ^ & ^ xPX&, ^1 ^ cb!Hcc&string.sub * HbN ^ 1, 1 ^ &number&1HPPbN#table&number& pointer, ^zone&pointer, cwbpNp ^ char#char HPHcdc 1&number, string.sub, 1Nbw, 9 * number ^ string.sub, &Nd ( bb#number <ddNPpHPNP#1b#1&6d ^  cH!wHgN } number, Py <pointer!ccb&number& ^buffer#buffer, number, cNcpb
-- PHASE_BOUNDARY:INIT                     number!string.sub!1Hbc, #  ^ NN {NbwwP&!table#PP!dNbFbb&number, &NHpP, !cN!wH &1!Pbb ^ !pointer! ^NwHh!number ! + pd&number&number * number ^ 0&table, #Bd ^ d1bppbNP!PH string.sub bb, ww !NcpH, HcdPvP, !string.sub!! ^state ^ dw ^ gb ^ Pb!number, char&! ^HwcH number&Dwpb fbp PPrH!dcNcd!bHdHbw!char#bwp ^ number (NqbHcH!, number#wwH, pEcpPwbP cwpw&window#HHpH!, 0, dv ^ pb, Pcb!!1!&Hbn&cdWdP {wNHp PdNp!wH ^ pointer!!dbp 1 * number ^ #wPyPNdNd#number&ccb  bw&wbHpH, ^Pp?buffer#!table  %  &1 string.sub#dwSwNZNe ^ 1#1 cNP#&  1H# ^handle char, bb, number { number 1&#!Hbdb*Ndcwp  %  HNNp1Pbp&!&HH&PHNbbb ^ number ^, &pbp#1 ^ cN#number# ^pointer pointer bN #, cKNb = string.sub, pb! .table!table, dNbNd#number#accumulator!Np 1, cb#&HNcp table & ^&wc:, Nbp&number, #1H char, dHH ^ ^Pd#b1w1pbNNPwc HPH&# ^ ^ ^bwH dNcbpP, char#pHHP#Nd, wcw& ^^pys cPcc#cHNd, pointer, bc &ZPicp!8NN ^ char, cc&!#, bdb wb, &number, 1_b&char&!char&number&1d&& ^number!buffer NpwcxNpN!NP, Hb&&bpb#, Ndp!, Hcb#?table ^ &char!!bc ^ HdHzd, py#window ^ string.sub#pb&!pointer; 1 ^ string.sub&pointer / pD pbb#number&#pbP&1d!#!& ^Dx ^ cNdwPPwcH! Hdcp table & ^&wc /, Nbp&1 ^ char ^ !&&#&#pointer ^ dbwbw ^ math ^ number&PHP#char ^ cN&pointer#, buffer!&& char ^ cNcvbP;number ^ #!# !, db ^ string.sub ^  number ^ count ^, 11bcpcwP Hb#& #bbw ^, NNdN 1bP&pd#dc! PH! ^! Nb ^ ^wp ^ 1&!#!#number&char, pointer&, number! & ^char, c1cpb!0! ^&!& table, ^, ww:dNcpw, table!string.sub#!table, &cHNbN ^ number, -1 ^ P1db char !#&number&cd, ^, number number&number&string.sub, pc!number!, table, & bdb& ^, ^1NbeNPHN 1#char#&#Hcbpb table, ^, NbNcocbpwH&dH PH!wNsx (buffer ^ wb&char!#1# Pbd  wHw &buffer ^ number ^ _bPHNp#bH!&& HHfwp, VcN&1dSP!!1bH&!Hb#&Pw&brNb, number!number#!##1& ^dN #pointer ^ ww, #number#pbcNcN!#char dPH& ^jdb, ^, number, 9 ^ Pdc#table = Hc#&bPbcwc, NN number, 1cp !buffer#char&cdNb, buffer, wc ^ &ppj#PwpNb ^ char ^ & ^table * bH ^ char, wgb, #1wpc!1!, &&& ^&Nb JHL&string.sub&1c!1!1#&! ^ table &wQ * char ^ NNbn&Pc1b#number#, pointer!pointer ^ db ^, number ^ table .insert ^ number&PHP#char ^ cN&pointer#, buffer!&& char ^ cNcybPZP ^ #!# !, dHH ^  number#NNNc, dP&ccH1Hb!cH ^ ^   ap ^ char, NNNcNb, #bH& string.sub #pointer, string.sub ^ &number#pbP ^ cN#, PbdNH&bbdX, number string.sub!string.sub ^ gwcwbd&table!dbn&char * NbpNNN ^ number number * string.sub ^ Pbc&db&& ^^ 1_dwN, gJ!HP&cp#1 * number ^ 1wb yJ, &1wNP!PbPHwd, #! ^number, Zd ^ &, cNc!zone!NHNH, Hc ^ 1b buffer, ^, NbNc + cbP&&string.sub## number&Nd ^ buffer ^ 4 ^, 1HPc!number#1!#dw&char ^ 1 ^, - &math ^ 1!1#cw!cc * dPdcbb ^ 1 number;Pw > 1wND!!1 char#!table table&Nd# -pw#pwMNN ^ 1 ^ # ^! dH * char ^ wwb ^ #ppp1PbP, #&# ^&1#PH  1, 1Nzp ^ 1cA!!HHNH &, baHdwb ^ NNbN ^ 1 ^ number&#1##table ^ Hb ^ Nb ^ number ^, &string.sub#string.sub#1 ^ 1N#dc, pointer!#&&char char, cwbpYp ^ char!char number, &pointer&   buffer#, number, cO INP, number ! ##dcdc  pointer table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ NHN&1&Pc!, #1H&#, bHb&number&, cp1p1b&string.sub ^ #!char dp#char&number number, number ^, Nbp&cpc#number &string.sub#& #bbw ^, NNdN PpP&1, HHH& object #&table, !, #Nw, 1 /, cN1bHw#1 * dH ^ pointer&buffer&window&, #1PPN!pointer!, !1dwd, buffer, ^:cj&number, 1bcwc, #, table  & &buffer, wc ^  pPpcPccNHx#, &cH& ^string.sub #, number ^ Nw ^ char ^ number ^ 1 #HHcdw 1d#number!versan#bwb!1, !number# Hwd * !Hbbwpww ^  number 1dP!NH#1&string.sub&number#Zb * wHgcn ^ ^wb ^ char;paHp!pointer#, table ^ d1dPjwNHp PdNp#NHPcP !&number * 1bN ^ number ^ HPpPbc, #wP!dpbN ^ pointer&number, Hw#, pQ NHb#PdPwdHb&&Jw, Fp ^ pbPNdp&P_Pgdd Pb#number!dwo ^ pQ, 4cP! table!PHdwd, buffer, ^ LcT&number, Pbc!!&HHc  %   number&&wB 1b, number, string.sub, Pb!&#NPpd!table buffer& ^cW1hb, #1#char!!pP, Hb string.sub * buffer ^ number ^ ^1N11pbwp #pH &cd&bd&number, & ^^number string.sub#cNccP&&Cd& 1b#wH pN!, PPPc!char#number&, &, cd&, number, cN Ns ^ number, PcHb!, pointer  wcw& ^, string.sub!string.sub&number&ccHPHb&&table ^ bd, %, & -string.sub NNcN#string .concat#buffer!&pointer&buffer!wbw  bN pw, number!string.sub#&&Pc! buffer ^ ^^number&NbN#string.sub ^ cd!number##&!cwbpd#wwbN ^ ^, ^1 ^ cd###, cf number&& ^#wbNNNN + cPc!number#_c ^ & ^ bbH&pointer, cNpp, 1#GH!dHbH ^ dNbpHbw! ^cNbN, number&number ^ PNHHdNd, wOdd: 1P#char, 1b#number&1db#7b  &bb ^ PwNb#Zd!PHcPbdwb# ^Nwc:! ^-string.sub number&cc!1Hb&NHcb!wc, wbpp! {NPp!1bH cb ! ^#&wODN&p1b#cHpp# ^! pointer& char ^ wwb ^ #Nwb#PNcc#!P_d&table&buffer# ^1, DN, cbbccc, #1&Pcwbpd#wc, number ^ wN, Nbc#!d1dd1Hb&&wpdH pppw > 5!PPdc, &buffer!number ^ Hwp, cNP ^ bPNPb!buffer#number!# 1 * number ^ pointer ^, ^1NbN, math .max * number ^ PbH ! ^pointer ^ bb ^ Hbc_cpPbWN ^ char ^ #bHH#char * char ^ Pwh string.sub / ^pbbH_d!cHp&, pointer##table ^ #wd dw!, !NHp, #PbwdH pbcwPdb * NwwwNdpbPw&pcbb! ^Rwbspbdp&1bZb!wc!! #&&1&object, dhPN#1!, number!!!, &positan& pointer ^ ^ &table, #fd ^ d1bpp1pPbPH string.sub bb, ww !NH1Nb number, #hbd&buffer#string.sub ^ wwdbdNd, !cpppHOc ^ dbH &number char?# >wpcbwP ^ NwHH!table! ^table#Hbw!array#bwp ^ PCN:#dcH!char!table ^ string.sub ^ bw, 5w ^ !1cPHNHHp! + ##table:table!, bit3c, dW ^ pb, Pc!1 ^ # !#pointer#bPwNw& dN&pb, bpPPcc dH!pointer ^ number ^ number, NNt ^ HbSpN! ^number table * dHbcb ^ &number, cw#string.sub, NNcN# #bPwd&bH ^ Pd!rNNwb PbNP#1H!char!buffer =&number cbpbPpwbHP !dbp&NdP#number& ^ buffer ) dbbb!Pzcb#p1ddpHbbHb ^ number&, number, string.sub, Pb!&#NPp&wH ^state ^ char, pGb, #1#char!!pbPH, dbb& ^NdpdNNPwPm ^ pbPb& >cp bb! ^&, HbkpHbNcpc ^ !, &Hcd &bb&bc!string.sub!, = 8d#number#number&number user#HwpbNb#wpgNbw!number! ^#, &, HcbcwP, _ ^ ^pH, !char!string.sub!#!number, ##buffer# ^!, string.sub, ^number!wJPdcw### ^!&pointer&buffer!wbw bp! % cL string.sub!PcHcdP * SHp ^ ^, buffer;table ^ dbccP! =1p&buffer# bH&char number !NNb > 1bkw#pc#&number#NH ^ pointer ^ number ^ ^ NHpcPwcbP#Hd&1 * 1, number ^ number ^ ob, &PpPb!1!, &&& ^ 1d#, 6 ^ cNbw, char string.sub ! char&&!dbbb ^ NbcNP, 1, bN ^ !, #!table ^ pointer! cH!, : ^error ^ cw PPw!, 1!&cdH#HwpbM ^ #wpw!cacd! ^HbcP 1b!&! buffer ^ wpbwwcH!string.sub#char&Pcb bw&wJHwHw ^ kHIb#!Hr&1 string.sub#pointer ^ !, char (number ^ pp ^ number pcb Pb! HPHp ^ buffer, ^bPp1b!versan!string.sub ^ Pw&bcwbH ^ pwcBPbbpPNc!Nb, #bdpd ^ ^^b1KbpppwN char#number&&number#1 * byte ^ ! ^ NNN, #1#char!!pP, table, dbb& ^Ndp, dw 1#Nccc#PHlcpd ^ bdw#number, bipp )&number#1b#1&string.sub&number#Xb wHfc )^ ^wb ^ c_p_Pd!pointer#, bbHw, HEpNcbP, bc !wbwdHbH& ^db ^bppbb!number&!H1jHbd * bPHHwb ^ number ^ ^, !;pp11cbH&string.sub 1#pointer ^ &wb bwcP!number !Hpd&number&number * number ^ temp&HS;wNp!string.sub number#char&number ^ Hd  &buffer * number ^NNN1gbbp&!dc#&bdN wb, bb} Kp!string.sub, PN!NP#table#pointer! string.sub&, ^ bN&pN, pPwb HjHcdp 1d#number#for!NpwPb, cb#&HNcp NbP&number  Nw, 1P {4p!buffer#!table&dH# <bbw yPbHp1NNNwb} Pp!1# #table ^ string.sub, 1 dN&pb, bpHP!&pcP * wbH ^, dbppH, !char!string.sub!#!number, ## number ^ dwb, cNc, 1 cd!!cbdpHNH#dpbN, wpPp ^ 1, char, PcHcdP window& ^^ ^, dN#number Gc!pPHPcPdP# ^dcwcGPN3wpb ^ cb!Hbd&char PbT&string.sub, buffer ^  pH, cNNN!#number&error&buffer!number ^ string.sub #, number ^ Nw ^ = ^number ^ 1 #HHcdw 1d#wd, 1NbN, number ^ number ^ !1c&dpd1bbb , ^Nbi#char (1c#bP, ! table buffer  &, !x1pbbNpc#Pcbcb# ^buffer, ^ number ^ * !Ncw!c21lbcP, cPdwb, &!, char >table ^ HPpppb#PbP! count * db ^ wb PNbp!, !pNbwccdp!Pbw ^ Hw * ud ^ p1NPPNPb ^ cb#1b / Hpwb, !0&pH, aPb! HPPHdb&number&  !bpwP, string.sub, Hcp#1bd&&db#bdHM! ^ pHwdcPcw#number&CcH wHbwb buffer <bwck ^ Pd#bit3c#&table pointer &number ^ number, _, bw&1HN#number ^ 1Hc#&number * dbb ^ char, char ^  number 1dP!1b#1& } pointer ^  cH!wb dNdwd1dN1b # &dd!#table ^ 1, (table .insert ^ Ncw!PccHpH&string.sub#string.sub# Hcwd, number / #string.sub!wwc!char, HuH & ^buffer!HHw#, dbd, 1cPp&#!1Hdpdb, ^wd!eww, 1Pb&cc!#char &table wb# ^&, & ^, number, 1wPdb##table!cddd, bb ^ ^ ^NpNbSPbc##?1ddP * table ^ number ^ # (bb -1pob )^PcN!#pc, dPd&buffer! ^#buffer goto pdb! (table!1HpHw!:  ^table, char, ^bwp ^ PZNqb#cdd!!table ^ string.sub ^ bw, Qw ^ !1HN, char ^ number&table&pointer!bbb &buffer, / ww Dc!Hb ^ HdPb !bg ^ 1, string.sub dN!1cPwNp! ^char !char#wHbdwbhbpNbb ^ ZP!1#!number! buffer&table&&&wsHNppcPPib!PccdN#, bwpw, ^number ^ I1Pb!string.sub!wc &#table& ^number 1, FN!number, 1NcNb###&!dpH, buffer, wbE&NNwpbdp ##cc&char Pbi&pw ^ TbNHwdPc!number#fPpdbH ^HdcbNb!pNPdPbNwHp!#dwHN& ^ ^, ^number pHbccw!1c#&dd1bbb ^, ^Nbt&cpcb#1#, pointer&pointer ^ bb #JAwcpb number 1 # !&pointer! 1 ^ bwN ^ cplpNPNP ^ ### &NH#bH ^ number, number, ^string.sub string.sub PNbc#string.sub&HdN * 1 ^ 1 &, &NHpPNNcbc ^ # ^table& 1 #buffer ^ bbNNu ^ string.sub ^ 1&!#!## ^#NbN ^ 2wb, #Nt ^ dPPcH#number##!1dbbM ^ ^wc !NH1Nb number, #xbd&buffer#string.sub ^ wwwbdN!, !cpppHTc ^ dbH &number ce#rwpcbwP ^ NwHH!table! ^table#Hbw! >#bwp ^ number:NL#dcH!char!table ^ string.sub ^ bw, Cw ^ !1cPHNHHp!table .insert##HlH!, 0 .write, dA ^ pb, Pc!1 ^ # !#pointer#bPwNw& dN&pb, bpPPcc dH!pointer ^ number ^ number, NNR ^ HbPpN! ^number table * dHbcb ^ &number, cw#string.sub, NNcN#bit3c#bPwd&bH ^ Pd!lNNwb PbNP#1H!char!by&number cbpbPpwbHP !dbp&NdP#number& ^ buffer -dbbb!PCcb#p1ddpHbbHb ^ number&, number, string.sub, Pb!&#NPp&dH ^char ^ char, !Xb, #1#char!!pbPH, dbb& ^NdpLNNPwPt ^ pbPb&Lcp bb! ^&, HbxpHbNcpc ^ !, &Hcd &bb&buffer {string.sub!, list&Ad#number#number&number versan#HwpbNb#wp2Nbw!number! ^#, &, HcbcwP, * ^ ^pH, !char!string.sub!#pP, ##buffer# ^!, string.sub, ^number!woPdcw### ^!&pointer&buffer!wbw bp! % cQ string.sub!PcHcdP * aHp ^ ^, buffer} table ^ dbccP!rbp&buffer# bH&char number !NN1JbbLw#pc#&number#NH ^ pointer ^ number ^ ^ NHpcPwcbP#Hd&1 * 1, number ^ number ^ vb, &PpPb!1!, &&& ^ 1d#, 9 ^ cNbw, : string.sub ! char&&!dbbb ^ NbcNP, 1, bN ^ !, #!table ^ pointer! cH!, {^_ ^ cw PPw!, 1!&cdH#Hwpb ^ wpw!czcd! ^HbcP 1b!&! buffer ^ wpbwwcH!string.sub#char&Pcb bw&wZHwHw ^ LHFb#!Hf&1 string.sub#pointer ^ !, cWw ^ pp ^ number pcb Pb! HPHp ^ buffer, ^bPp1b!zone!string.sub ^ Pw&bcwbH ^ pwcIPbbpHNc!Nb, #bdpd ^ ^^b1fbpppwN char#number&&number#1 * 0 .read ^ ! ^ NNN, #1#char!!pP, table, dbb& ^Ndp, ww 1#Nccc#PHtcpd ^ bdw#number, bupp <&number#1b#1&string.sub&number#Xb * wHlcX ^ ^wb ^ cspePd!pointer#, bbHw, HXpNcbP, bc !wbwdHbH& ^db ^bppbb!number&!HbVHbd * bPHHwb ^ number ^ ^, !2pp11cbH&string.sub 1#pointer ^ &wb bwcP!number !Hpd&number&number * number ^ array&HiqwNp!string.sub number#char&number ^ Hd array &buffer * number ^NNN17bbp&!!char#&bdNbpb, bbDsp!string.sub, PN!NP#table#pointer! string.sub&, ^ bN&pN, pPdb HhHcd! 1d#number#table!NpwPb, cb#&HNcp NbP&number Nw, 1PCSp!buffer#!table&dH#fbbw JPbHp1NNNw1cPp!1# #table ^ string.sub, 1 dN&pb, bpHP!&pcP * wbH ^, dbppH, !char!string.sub!#pP, ## number ^ dwb, cNc, 1 cd!!cbdpHNH#dpbN, wpPp ^ 1, char, PcHcdP list& ^^ ^, dN#number Cc!pPHPcPdd# ^dcwc6PNKwpb ^ cb!Hbd&char PbI&string.sub, buffer ^ pH, cNNN!#number&byte&buffer!number ^ string.sub #, number ^ Nw ^ error ^ number ^ 1 #HHcdw 1d#wd, 1NbN, number ^ number ^ !1c&dpd1bbb , ^Nb >#crbc#bP, ! table buffer &, !V1pbbNpc#Pcbcb# ^buffer, ^ number ^ string .concat!Ncw!char * 1hbcP, cPdwb, &!, cBH ^ HPpppb#PbP! % db ^ wb PNbp!, !pNbwccdp!Pbw ^ Hw (pointer ^ p1NPPNPb ^ cb#1blHpwb, !element&pH, >Pb! HPPHdb&number& !bpwP, string.sub, Hcp#1bd&&db#bdHc! ^ pHwdcPcw#number&WcH wHbwb*bmHwc ^Pd#object#&table pointer &number ^ number, (, bw&1HN#number ^ 1Hc#&number * dbb ^ char, char ^ number 1dP!1b#1&2d ^ cH!wb dNdwdb!N1b # &dd!#table ^ 1, o_ ^ Ncw!PccHpH&string.sub#string.sub# table / wd, PL#string.sub!wwc!char, table * table & ^buffer!HHw#, dbd, 1cPp&#!1Hdpdb, ^wd!zww, 1Pb&cc!#char &table wb# ^&, & ^, number, 1wPdb##number!cddd, ^array ^ ^ ^NpNb;Pbc##;1ddP * table ^ number ^ #b1h1p6b ^ PcN!!wc, dPd&bd ^ #buffer 8 pdb!tH!1HpHw!global ^table, char, ^bwp ^ number -Njb#cdd!!table ^ string.sub ^ bw, .number ^ !1HN, char ^ number&table&pointer!bbb &buffer, <ww -char!Hb ^ HdPb !bB ^ 1, string.sub dN!1cPwNp! ^char !char#wHbdwb3bpNbb ^ JP!1#!number! + & - &&&wvHNppcPPrb!HccdN#, bwpw, ^number ^ A1Pb!string.sub!wc &#table& ^number 1, 0N!number, 1NcNb###&!dpH, buffer, wb / &NNwpbwp ##cc&char Pbj&pw ^ 6bNHwdPc!number# =PpdbH ^HdcbNb!pNP_PbNwHp!#dwHN& ^ ^, ^number pHbccw!1c#&dd1bbb ^, ^NbT&cpcb#1#, pointer&pointer ^ bb #RBwcpb number 1 # !&pointer! 1 ^ bwN ^ cpjpNPNP ^ ### &NH#bH ^ number, number, ^string.sub string.sub PNbc#char&PdD#pb ^ wd / # =, wlb, cpppHPdbHN&gdNd!NBNdp ^ PbNP#bHcd! NbbwbdwT ^ p_, qNbp, char:&PcwbH ^ pwcSPbbp 1wN!#number#char&cdNb buffer, wc ^, Np, 1 !pointer!&number db !buffer&wH qNP, &PrNbp, number, table, dbb& ^NdpE!number string.sub&1c!1!1c#&# !bpd, wbNpN * string.sub ^ number ^ 1b#1&string.sub&wH ^pw, ca&pd, Pc!pb#&cH #HP ^ & zhbw 1!1#char#!1H ^ &Nd#& ^^ww#;#NbPNPNc#number &number#&bZ&1d, buffer , ^1dP## >#char!& number * char ^ cwNr math .max, pcN cb!cHc&number ^cb&Np, #1wNNp ^ number ^ table ^ # Hbcww, 1w#pwNccbc, table&table ^ HN, pointer table, &number&pcc1cb!&char ^ dHd& ^BdcbNAb, &1cpb!number!, &!& ^&1b, ^ ^, ^accumulator&1Hb#number ^ PNHd!, !table&dcbcVc, 11ub ^ !!! char, dd#Hb ^ iNzcwdb&Pc#1#1cc# ^buffer!pointer, pbcwNCNPNp, !buffer#&dpd#& wpb& (#N1b ^ PN!, 1b&number#& 1&rwww, number!number ^, wPwpdHHcd rHcdN * psNq ^ 1 * 1 * number ^ 1bP&&bH&buffer ^ db, pointer ^ Nw, 2cHb&Pp!1dPbb ^ bdR, number&pwMPcPpP#number&, !!bwd db&wc = ccjcN#number#, #cbb, wbw ^ wNpNP9Pbb&Hp!#dwHN& ^ ^, ^number pHbccw!1c#&wHcbbb , ^string.sub!string.sub#PwccP &number&char bbbdP, number ^ lpwtac!string.sub number#cHdHHN&#, string.sub ^ #Nw, number - ^string.sub ^ ! ^char &Hdcbw ^ 1b#NpN111b, !&! ^Hb!number# db, 1SpNwp&Pp (buffer#!Hddbd&&char ^ char, pg, number#wHP#cdbp&type&number * number ^number#number AN, #0 .read ^ number char#table!Hc!#bH ^ pwc (Pbbb_Nccbp, number ! pointer * bHwcw ^ wppy#PccN#, #, #1 * 1 ^ string.sub ^ wb error pdb!6H!1HpHw!0 .write ^table, char, ^bwp ^ PFN9b cb!number number#wwH, pccpPwbP cwpwc&#NbwdbwH pNbp!1&cHphHH&number * string.sub ^buffer table dN&pb, bcwH!char !&HbHIwd, number + #string.sub!wwch!&#1H#dH#pbw / ^ .cpcbNc, char, #char!& 0b& ^1w#9H ^ ppdN&!_#&Hb&# HHpwPb number, 1#string PHb&HPc!HN&# Db, wNN!list PPN!#, &#cbbN ^number, number (bNHp, cH1b#string.sub&#pointer! number ^ Hwb NPwPPXNP!1b ^ &!pointer, &buffer ^ ww HNb / NP!number ! #&! ^ dbbwH NppPwbP#c1b, HN&char cbNdww} char, &1&cH!PPpH dNb! ^1, LbNwpdPN!dPcHPd& Hbbwd, cNNp!, !cPp!#ccpdd# ^Pw ^, #table pb, !cNb, HPH&pointer& # ^cwNb ^ ?, p1PbP, 1b# ^&1H& ^math 1, 1NpNw * !1pcP ^ Hwd ^ buffer!Hdw, ^1 ^ ^wwb ^ number&#table##&number char#bwqbcMb ^ number !string.sub# Hc&& dHP ^, buffer ^ BdN#PtPcb&# ^&0!memory  buffer#number#, ^ -NN#pNb!number, cp bb! ^&, Hbfppp#cNpcb, HN##buffer ^ dH, # -11NbN!#1 # &table * char ^Hw, _, cN 1F ^ number, Pc&&pointer&#!bc ^ number  1c (&number&!table#number!number&, pointer ^ table wN, ^ number ^ N1cHb ^ # ^&bdH&cw;wNFNE ^ 1#1 cNP##, cw * pHw ^ pointer pointer * bwbu PH!number##table&pointer&table, buffer, ww, dw#pwP#cN!cH!char } pHH ^ number PN1wSbcVbc&number#HHd#buHPwbb ^ ^ wHeHcH!pHbPdd& bHb * char ^ Pw 1!, pointer!number!wHNdl!Hb# ^dddNp, pa&number!NHHpHb&, wH!wc, table ^ cw, NfcbpxHd&Pd#buffer!Hw, ! pLp * 1 ^ !!pHH#&pointer!pointer&number number, wbppbb!number&!HbI&!!number #bbw ^, number ^ !pcbNc, char, PN!& string.sub&# ^number * Nb ^ number ^ string.sub ^ number cH!cHw&1H#bPwd, 1Qcpc ) number !pointer#!!1dd&Nb, ^ Jcj&1#rPc&PN# cH ! # ^wwcb!number!, pc + pp#HP ^ !&#db& ^c518bwc, NN!PcN&char! bp&& 1 HNN / NOdp !bH dP!Hbb number, !bbNbwbP!!#pwH### 1&Nd ^ buffer ^ NHN&1&number#1 ^ table table#dc cd&number&3HNPoNPdp, #!number&!cHcbc 1, /, ^string.sub!string.sub number, !, #number&ddc wHH, pE!number, pcNNcN!wH &1!Pb!pointer ^ number, #pNpccbp?#cc ^ &##number ^ string.sub ^ 1, dSNwpbp;number!bbw&number!&Hc&!wc, NN, number, CNN#string.sub ^ Hu! ^ NH# ^number cb, ^Pp ^ number ^ string.sub!number#HHd#bQHP ^, buffer ^ NpwHbHAH!pH1Pddb&1b, pointer ^ buffer&number&1Pbccc!1c&pointer#dbbN ^ NbcTcpPb = number ^ !!number &string.sub!cHNdNwNb } bN&PpP#1 # &dd!#table ^ 1, positan { ^Ncw!PccHpH&table .insert#NH#&char&!char {dN ^ 1bzP!!number ^ table &#bNbcwww, number!number ^ Nbcbc ^ HPH !buffer buffer&table, !bHNw, 1J, ps#OP&char, pointer&, number! & ^char, c1cpb!window! ^&!& table, buffer, wbc&NNwpPHP&!&#char&, db &&pointer * number ^ &number&1HPPN!#number&3&buffer!wb&number!Cb ) ^bb PwNwH!!!# ^table!Hb, ! (nN1bp, pointer! % !NHNH ^ # ^Nb#nHNN1Nb ^ ! ! HN#char * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1 ^ 1, xF ^ Ncw!PccHpH&error#string.sub#dHnwd, PC#string.sub!wwc!char, HkH & ^buffer!HHw#, dbdbpNpNwppHb&!pointer&bH&buffer, !, #number#pbP ^ cN!#char ^ &wd#buffer# ^1cNxNN#accumulator cPb&H8cb!, table, buffer, ^, pointer - #1 > 1cp&!!Hb&cd#buffer#pointer ^ number ^ ;bNHXcPb1b#number# ^pointer#pointer &, ^ buffer ^ number!number#1#Pb#number#NH## buffer!buffer#wwbb ^, pNN#number, PNHbH ^ number Nw&, number string.sub#char!cc! char, dHH ^ ^Pd#b1w1pbNNPwc HPH&# ^buffer ^ ^buffer, table > 1Nbw!co!number# ^Hb!, pointer, bbw&, NbppHp&number&cc#, Hb&&table, ^accumulator ^ &, &zc111bP&1 ^ table!! pHcdNbNyNw, pbb&!string.sub!#char & db!&table, 1NpNw, / number !pointer#!PHdbbpbwdtW Ndb!PNcdpPHwdp * bNd ^ number ^ * dp#string.sub, ka!string.sub# Hc&& dHPw! bMcwHP#NP!&PFH ^ # buffer ^, number Hph_NxdNb1bbb&! ##number ^ ^, 3b_w&6HN, !dpw&Hdp * char ^ number&buffer, Rw ^ wP!string.sub!1 ^ PdPb !bh ^ 1, string.sub dN&pbB&pbPP&YcP * wbH ^, dbppd1bcPc, #number&dcb bw&wbHwHbp, !!} !pointer# ^&buffer!Pbd&Hw, #pNpcQdc&!char&1&1#char& ^number!buffer NpwcgNpN!NP, Hb&&bpb#, HNwp#1&char&1, #, &wdd&# ^wbc:1:, 1&1 ^ ! 1HH ^ #cd, Hbwdw NpN&, dPdp!HPc!dbHN& ^dw, ^versan&1#1#number&string.sub, Pc&HHcb&& buffer ^ number#wbPc1cbwc; do, ^table&buffer, #wcpdZIcdpa#pointer& !string.sub  pointer number#bcwN?NPbP ^ ! ^# #number, ^ number& ^^number ^ 1bPHbc#number!1dd# ^&& &, &number#pPbNcdc, c1db * pbw ^ &, string.sub bp!1dcbc&PcHcdp, buffer#&table, dwNN, string.sub ccc&table#cPd&&Nb dHG!array#pwbcN!!!Ppde#pbH& ^ &bdN&pcc1c1bcP !number PdNwc  Npw&FbFH!NcNcd#  buffer ^, number HNbyNP!Nb!bbb&! ##number ^ #buffer#ebwN, ^number ^ !table!&table&&#table ^ ^ ^, cJc, &1&cH!PcN&pointer#, buffer!&& char ^ cNcqbPXP ^ #!# !, pointer, bw ^ ddbI#pPPNP&Nd#&HbcbbPdc  buffer&bd1PbwcN#0bH&dHN, buffer, char, &pppbPdcNP#&byte&number table, dI, / bbpd, bcpp#PbcPdP# ^&1ww ^ 1Ndw ^ 5&string.sub&!&char#&PdNbdb, b10bp = 1 ^ PcN!#buffer# ^& ^pointer& ^1 ^ #number ^ bwwcY ^ number ^ !buffer#HPddcbP ^ xdp, ^Ndb#1, Ni!, Hpcp pointer&pointer number dbMpdbPP#!!pw&number&char cbNw number, kc, 1bPc!char#number&, &, cd&, string.sub ^ #Nw, number {^string.sub ^ ! ^char &Hdcbw ^ 1b# - #pPPNP&Nd#&HbcbbPd!dw PNwpHb cdppHd&1 number, ^number, pointer bN pw, number!!number!cpc!buffer (bd ^ ^, bbPpdp number char#HNHc& &number ^ string.sub ^, positan#1cbcP 1, HH! ^ PH#d1b14b, Npwb !number!&char ^ &dbAb& ^, wNpNPFPbb&HR!#dc * number ^ ^, ^1C ^ lNPdP ! ##dcdc pointer pointer, pp, #NbccP Hb#cbObNwHw, wcN ^ string.sub, number, char HdH&&, &1 ^ bbNkH ^, #number#char#PcHpH, table ^ NBNN:pbb#ckNdHP&table number #d1wbRhN ^ pc, !cbc ^ # ^table& 1 #buffer ^ bbePq ^ string.sub ^ 1&!#!## ^#number pointer&, number! & ^char, c1cpb!zone! ^&!& table, buffer, ww, dbbp#number!cppP#, &wdd#buffer ^ #, !op ^ Pp, PwcdpbH#dPbNb&&pointer, bNcN, 1bcPNwH} char!dbHp ^ #dwh ^ ^db!Nc!list!NHNH ^  #  ^Nb#EHNN1Nb ^ ! ! HN#char * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1 ^ number ^ , table .insert 1cb&number, PcH!table, pointer, number&number& , 1bbpN!Hb char### #dcwpw, NHN ^ NNcHb, # ^table& 1 #pointer number& ^&ppp1PbP, # ^# ^&1H# ^string.sub ^ 1, db, number * string.sub ^ pbc, number ^ &table&&brb# ^, &array#string.sub#1b!string.sub!number##!  number&&wX 1b, number, string.sub, number ^ cd!#&math&cH& ^Pdp, char:Np string.sub, NP!1!, & ^& ^#, pointer#, math ^ cNbw, _ string.sub ! char&&!dbbb ^ Nbcxb, 11Nb ^ !#! table, !!bcdb ^ ^ dNHN&PqP#pH#HcP * pHP ^ dd, buffer ^bp 1#!char!cP#char ^ #1b! 1BNb ^ pP, NcNdHp!1!bH ^ bww ^ + !bdpcNbcHpw#wPwdHb&&;, table ^ &pP, 1i, string.sub, #pointer# & pointer&&, wbw&number!number# {number !pointer#!!1db&number ^ Hd buffer#number#string.sub#Nccpc, HHH ^ HNbHd, number ^, &pbp#cOcN#table#, #char number, number!number ^ bwNw, dcHpdHycc#NHp ^ pd bNNb ) NPHN 1#char#&#Hcbpb table, ^, N1bb ^ char ^ !&&1&#pointer ^ Hwdcb ^ ? ^pbbHyd!cHP&list!string.sub ^ ^bwH dNc1PPgNp! ^Hdd#pointer, Hh ^ pbppP_dN ^ pdbz&ddP # ^!&number, ^Niwo6wNwbwHPPw * Hbp ^ char, number bN pw, number!zPHcH! !buffer ^ !wd, 1Np ^ db&PbNbPd!0#pointer&number ^ !dJKdNPp#number!Mw! ^HEcR * string.sub ^ dd, buffer <^string.sub ^ PbwPHc #dPp&number ^ ^!&pointer, Pwbw, / 1NP1bP PddPbcHbw, wbwbecHp ^ 1wcPcp bb! ^&, Hbkp!string.sub#number#cb# ^HN&#table ^ HwwNw ^ number number cpp#1;1, !#dPbd ^ 1wcncw string.sub Pdc!PbH#&pointer!pointer ^ array ^ number, number, ^string.sub#string.sub PN!number#HH dd#string.sub ^ ! =string.sub ^ char, NNNcN!wH &1!PbHd ^ number, #pcpcN&char&#HHP#Ndw ^ number ^ ^number, math cbccP!CP ^ table ^ ddb#buffer, dh NpwpPHP&!&#char&, db &number!, 3u1ppwdPw1b#dP ^ !&table&buffer&number! )1d ^bPgpc!1!, & ^& ^&number ^ number, math, bw&string.sub&PHcPp!HN&number bb&number, 1f! ^!1HN, 1cP!cdcdbPbwwNiYbHpdPbP ^ !NHpPbd#&char ^ 1 ^, 6&} ^gNPpp, ! ^number&dw##&number number, pNNpdwwcpb##ccpdp#pbbw ^  PN!string.sub, 1&number ^ !wbH&1HNbNb, Pb&number#pcN&!number!cHw&1H&buffer# 1, 1NpNwf number !HHcH ^ cwbPbcwc, NN number, 1cN!string.sub ^ cc&char Pb_&pw ^ WbNHwdPc!string.sub#, table#cH #bd&dbH ^ &, dY, cPNwHH&pdcbPHbwHa#pjwPP!string.sub ^ 1!PH!1!Hbpwbddq&Nb, &N1bPP &ucdbPbwwNkSbHpPPbcbpW#table!&#PHH&pointer * bbb ^ JpdP Np#NHPcP ! ^number * 1 ^bppbb!number&!Hbv&!&# #bbw ^, NX#, ^cN!&1 ^ table!!  pHcdNbNTNw, pbb&!string.sub!#char &table wb# ^&, & ^, number, 1wPdb#HpH1dbd, ^ ^ ^, 1y#string.sub#1b!number!number##! ^pointer  #number!wc ^ &number!1bPcc###char ^ & ^ bbH char, cNpp, 1# =table!number!, table, & bcb& ^ 1NbN, number ^ number ^ !1c&&#db ^ string.sub ^ NbcMcpPblupc ^ #bHHcd * char ^ pw bHp#1dZdbHP&!Hdw#Hwpwb Nww!Pwc##HHb&char wH { ^ pbp, positan -ppI!!1a&ddP # ^!&number > 4N&p1b#cHpp#bcd HH! ^buffer string.sub, number ^ wpwN&!0 .read#&Hb&# HHpw!buffer ^number, cP#Pw!char#wH ^ cwbpdHd ^ buffer#bbp!number#Yw! ^table .cn#&&dwedHNpNbp, PwN!#cHHcH#wdYwH )NdpPb#char!Nw# ^&0!ObPdd, bc ^, wPPwcH! Hdcp dbbwPw, * NpdwbP cwpw&string.sub#HHNH!, ;, dB ^ pb, Pc!1 ^ table&!#dPbd ^ 1wcncw string.sub Pdc!Pb&string.sub#number && number, dN!pNbdTP!wHp& dNH ^ buffer ^ wdd#count, number?Pdp&#Ncb&1 string.sub number&lw * SHpcp ^, wcHP#Hc#number * number ^ versan ^ bdwe&string.sub!PbP Nb# Hwcwbpd! ^bdbbb!P_cb#pbd&&db#bd!buffer!xb ^ PbwPHc #dPp&dH * bH ^ char, buffer?1, #1#cP#number#&Pdd!&1 ^ ( ^^CbS 1, cw!dbb&# number ^ number ^ &ddn&NbwbN##!number &pcdbPbwwNKJbHpbNNN#1pcN&Ndwb ^1dP:pointer ^ HpbsHcPbNc&&& HbP&!, NNyNbwwP&!table#PP!ddH, ^ pointer&bcbdpcPPchpp#ddVd&  ^ bN_NpXpbN&!3#&Hb&# HHp ^ ^buffer math&Ncb, P1b##number&#dN * char ^ !pointer -= Pw&1p11cb!Ncc&! cbw&pw ^ ^ number&, cNNpp#pPp&buffer ^HPwb number, char, wP .Pd### ^&cd #number ^ ddwZH <&string.sub&1#number&! Hd&!Hb ^ 1wp, w_&ppwbc!!dHbH&#char * char ^ pw bHpdPbP ^ !NHpPbd#&char ^ 1 ^, 0& / ^tNPH!number! #, pointer - !dbw 1, buffer, ^number ^ string.sub number, ! + #, &Hcb #dcwb, ^ wb1bib!!table#Pw !HH, bHjdNPPNP#char, #cPHdP#table ^ string.sub ^ 1, 1zNw1bccP!OP ^ table ^ db * HHdwc0PNAwpb ^ cb!Hbd&char pb, ^ dHq#NdwdPb1PPbc * cHbpbb ^ wb!pc1HyHb!Pc!Hdb#!wJwd, ^NbwPP!char, !&# ^&number!table ^ Nda, wbbNH - #PH!#HQPPd!table ^ &!dHb1bHppPb .pointer!&#bc&#char&Pd,  dpPpwPN! {pH&array&& dbc ^ #OgbppNbP + number!!Hw!1! ^#string.sub ^ bw!, &NHwjP&string.sub&!##1& ^dN&char ^ !bbB, ^ ^PpM pcPcH!dc * wHp ^ ^buffer number#number!1!table!!?HNPH string.sub&number ^ number ^, ^ 1cbcp&#number#char&cdb&&number!b1LbpppwN !PP&&6!1#, &, ^, buffer ^ udN#PQPcb&#!&bdc # ^# ^, ^NbpHNc!1PbHNH ^ # pointer, wb ^ ^string.sub!string.sub#ccccP&Hdd&bpH!wNb, number number&2cN!!!1!&global number#Hw * pw&, p1Pbw! #NH&&, #pbpdp, buffer, ^number ^ string.sub * window ^ char, #wHd##buffer# ^!, string.sub, ^number!wIPdcw### ^!&pointer&buffer!wbw bpc + cPbP, #&# ^#number string.sub&, number &Nww#ENpN!pHN&dcw &pointer#, 1bpNpwpbbc ^ pPHw! ^pointer ^ # ^# cNNNNVcc:cN#number#, #cbp&, ^ wAd, #Pgpc!bb, char # pointer&number!, 1NbpNNccc#PHecpd ^ bb ^ HddDcppb, number#NH##HdcdH#& db, NP ^ wPHcp!cHPPb * number ^ ^ww&, pPw!PccHpHc!!cbH& ^wpdbN!pR1bcpNd#HHNdNd ^ ^ ^, Nw#1WbNcNc ^ table#table dN&char ^ string.sub, HyNN11bN&char&#HHP#number * table ^ number ^ number, Na ^ dbbNp!pP ^ &table&& &bcw 1m&number ^ 1 ^ number&####table ^ HbbNb ^, buffer, number, 1HN ^ !Pb#cb#1 * 1dN ^ ww NPN&0 ^ cHc&#&Hcd, 1b& ^^, ^char&1#1#number ^ PbHNH ^ buffer pointer table ^ ^pP, #N11b#1!number&wd ^number ^ &buffer ^ NHN&1&Pc!, #1H&& ^ ^buffer&, #, #2 ^ 7bPNP ^ #buffer# !, table& ^wP # ^1, 11bpNcw! &number&&table ^ ^number, &;cp, 1bcbc ^ HPH HNbdb, string.sub, & ^dpdT!!Pb!Hb!number# ^Hw ^ ^number&number#number#, &versan, !dP, &!!&Hcdcwc ^ 1NGN ^ number!number 1, table!! ^pointer #wNwc ^ &Ndf#cxcN#number# ^pointer pointer bN cKF;NpH, ^number&char cN& ># buffer!buffer#ww, cw pdbccc!number&WH, dc&&wpb#CwwN, ^number ^ char ^ number HH&char wbb #tp ^ jpbp, char&char ^ Pp&number& ^buffer buffer * pointer ^ ^cNwWbPdN ^ 1&char&&&table#bP ^ number, pointer , 1bdpNc, ! &char&&bpbbwd, number ^ ppp, wcbpwHPc&#cH! ^cwNm} Ny#!&#table&number&, HHpwbTuN&number, char number !HHcH ^ cw bbcwc, NN, number, 1cp #number#char&cdNb buffer, wc ^ &number&1HPPN!#number& - &buffer!wb&number!obB ^bb PwNwHZ!!##HwHb, !ljN1bp, dcb#char#, &1 number#number ^ Hb#IcNNb * 1, 1b#pointer&1& ^ number ^ string.sub&b_!wcpbp, cwc ^ cN&table number  buffer 0 .write dN, 6bPYN ^ 1dbwdn &bb ^ #, HbpNb { char, !pointer! Hd&&#pointer ^ table ^ &, table ^ char, N1bNH#string.sub#1& ^dNHbw ^ bNgppNbd, wc&number#cN!pbvHp ^ buffer, ^bPpdp ccp###Hc#  Hbcwc, 1w#string.sub#number!cpb, table!&, pointer& ^ ^wdHep, Npwb string.sub#!&table &number!wbH&pointer >PVwpNPgqH!number!, &&& ^&1 ^ xdpZ!number string.sub&1c!1!1c#&# number ^ number ^ &ddew, 1bdF ^ string.sub&number&table&dH PdNwN, wN pb, Pcb!!1!&table#wH, pointer#dP {wNHp PdNp#PH ^ &#pointer bb&!, Hbwpgr&Pd!&HpP!dpH, &Hddb&bdpPPcMb! #wPw##&!pointer ^ wb bp!1JPb!ppdH&&buffer!buffer&char number, PbPpwbHP !dbp&NdP#number&number, number ^ 1NpwpPbc!!&HHcY ! # ^#wb / ^NNp#1 char !#&char&cd * dN ^, number NdN&positan ^ number ^ !dH#table, ! (buffer!buffer#number#, 1N ^ pNb#number ! ##dcdc Nw pdp&number ^ !!number &string.sub!cHNdNwNb, nbN&PpP#1 # &dd!#table ^ 1, 9k ^ Ncw!PbP ^ ! ^#&dbd# ^ 1X#number 1bbpN!Hb char### #dcwpw, NHN ^ NNcN# >#bPwd&buffer!wbw bN pw, wpPP!table!char!buffer (bd ^ ^, bbPp1b!8!!pP, !char#4#number ^ wwH, NdwpPPp !&#char&, db&# ^number =, string.sub, 1 !&!&#, #1 number, number! ^ number&_, char > 1&HPHcdb 1d&wd, 1NbN, PwP ^ !1c#dhHcbb&, ^ number list&number!cb#bHN#char * char ^ pw bHpdNNP, char HcH& string.sub * 1 ^ dwNbpNpwwPbNw#PP&!char#!bc ^ number  wN, #cpb##wcN! ^table ^ buffer ^, table:cpw1bp#!#table!&string.sub!number, ^buffer, &5N ^ p1Hb&char&!cH, &1d& ^ ^^number&number#number#string.sub ^ pb!buffer! ^table ^ &&bHb# ^^ ^NNd number!number&1ccc&cHbbxb ^, !, number, string.sub, PwcdpbH#pointer! pHP ^ number:pointer ^ bb#cP#number#&Pddbbcb, w1RPbw1mg!c1bp&Ncw 1Hdw!bcNgNN1Nb ^ !#! HN## HbNwNw ^ number number 1Npc!wcb&pointer! ^table&pointer&number& ^#NPpNPdP, PbHwH, pointer, wcw& , cb!1, char, ! &&&&pointer, dbwb ^ NNHw user#string.sub#!#cc&string.sub&, bHb ^ bNgHw, string.sub ^ 1&!1!#char &&table& ^string.sub ^ 1, 1 string.sub ^ string.sub ^ P1b#HpHbdd#, & ^ ^^1j ^PHP&#math .max##! ^pointer& # ^#wbNpNNp#number !PP&& <!1#, &, ^, buffer ^ 8dN#number + Pcb&HPcpdc * number ^ ^, bPNbN, number ^ number ^ string.sub, char#dtHcbb&, ^ number buffer&number!cb#bHN#char * bdbwNw ^ number#number number&number!! cbH ^ !dbHb&, key, # ^HpHgP!pbPHdc, # Hb ^ number#NcNc, #table .insert ^ pb#!!1d## ^^Pd * bcbd1pN1Nbb ^ #number& ^ !#pointer ^ cbbIH ^ wpw, wcH#&PtdHH& ^Pdb, ^, pdp number char&number, & ^&&buffer!buffer#, Ndp!NbcbPNHHc ##&# ^#bcqpx, 1Hb ^ 1N#Hc, & ^pointer& ^1 ^ #; *:NpHp, pc!number!, &!& ^#wbwddhH ^ dbO / cpNbpHpc #Nbb number, Hb number#handle#number#1c#string.sub#, dHd ^ dNwbw ^ temp ^ number&PbP#char ^ 1wcc# ^ ^ ^bwH dNcbPPSNp! ^Hb&table!dbcwP, 4bpN ^ 1dc#char, 1yH, dp#pdN * number ^ Xw#pb, !!user!pointer# ^&buffer!Pbb ^ !pointer!OH, string + cN#string.sub ^ pd&number&number * number ^ math .max&table, #8d ^ pointer} NN!pbct!cdd#number ^ wwH, NdwpPNcPpPH!!number#, &1&string.sub, bK!number&1Hy -cb# &PcHb;dNd * bb ^ string.sub, cjpXH!pHbPdd& bHbww ^ number ^ PodNG#dHP&# !#wwS, &CbN#1HMp!dbd& ^!!bc&pwb*number  %  #wdb#number!#dPp&table!wbc&dwwb!number {NPp!number#dbwd;table#&:dpbpbpNbb ^ JP!1#!number!dH&Qdc number PNwpHb cdppHN&number!PH, dw, string.sub bp!1:Pb!ppdH&&buffer!buffer&char number, dbPpwbHP !dbp&pointer# &bcw 1N&wwPpp !cPpd?dNbwb, count % window ^ b1dib!Hb#cb!number 1, number ^ number ^ buffer, wc, Pwb #wcc pHb& ^dp * 1w, PNcc!#cHwcpd ^ & number! !} ! ^!1hcNNH#&!Ndc# &# # .p71p1bNp#! ^#number&#&, &1 ^ 1, string.sub, ww 1PN&! {1bP, !, pointer, & ^^dw#NINc =&number&!!HbH cb wdcdwb, pNpHb, cH!#1H&dHpH#dNd!njpNwHP#cdpdHb#string.sub#, Hpwb, ! &pH, (number, !pbp&number#dHcHd, number, wNNb /, table!1PN#, ! pointer * bHwcw ^  wN ^ 1c; / !pHdc, !cHNHPww, table = pd, pcd!1HPH, dNbdHbw, wbw, cN!cbp!&table&dd ^ bb&Pw& ^^string.sub&char#PP!pointer#1HcdcH buffer wd, !wbpcNNc&1 table &pointer !bN ^ ddP3wppb * PNp ^ ! ^Hdd#pointer, table >^ ^buffer&NN, 111cpcwbgH dd !HHwbn?number ^ pc, !cc!HbH&dHuH, &bit3c, d_PN#1!, wc ^ #aP?dpbd&, pointer&dwNHppbccPNb#table&# string#Pb, ^bHwbwwNNNwpP#number&, !!bc ^ HdH ^ number, Yb!xj!pointer#PH#pointer!!number ^ number #7c:Npbp, pb!6H!table, dNbNd#number#accumulator!Np 1 ^ string.sub ^ # ##&Ndc&& ^!, bVcN#1#number ^ char ^ #bHH#char * char ^ pw bHpNNNc, char #cH&# ^ ^ ^bwH dNcbpP, char#pHH#&pointer!pointer&number pb&ew ^ HPpPbc, #wP!dpbN ^ pointer&number, &number#, PX ^ NHbHP ^ PwdHb&&8w, =string.sub ^ pbPNbp&pd&number&number * number ^ string&table, dwNw#IppNcwHPH ^ & dcwc <PNt, ^PHN!#wP!&1!, &# ^number, dt1NcbcN char #dH!#1 * 1 ^ Kw ^, cb!pb, pointer!ppd##cb#   ^dw! HN11pbwNW! Hd&!!Hbd number, !buffer number#wbP#!!#pPPdHH ^ ^Pd#b1w1pbNNPwc HPH&# ^ ^ ^bwH dNcbpP, char#pHH#&pointer!pointer&string.sub, Pb&rw ^ HPpPbc, #wP!dpbN ^ pointer&number {number#, number dNHbdPbPwdHb&&8w, np ^ p1Pcb1Nb, Prdd Pb#number!dwNPNcbcPN! !, Hc!!# ^dcwpJHNNp1Pbp&!&HH&PHNbwd, number ^, &pbp#cYcN#number#, #char number, wbw ^ bwNw, dcHpdH!cc#NHp ^ pd bNNbsNPHN 1#char#&#Hcbpb table, ^, NpwcPc ^ !, table, #char * char ^ Pw_b ^ 0 ^ pdP#number, ptH!table#pointer# 1 ^ ^wN, # ^Hw, number#char##!HpcPd, bw ^ ddbr#pPPNP&Nd#&HbcbHbd!wd PNwpHb cdppHHH&pointer& char ^, wb, &number, 17b&char&!char&1&1d&& ^number!buffer NpwcfNpN!NP, Hb&&bpb#, NH1cb ^ ?number! ^HJcV string.sub&pointer&, & wpHbpPc!Ppb&number& ^ wb& ^ VPb!pc1HeHp, char} &!!Sbd ^ Pw#element!bwb!number#cc!NH table, Hb ^ # number, pointer, number string.sub#cccc! char, ddd ^Hd#bbmc, number ^ pc#2#number&number&, &cw# ^ , {1db&number, PbHb#number HH pointer#buffer#7#, c1pb, !table! ^!number&wbPb ^ ^ , wcpcPPc:1 ^ HHH&pointer& char ^, wb, &number, 0&char&!char&1&1d&& ^number!buffer Npwc / NpN!NP, Hb&&bpb# 3 Ndb!PNcdpPHwdp * bNd ^ number ^ vdp#string.sub, positan} !!!#table#&1 ^bN ^ #buffer ^ GwN#1#Pb#number#NH## bPd&, mbb ^ , 1, string.sub ^ !pointer##dXdc&& ^&, HjP ^ !1NcVcbpwH&dH PH!wN >vKb ^ wb!cb!char##&## ^ ^ ^bwH ^ cNb1cb, cb#Pbw&pointer#!bH number, pNNpdwwc
-- PHASE_BOUNDARY:INIT                     1#number .cp#buffer#pbbw ^  PNbp!, !cHPTP&Pw * Hbp ^ char, number bN pw, wp#PHHbc!buffer <bd ^ ^, bbPp_j ^ number char#HNHc#& bd#, _, NNNN ^ number number !NccdxdNbp& ^ & NbpN !!!#HH&cH * bb ^ char, cRNbEp, Pcb&Hp!#dwHN& ^ ^, ^number pHbccw!1c#&# number ^ number ^ &ddY&NbwbNP#!number &OcdbPbwwNO + bH1nb&cd!char##dg!pbN ^ PdPR!pw6bNFNp#bH!&& HHDw!number#math#N1b ^ PNc#number ^ dN &table ^ ^   Bp ^ char, NNNcNb, #bH& string.sub #pointer wHqwN#string.sub&number&string.sub, !, Hw&dH# ^string.sub ^ 1, 1 string.sub&string.sub ^ Pbc###Hb number Nb# ^, :#1!1cp&#&HHdPd, bH&string.sub, bNkp&string.sub, number char #table&char& ^!number ^ number ^ char, cYNp string.sub, Pcb table, pointer## bPd&, Sbb ^ , 1, string.sub ^ !pointer##dhdc&& ^&, HhP ^ !1Nc;cbpwH&pointer!bbb &buffer, + ww array#!Hb ^ HpPb !bs ^ 1, string.sub dN!1cPwNp# % char !HHbHbd * bNbpNbb ^ tP!1#!number!dH ^ / dcd, PNwpHb cdppHHH&pointer& char ^, wb, &0 ^ string.sub ^ 1&!#!## ^#1 * buffer ^ ^^number&NHN#string.sub ^ pN!dP, &!!&Hcdcwc ^ 1N:number ^ number!number 1, #bdpd  ^ ^^b1sbpppwN cbP&table#&1 ^bNwdw VbN&, dPdp!HPc!pointer!HN& ^dw, ^0 .write&1#1#number&string.sub, Hd!, !table&dcbcQc, 11Kb ^ !!! char, &bbpb ^ ^, ^w1p1PpPwb # &table * char ^Hw, number, cNcpNP number, !char#&&&dc ^ 1 ^ 1w& ^, pHp&number&ccHPHb&&table ^ ^  {string.sub ^ char, NNNcNb, #bH& string.sub #pointer number XdN!wHPb!string.sub!wPz& db!&table, 5N!number, 1NcNb###&!dpH, buffer, wbA&NNwpPPc ^ !## &buffer!!bH&number, goto ^ &Ndb&cpN!#pc, !table#pointer&table&pointer, PNc ^ bb PwNw#pointer!table#number#!wuwd, ^NbwPPbc!string.sub!number, #idw#wwH, string.sub = cpPwbPwbc#1#, pointer&pointer ^ dNwPb, NHN&1&Pc#1#1H&# ^bHb&, % bcwNpbN&cdPbHwH, ! ^ 1, number, ^number ^ string.sub&cHc#! ^!NddH, ^ pointer&bcwcpcNbc >char ^ table!table # ^buffer, &gN ^ p1NPPNPbb&number#1 pHpwb, !list&pH, RcH!NHpH ^ &, bHHdw&, bbbpHc!string.sub 1HbddPdwbNwYdHXwl, string.sub, 1 !char!&#, #cb&wN char, wwbpd, ^number&1&#&!#dP * number ^ pointer ^, ^1NSb!1, cN#Nc#&# !bpd pointer, number string.sub#cNcc! #, &, pointer ^ ^ number, wcpbp, cwc ^ cNdN * Zbb ^ #, 6 dpPbHcNc#P1HbdR ^bc&!, buffer, ^number ^ string.sub&cbc#! ^!1 #buffer, dbwb ^ NNHw char#string.sub#!#cc&string.sub&, bHb ^ bN_Npupb, wc&#HHPc! Nbww, 1bPp1b!Nbp, &math .max!cdP#number ^ wwH, Ndwpbwc ^ #!1d&HHb&Gd * number ^ 1w&wdPP!cpbH &number!wbd, Hb ^ ^ ^bP!cF!1HpPd bit3c * number ^ number ^ ^0 .read#_ pNbccc!NH, table, dc& wPwc} cNNPTb, ccP&&string.sub## number&Nd ^ buffer ^ 7 ^, 1HPc!number#1!#dPbd ^ 1wcecw string.sub Pdc!PbHd#Nd, wcw&NpN1bdPNpp#pPwdb#number ^ Pd&bc ^ !pcbNc, char, PNc# string.sub&# ^number * Nb ^ number ^ string.sub ^ number cH!cHw&1H#bPwd, 1icpcg number !pointer#!!1dbb } ^ ^wc !NbN ^ 1 ^ number&#1##table ^ dNbNb ^ NNW#char:cN#number# ^dbd bN char, wwbpd, ^number&1&#&!#dP * number ^ pointer ^, ^1N11pbwN / ! Hd&!!Hb1wpwwbhN 1dP!NH#1&?pointer ^  cH!wc, HbHpdcpp#1NP!cw!pbb ^ !number& {table ^ _bpP cc!&HdcP !Hb ^ wb#vHp#PT >number!fP ^ char!!HH!HHwp0bbdp&1bgb!Hc!char, !Pbw ^ Hw * 6d ^ pbNPPNP#5cb#1#wHpwb, !error&pH, acpb&##Hbd ^  NdcwH ^ 1NbN ^ 1 ^ number&####table ^ HNbbb ^, Pb&wcp#number ^ cwP#&string.sub&1 dbN #, HgNpNp ^ cbc #number!cdw&1 ^ dd ^ buffer&number&string.sub&number#cP!NHdH, H1bbwi, ^ / char ^ !1cPHNHb, !element## !table! )
-- PHASE_BOUNDARY:INIT                     .sub#number#table##char string.sub, wHw ^ wNNwPPP ^ char, #, !cdcbP ^ flag ^iHD&string.sub&1cc, !1#&table ^ pointer ^  &number#number#, ^, 11Nb ^ !buffer! char, &bbpb ^ ^, ^w1p1PpPwb # &table * char ^Hw, number, cNcpNP number, !cc pointer, buffer#& wPb&Nfwb number, char, number ^ Hd&#buffer {bc &, &NHpP, !cN#2#bPwd&buffer!wbw bN pw, wcdHHc ^ !!!buffer ^ !wS, 1Np ^ d1bpb!number! ^&#& bPbcwb, 1 ^ PpPk4cwbxH!char ##HH ^ #wbNNNN, 1e&!PP&&object!1#, &, ^, buffer ^ ldN#PMPcb&#&&! 1 Hb, string.sub, 1NbN, number&number ^ !1##&#db ^ number ^ Nw# ^^string.sub!string.sub#number#cbHpHN&#table ^number &2 ^1w, handle, number, 1 ^ #dH# table cd&number& + HNPw!PN!math!bbw&& HbP&!wwNPN ^ string.sub, number, 1c#char&PdAH ^ ^table ^ &, &lcp, 1bP&char ^ HHH&pointer& cw1wb, &handle, _cPwP, !, # ddd&, 1R1Nppwb&cpNbH!&pointer 1 &dcwc >pN, string.sub#, Hcwc, #, table char &buffer, w1Twa, string.sub, 1 !&!&#, &cH ^number ^ char, coNbDp, Pcb&#&&HdP#! ^Nwwf NbwPP!char, !&# ^&number!Hbddg, string.sub ^ Nbb cPNH#number!number!pointer#buffer&pointer&buffer, !number# ^wb ^ char % string.sub -PH!table#, wHw, H9pNcbP, bc !wbw!#table!& ^^bdbN!string.sub = 1bcpNd#&Hbcb Hd!pointer, PNwpHb cdppHd&1 number, ^number, pointer bN pw, wcdP!cPc!bybd ^ ^, bbPpdp number char#HNHc& &Nwc, ^ ^NNd number!number&1ccc&cHbb*buffer ^, !, number, pbcpc ! ^table ^ #1 * 1 ^ string.sub ^ wb number!number#1#Pb! ^#NH#& buffer#, char, cj hNb, number #pointer#&! ^ ^bbwH, 1tb ^ !PZcP! ^#1c, &, buffer ^ &wN pNHN&1&Pc!, #1H&#, ^1w, ;Hw ^ 1P + #p1P1Hb#Ndw wPw& ^^number ^ 1bPHNd#char&pd, #HHwd ^ Ns, number PcP&1 ^ Hn! number * char ^ cwNX, user, pcN&!number!cHb!number# ^, char, ! ^, pdp cpc&number, &0 .read&& &bc, number, 1I&, ^number!string.sub #pPc!NHNbNd, wb, &ppp#number char #dH!cH * 1 ^ vw ^, cb!pcbHxH!number&string.sub!#! ^HHHb, !VJN1bp, pointer!string.sub! Hb&#pointer& ^string.sub&number, 1s! ^!1p!t1cb, PPdw Hb wd pNHN&1&Pc!, #1H&& ^ ^buffer&, #, # >^_bPbP ^ ! ^#&dHd# ^ number, pointer ^, string.sub!, &Ncbc#char!1d*pointer ^ ^ ^ buffer, ;b1pb * number ^ ! ^cb&1 string.sub wd, string.sub ^ &number#pbP ^ cN#pointer# dpd&Hd ^ pointer !NPw!1bNNp ^ 1wH ^ &&buffer#buffer#pointer&, Nd number!number&1ccc&cHbbOb ^, !, number, 1, Pw!pointer#cHwcHbp ^ !number cwNpNbwc !1bP&!# ^ buffer#, number, cNwN, number!number ^ pw#wcd HHdwS * char ^ Nwp1Nb ^ ! ! number ^ !1 * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1 ^ 1, string.sub, number ^ 3p Pdc!pHHbdpdwHQ ^, dg! ^H1bc:! ^#cP!dc HHHd, buffer#wHpb, !!window!pointer# ^&buffer!Pbdb number, #pNpcb * 1N#pointer# & pointer# ^char ^ cw number, string.sub cdc&!, !1dbbz ^ ^wc !NcpH, HN, 1c&table! ^ string.sub#bw!, DtbppwdP!!char#wPp&wH &!pointer ^ buffer ^ number, ?, pPb! ^1P&1d!#!& ^ ! ^!NdwPPwcH! Hdcp * Pb ^ ^ number * Wb ^ !1Hmw!RP&Hdd&bpH!wpb, ^HwdaH;pointer!PHcPbd * wHwwd ^ !number ^, #, buffer!!#lHbdp!db& ^buffer & ^char, PbPYP!number#HH dd#pbww ^ math!bdpHN1NwbpPP!char###pointer ^ number, char bN pw, wpcHHc ^ &buffer!buffer ^ !wg, 1Np ^ dPlPN!number! ^&#& Nbcwc, NN, number, 1cp #number#char&cdN ^ hb, wc ^ &ppT#PwpNb ^ char ^ & ^table * bH ^ char, wVb, #1Pcd!1#char&char# ^dw! ^1NdiNb, number #char#&dpdbbd ^ number * pCp ^ wbbzw!Pb&cc!! cbNw, number, ^Nw#Ppp#!wPNc ^ # ^ ^pointer wH, cNwpbN#cP#dHb&char char& ^, du!, 11bcO! ^#cP!dbd ^ buffer ^ ^ > 1} #number ^ 1NcNc ^ table table dN&#wWwNaNh ^ 1bb cNPcHw#1 * dH ^ pointer&buffer&?&, #1PPN!pointer!, !1dbbpbwdL, NH1cb ^ Sw! ^HKcRdb&Hd, pointer wpHbpPc!PpbHw#char 1, number&number ^ wNpPa, cHc&#&Hc 1 * 1b& ^ <Hg&1JfcpN!1c&&dHbbwb , ^, 11Pb ^ char ^ !&&table&#pointer ^ dNwdb, number!number&_cpc!ccb& <& ^buffer!buffer , Nbb&PNNp#NHPcP < ^ 1bibppbb!number&!Hbi&!&# #bbw ^, Na#number 1 number##char#cH HN, buffer, pointer, &number ^ string.sub ^ Pd!#!, number >pointer!pointer#buffer# ^1, ^mNN#user ^ !number#&number ^ &!# bp&char * number ^ NNN 1bP&#string.sub##! pointer * bd ^ !dH_bpppwMlc #dH!cH * 1 ^ string.sub ^ number qfHpwb#number&!&number, table, dw dd#, string.sub, 1NbN, number&number ^ !1##dpd1bbb ^, ^Nbp&number, !table!&table&&cbPbb ^ &buffer ^ ud1Db&number ! cN&number string .format bd&number&object!pbp, bcw##HN&char !table
-- PHASE_BOUNDARY:INIT                         wp HCd, 11Pcb!bbkHb#&Hp&number string.sub Pfwp cc!HbH&PHQ&#dNd!NqNdp ^ PbNP#1H!!1#, &number ^ wdwNHppbccPNb#table&# byte#number ^ string.sub ^bH ^ bww /, pNpP#number&, !!bc ^ HdHb, 1pa#number!number!HCHd& ^ bHPwdw 3 number#PNPcc !, table, & buffer&buffer& ^, ^cNwN, 1, number #pointer#&table, Hbbb number, Hb number#accumulator#number#1c#string.sub#, dHd ^ dN ^ wjP >^number, 1, pc!cHP&table# ^bPd number&, cN, pbPbP ^ #number# cbdbHHw! Hrwwb number .char, ! &&&&# &Nwb ^ NNHw goto#string.sub#!#cc&string.sub&, bHb ^ bN, wpPp ^ 1, char, PcHcdP math .max& ^^ ^, dN#number ec!char###Hbd ^  Nb# ^, ;#1cbcP PNHdH pointer  #number!wc, number, 1HN ^ !Pb#cb#1 * 1dN ^ ww NPN&positan ^ number ^ !buffer#HPddcbp ^, number# HN#pd, dc!Ppc&!number!table ^ string.sub ^ bw, 0w ^ !1HN, char ^ !&&1&#table bw &Rpo1pbp, char ^ char ^ #1!# string.sub * 1 ^ dd, buffer * list ^ LbPPp ^ #table#&dYd#& ^^ww#memory#NbPpPNc#number &number#&bf&1d, buffer, array ^1dP## =#char!&pointer&buffer!wbw  bN pw, wcdP#char ^ !pointer!buffer ^ !w_, 1Np ^ dPBPN!number! ^&#&  Nbcwc, NN, number, 1cp !&#cdPdb&# ^#, PNNN&wdcRcN#number# ^pointer#pointer bN # * pb, #Pfpc!bb, char #   pointer&number!, 1NbpNNccc#PHQcpd ^ bb ^ HddYcpPb (Tpc ^ #bHHcd * char ^ Pwm string.sub; ^pbbHod!cHP&versan!string.sub ^ ^pointer, # ^2p, PpNpbdP, #string.sub !HDwd, number  %  #string.sub!wwP ^ !Lb .char##char&array ^ number&number >HNppcPP -buffer!wH#&Ndcb!&error, pbHNdlbPP!1#bPS&bH&&pdPbPbPNwb, char!!char#HPHdP& + & ^dgtdNPp#number!Jw! ^Hicv#!&dd, ww wpHbpPc!PpbHw#char 1, number&number ^ number!number#1wPcp!#!cp * 3Hp ^ Hd ^ buffer& ^dp&1c!1!1Pcc  !& wp * char ^ number, NbNN, cb!&&string.sub&#table buffer * wHsct ^ ^wb ^ cQpn#buffer!pointer#1#Hwpwb Nww!PbP ^ ! ^#&dbd# ^ 1W#number 1bbpN!Hb char### #dcwpw, NHN ^ NNcN!wH &1!Pb!pointer ^ number, #pNpcN&cbP#& (&number * number ^number number 8N, cPOPN!Hb ^ char&& &number ^ string.sub + ! {pwbcp !buffer#char&cdN ^ Ab, wc ^ &ppK#PwpNb ^ char ^ & ^table * bH ^ char, wyb, #1#char!!pbPH, dw dHbw#?PpNp&, dc&!bbb!!table!& ^dddNPNw1NchNH##Hd!#HNdp &, HbH1pbbP, !wb!&string.sub NbdHw, string .concat ^ #wp, #SHp#number?1w&table &table ^ pbpwbWbPdNdHPHwdNb .HHwww, memory, number PcP&char, #1&1&, buffer ^ buffer ^ wb ^ &number#pbcpcNPcHw#1 * dH ^ pointer&buffer&:&, #1PPN!pointer!, !1dhb!buffer, wNRNw#string.sub#number!cpb, HdH pointer #wNwc, =, string.sub, 1 !&!&#, #char 1, www ^ wNpdu, char!string.sub&Pc!cdc&1 ^ goto ^ ^array!function 1b!string.sub! # ^& ^H1bbwpww ^ number * 1Hccc ^ pw&number&char cbNw number, ocN&1&Pc#1#1H&#, ^buffer&, table, #number 1PN&!j1bP, !, pointer, & ^^dw#NdNc &number&!table#PP!dN * number ^ wb PNbp!, !string.sub} 1wcc&number!Pbw ^ Hw * id ^ p1dPb!number!, HNdd!bb ^wdwGdbHi ^ NbNbH!&sdbbpHd, math .max, NNNN ^ number#number !number#char&cdNb, buffer, wc ^  number&pccPcbP#&_#char bH, pointer buffer (, &1!Pb!buffer#number!cdpbH ^ Nw1rbw&string.sub&PHcPPNHH!, pointer ^  &wbw#number .NN1Hb, 1c#number#, pointer!pointer ^ Hw ^ number dNHwdP / NcbNPp&number& ^buffer buffer * pointer ^ b1pcbPcXc #PbwdH * buffer ^ char ^  buffer#flag#pPPNP&Nd#buffer!1dNd ^ ^ ^ {PCcpb1bp&#string.sub#1&ddNHp ^ pdw_b ^ wbPL&pcb!Hc&number dN # (&pHbPk!!NH >Hbcw & ^HwP !NN15bb} number!&table!dbd #buffer ^  ww wpyq#number ^ string.sub#PcPpdb !buffer&wH {Npp 1cP&!dbP&!!buffer &&Hw ^ bPpb, FPbp #!##&#dbb ^ ^Nw# ^^Nwp#number#cbHNHN&#table ^number &string .format (^1w, accumulator, number, 1 ^ #dH# window cd&, number, cNcpNP number, !cc &bdcbc ^ number  NcX&cpb##wcN! ^table ^ buffer ^, Hzcpw1bp#!wcc&1&, buffer&buffer ^ bN number, 1Hb&char&!char&1&1d&& ^wHw&NOwcoNP1b&#char!1dwd, ^ ^ ^^1_, number ^ 1 ^ number&#table##table ^ HNbdd buffer&wc_cPc1b#buffer# ^pointer!pointer &, wd Hn number#PNPcpd#&Hc 1 * 1&char ^memory!number 1picpNPNHN!, db &wpw# ^ ppG&number#cb# ^HNdc#buffer ^ &, 1 ^ epwp, char!char ^ 1wHw!dbH&pointer, kbcwN, pPNP ^ # # char ^ #1H& ^bb&number#w1bdNNp 1c&table#&Hpd1wPRbNbw % 1 string.sub&!wPP&number!number * number ^, pointer!nww, 1dh&pcPc&table .insert&number number, char, & pbp ^ pN!NHTHb#&bpd#wwbN ^ ^, ^1 ^ string.sub !table#char&wdb&# ^wbc?1m, 1&1 ^ !!!#Hw&cH ^number ^ char, b21wP1PNi!wP} &!! table#&HwHbN ^ #1pN#cwbNP ^ ! ^pointer ^ & ^Hwc;wN1c#cpcb#1#, pointer&pointer ^ bbdP * w1pbPWc ^ !cb!&handle number#HwMw&9wpcbHPdNp! ^Hb&HHcbcwP, 3bpN ^ 1bPHNd#char&pd, #HHw#, dbdpbNpNw1cbHdpdb, ^wd!ScNHwHPd1pb char&char!bVbd ^ ^, bbPpjb, cHNb#table!char!, table &! #buffer, bbp!number#Qw! ^Hecu#HHw, 4bc )
-- PHASE_BOUNDARY:INIT                         pointer ^ PbwPHc #dPpdP ^buffer# ^, bb!pHo ^ Pw! ^table!Pdd!&1&bdwbbbwpHP&Nq!, Hpcpdw&dd!ddNPNwbNcnNH##Hdcd !db &bpbH1pbbP, !wb!&buffer& ^ ^buffer&, 1, #3 ^ sbPbP ^ ! ^#&pointer#pointer# ^ number, pointer ^, string.sub!, &Ncbc#char!1d } pointer ^ ^ ^ buffer, array, pbP&cNppHHc!pointer& char ^, wbbHN#p1cNcN1bc dPH& ^tdb, ^, number, array ^ Pdc#HqHc#& & ^HwP !NNpwP c1pPHb&!!!Hw * ybcfP ^ PbwPHc #dPpdH#!buffer& ^char o1wHb#Pb#number#Ncb# bPd&, Cbb ^ , 1, string.sub ^ !pointer##dCdc&& ^&, !NbN wbP cwpwHd#table# ^&#&bk!NapbPpQd!!Hc&number!pbfd * Hbw ^ buffer, wNcNp!bH ^ cP 1b!&!buffer -string.sub ), cbPrP!number#HH dd#string.sub ^ number, &9cp, 1bcbc ^ HPH HNbdb, string.sub, & ^dpdC!!Pb!Hb!number# ^Hw ^ ^number&number#number#, &8, !dP, &!!&Hcdcwc ^ 1NLN ^ number!number 1, #bdpd  ^ ^^b1IbpppwN char, #pPddHd&buffer& ^char KbN&cMpc!1!, &number& ^#, wewd, ^NbwPPHp ^ #PP#!1H1bbwA, ^uc ^ !1dN, char ^ !&&#&#table buffer wd, !wbpoP!number, !NHN!#pointer#buffer! ^string.sub , Nbb&PNNp#Pc &&dcb, ^1, buffer, ^pPp pN!pointer! &string.sub&&#dbdd!?number ^ !pblNN ^ pw# ^table& # #&&pointer, Ddw, 1!2&pcPcHc#1 ; ^number!number ^, number, 1wPdNb##&!dp#Pb, ww, dbbp#number!cppP#bdpd  ^ ^^bb?1pppwN !!!#table#&1 ^bN ^ #buffer ^ number!number#1#Pb#number#NH#& buffer!buffer#number#, 1pppNb#number ^ PN#wdPd ^, ^, bc;cpPbsN ^ char ^ #pointer&#&, # )^pw, char  %  &pd, Pc!1 #buffer&  number#table ^ PbNbd ^ buffer, pointer, bc!##1w& ^ rHO ^ bbH ^ number ^ HPpPbc, #wP!dc * HHHwP ^ Nw#, /, !! / !pointer# ^&buffer!Pbdb number, #pNpcb * 1N#pointer# & pointer# ^char ^ cw ^, pH >^cPp#Pb!1db&Nbw ^  2Pa&, ^1 ^ cd###, ch !HP ^ #wbV ^ NN, !PccN#, #, !NH& ^string.sub #, number ^ Nw ^ - ^number ^ 1 #HHcdw 1d#number#accumulator!NpwPb, cb#&HNcp NbP&number * buffer ^ number, 1bp;string.sub!buffer#!table&dH#5 ^ !dP, #2bp ^ 1NN!!char#number&, &, HNd&, string.sub ^ #Nw, NB ^ string.sub ^ ! ^char &Hdcbw ^ 1b# {pPPNP&Nd#&Hbcb Hd!pointer bcbd1PbwcN# % 1H&number 1bb&vww ^ &number!, b7dpbPbPQ&pointer HpwN, PbPwwPwpb!pbp&bd! & ^HdFRpw&string.sub#1bc ^ !NHdH string.sub &pointer table, &string.sub;string.sub#6HcHbP&string.sub!number dH, pointer bE number#PcPcp#1 ^ &table# ^bP&# 1 ^ 1N1QNbwP #number#&! ^dd ^ 5 ^ &number list, NbNczcbP&table ^ dX#table ^ ! ^#, #fbp ^ 1NP##wcb&number& ^bbb * pointer ^ OwNHp PdNp#!char dp#char&number number, number;wp 1bzP!HP ^ table &#bcbc &, &NHpPNNPw#number# ^table, pointer, &char ^ char, number .ew ^ string.sub ^ Pd!#!, PhdpH&buffer# ^1, ^MNpdp cpc&number, &table&&bJb#dH, table ^ PbpOPcdp, number cbd #wcwcb# ^^1HN ^ !Pb#cb#1 * 1dN ^ ww NPN&math .max ^ number ^ !buffer#HPddcbP ^ <dp, ^NbpH, dcc#PH <cpd ^ bb ^ Hddfcppb, number#NH##Hdcd bdPdwbPbH1pbbP, !wb!&string.sub NbdHw, string.sub ^ #wN, &5Hpd1Hbw&table &table + ^ pbpwdtNpF!!1h&ddP # ^!&wf .number&p1b#cHppH!! pointer& char ^, wbFHpNp 1, !lpdH, !string.sub number&, ^ !NPNc1wPbpP#PcndwHy ^ Hd buffer# ^Hp#1b!number!NPbc&!, bpd, number ^ buffer&pp, #NNN!#table&number& pointer, ^char&pointer, cwbwbO ^ Pw! ^table!Pddw&1 ^ ddw, wbwpHP&NB! char&&##1H, pointer pointer, pPp&number, !#!&table&&#table buffer wd, !wbpaP!number, !NHN!#pointer#buffer! ^string.sub, Td < string.sub 1#!number!char# #Nbc ^ ^ NwwNPN ^ string.sub, number, 1c#char&Pd?table ^ buffer ^ wdB#3, wLP!number#!##1& ^dN #pointer ^ SNN&number ^ string.sub ^ PbcHpdHcdP ;Hp ^ ^, bCH ^ dbccP!5bpH ^ ddb#buffer, dK NpwpSwpb#4bddPdwbNw / dHL#NdwdPbbPP&cccHbpbb ^ wb!pc1HVHbpcp&!!Abd ^ Pw#0!bwbXP&cb!#HHcp * PHd ^ bbcc!pcbwCpcwP cP!!HbH!wkWNbHp#1d <dbpcp!&dH#Hwpwb Nww!PccHpHHP#pH#&global&!VBhdN ^ 1bGP!buffer#char&!dN * 1 ^ buffer&number, ^NtwkF&pd!HbHdpdb, ^wd!JHw, string.sub ^ 1&!1!#char &wH& ^string.sub ^ 1, 1 string.sub ^ string.sub ^ P1b#HpHbdd#, & ^ ^^1NP, ^PHP&#versan##! ^dw # ^#wbNpNNp#number !PP&&6!1#, &, ^, buffer ^ JdN#number:Pcb&#!&bdc # ^# ^, ^NbpHNc!opwHNH ^ # pointer} number string.sub&string.sub&? 11Hb&pdw & ^string.sub&bm!Nd11b&pc!cHp&, pointer##table ^ wdb + 1cb&Nw! ^#&pointer#pointer#table& number, NNTNbwwP&!!HbH cb  bw&number, dwHw ^ for&Mb#!HQ&1 string.sub#dwpw {bN#string.sub&cpNP#1H!char! pw % char, bPpwbHP !dbp&table&& &bcw 1C&number ^ 1 ^ number&####table ^ Hbbbb ^ number ^, &pHp#1 ^ 1N#dc, pointer!#&&char char, cwbpCp ^ char!char number, Hb string.sub * buffer ^ number ^ ^1N11pbwp #pc&&#dbb ^ ^number, pointer, ppp&Odcdb!&number!! buffer&Nd ^ wr ^ number&number#number#string.sub&1, &pointer#, buffer!&& char ^ cNc_bPVP ^ #!# ! bwwd, cAw ^ HPpc!!, #char!NdN * number ^ wb PNdN 1 number##number#cH & buffer, &, &object, YcPwP, !, # ddd&, 1, bwNpH, number#1###!cdpd, ^table ^ ^ ^NNNb / 1bmw!&HH&number!!bNwfwb wN&1!cbc pbH &number!number&table #buffer ^ Np ^ bP!char )!1HpPddbbcb, w1sPbwbvNc!0!NHNH ^ # ^Nwc % cNNb, 1, ccP table&&cbPbb # cpb number 1 # !&pointer! 1 ^ bwN ^ cpZpNPNP ^ ### &Ndcbc ^ number  NcM number&ccHPHb##buffer .dcwb, ^, 1 string.sub&!!#1&bdN&cwMwNmND ^ 1#1 cN!cHc&number ^cb} &NcPPP1b#HG!cdb#, &, number&string.sub!1bcb!Nccd } dNbNb ^, #, NNpcPccN#, #, &cH buffer& ^char + number * 1, #Pipc!bb, char #   pointer&number!, 1NbpNNc!_!NHNH ^  #  ^Nwc  %  cNNb, 1, ccP table&&cbPbb # >Fwcpb number 1 # !&pointer! 1 ^ bwN ^ cNb } 1PNP ^ ### dPdcbb ^ 1b&NpN1bdPNpp#pPwdb#number ^ Pd&bc ^ !pcbNc, char, PNc# string.sub&# ^number * Nb ^ number ^ string.sub ^ number cH!cHw&1H# ^string.sub ^ 1, 1 string.sub&string.sub ^ P1b&#dH1dbd, ^ ^^ ^, 1w#string.sub#PP!number!&1d&buffer char, ^1, number wpS, !ccpp! Pwdb#db# char, !Ncpw, pcdb PPc!#!#! ^8, number HN#pd, pointer!pPpP, cp bb! ^&, Hb_N, 1p_p!dPb!number! #math .max ^ dwP, #number! ^wb ^ char = string.sub ^ number&!table number#Hwpwb Nww!Pp!number#dbw&!table#&1d, table ^ #number, wwPH!&1gH, dp#string.sub ^ pointer, buffer ^ number ^  wrPdcP!#table!Pw / &# ^cwNJ >, 61c1bN#pointer# & pointer# ^char ^ cw ^, pdp cpp#PbHc# buffer&dc, x, NNHN, Nc!1c, #, table  pointer &buffer, bb .buffer, NbH? string.sub#number#table##char string.sub, wHw ^ wNNwPPP ^ char, #, !cdcbP ^ + ^xHl&string.sub&1cc, !1#&!, 5 & ^&wcN1Nbp&number ^ !!number &string.sub!cHNdNwNb, BbN&PpP#1 #table&wd# & ^& , NwpdN#char##number&number&&!dbb 1, number, ^string.sub#string.sub number, !, number ^ &!&# #bb, number, number #, number!number#!wPbc, dN&#wcbNjbL ^ 1Pb * 1N#, # & pointer# ^! ^cw ^, pH <^cPp#Pb!1db&Nbw ^  8PM&, ^1 ^ cb!Hbd&char pb, ^ dHEwF, string.sub, 1 !char!&#, #char !, ^, number number&number&string.sub, pb!bcN&table! table#pointer#number# ^cNpN, PHP ^ PNHNdGdb#number ^ &, !NbN wbP cwpwcH#!bpH!; for, dO ^ pb, Pcb!!1!&wb } &cdbdPMwNHp PdNp#table#&&&dcb, ^1w&bdwNT&number&!!HbH cb wdcwbw, number&number ^ number!number#!number#char!  number * char ^ bwbbPNP, -PwpX#!number !##HbHdN #Np, #1wNNp ^ number ^ table ^ #  Hbcww, 1w#string.sub#number!cppP#, &buffer &bN&string.sub, NuP ^ number, bNb!Hpb&!dy * 1 ^ string.sub&pointer, !Ncpw, pcbb * PHc ^ !bH ^ dcdp, bN ^ wPPbc!string.sub!number, !number pointer#wwH, string.sub {cpPwbPwbc#1#, pointer&pointer ^ bcdH, ^wcN bcdc HpH&!pointer pointer&!, Pb!Nb, number - ^Nw! ^#&pointer#pointer#table&&, char * table, cb&bit3c, !!1 ^ char#cb cdcdwb, NDp, PHdb!#cc&pointer#:bY&Owd / ^pp number char#1ccN#number * buffer ^ ^^number wNN&string.sub number&char&number ^ table ^ db * Hdcww ^ 1Ndw ^ 0 .write&string.sub&!&char#&PdNbdb, bbQTp!string.sub, PN!NP#table#pointer! string.sub&, wd HO number#PNPcpd#&Hc 1 * 1&char ^_!number 1p -cpNPNHN!, db &wpw# ^ NHbwP#char&#&char, &, wbd #, #NP1Nb& >pointer!bcb&number& ^buffer#buffer wbb!number * I1b ^ Nd#table#&dKd#HH ^ table PNpwPbd /, string.sub 1bH &#bcbcd# ^ ^1p!Nbc#string.sub ^ HPc #char#pointer ^ 1bbbbw ^ pwP ^ !!pdHc#1 * HHw ^ wdw?Hp&, 0P&1&#ccb!, table, ^pointer ^, x& 1#number&!###! pointer * bd ^ !bbEb, NbHJ string.sub#number#table##char string.sub, wHw ^ wNpNPlPbNw#&&HdP#! ^number, 4, bbwp&PHcPp!HNdcdb#number ^ &, HaP ^ !1NPw! #1PPdb !table!pointer ^ ^ * NP ^ wPHcp!cHPPbd!buffer#Hw, ! pPb Pw!7pHHwH, pointer, wcw& number ^ 1bPHNd#char&pd, #HHw#, dbdpbNPN&1cbHdpdb, ^wd!7ppNbd, wcdP#cp!table#table&&dddwJHp&, yP, !pbp&number buffer&number& dftdNPp#number! )number#vH&&1d#bH&pwwbdNbTcP!!char#wPpdPH &Pd!bPb!pYPN .table!##dPddb&number& ^dpGbN!string.sub&PHNu!, Hpcp number&pointer number bbZpdbPP#!!pwHd## cbNw number, wbp!NNcdc # table# char cb, Rdr pbf#pb!cc &bHc ^ ; ^number, string.sub , cb!1, char, ! &pointer&&pointer, dbwb ^ NNHw 3#string.sub#!#cc&string.sub&, bHb ^ bN = NNwb PbNP#1H!char!# ^wL char, dbPpwbHP !dbp&ddbbPb, wNadbbp 1wiw#count&table! ^#&#bw!, memory {1ppwdcYcN#number# ^pointer#pointer * bN ^ char, cmNp, string.sub, Pcb #&Hc number 1d#wP;dNbpcPcp ! Hd&!Hbbwb, number pcp&1, 1cH&dN#char * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1wb, pxwN&1p, buffer!!#pointer&1&&Hcbcwp # ^H1wb, char, ! &char&&pointer, dc, &NNwcpwNbcdp ^ number&!&pointer&&# ^PwN <dr, S1Pb!string.sub!wPV& db!&table, 1Nep ^ !!char#Hcc#global&string .concat ^ !dXedNPp#number!Lw#!#, ddd ^number!dHe#NdwdNN#PP&HwcHbpbb ^ wb!pbp ^ number ^ char&HbH#& ^ number ^ number ^ ^ ) result pNN#! % !NHNH ^ buffer ^NbcBw, 1bd: ^string.sub&number&table&## PbNwdw, wbpmP!number, !NHN!#pointer#buffer! ^string.sub, yew ^ string.sub 1#!number!cHwH, ; ^ wwwbdpH, dPdpcPNcpdNd ^ ^ ^ ^ ^1pwNbcdp ^ number&!&pointer&&# ^PwNTds, _1cb!string.sub#wH&dp!buffer ^ !wd:1t&, cbccp!, ##PHdwd, buffer, ^ ?cn&number, 11cbc, table ^ table ^ db&&wpw1Xbn, 1wb ^ cbP#&count#char bH, pointer buffer 9, &1!Pb!buffer#number!cdcbP ^ Idp, ^NbpH, dcc#PHacpdd ^ flag ^ &number bit3c, NbNc <cbP&&Qd& 1b#wH pNPwdbbpc!!Hc&number!string.sub wd Pb!wPw!Pf!NpHH#&pointer!pointer&string.sub number, pbppbb!number&!Hb_H, dp#string.sub&& buffer, dbd1PbwcN# + 1H&number& buffer, char, &array, p1PbP, # ^# ^&1H& ^string.sub ^ 1, 1 pwp ^ P1b#table / !cdb#, &, number&string.sub!1bcb!Ncc&char pb, ^ dHad, Np, 1 !char!&&string.sub&1 dbNdp, pbwpb, wcPp&Pcc!dc * number ^, ^, bN ^ #1pN#cwbNP ^ ! ^pointer ^ & ^HwcfwN1e#number#!!#pPP&, buffer ^ &wN pNNpP, PcKbwPHPb !bl ^ 1, string.sub dN&pb, bcHP!char !number!pointer ^ number ^ number, NNq ^ HP + number&!pointer#cH# window#string.sub ^ NwP * number ^ number, wbbJb#!Ht&1 string.sub#dw >wN .NZ ^ 1#1 cNP#& 1H# ^global char, bb, number < number 1&#!Hbdb Ndcwp5HNNp1Pbp&!&HH&PHNbbb ^ number ^, &pbp#1 ^ cN#number# ^pointer pointer bN #, cZNbOp, pb#1Hp&wd&bpHb, ! / dpbp&Nccc#pH, &#!Hbwb, number pcp&1, 1cH&dN#char * wdbwd ^ ^&, &1&string.sub#!number#number&pointer&, &1 ^ 1, string.sub, number ^ 0p PH!char! ^1wdAH#bc ^ number  1b!pN!pointer! table &#bcbc ^ buffer, NdN PpN#1b#char! db&cwewN} HO, (cP!number, !, # ddd&, 1, bwNpH, number#1###!cdpd, ^table ^ ^ ^NNN1Mbbiw!&HH&number!!bNw?wb wN!1bPcc###char ^ & ^ bbH char, cNpp, 1#OH!dHbH ^ dNbpHbwHbPN! Phc, #Hbb&wHcHwdQ wbkNdb Sp!number#PPPd!Hw&#&bC!NspbPpQd!&#bPbdw&Pd  ! dpPpwPN! {pHHP#Nd, wcw& ^^pDY cPcc#cHNd, pointer, bc &kP * cp! <NN ^ char, cc&!#, bdb wb, &number, 1 (1&char&!char&number&1d&& ^number!buffer Npwc >NpN!NP, Hb&&bpb#, NH1cb ^ Jw! ^Hdc?## ^dd number wpHbpPc!Ppb&number& ^ wb& ^ kPb!pcbH;table!pointer&string.sub!##1#!wzwd, ^NbwPPdP ! ##dNdc buffer, number string.sub&string.sub&1, 1c#1#, dwd ^ dN ^ wAPi ^ number, 1, pc!cHP& # ^bHb&number&, cN, p1b&string.sub, Hb& !, table& ^wP # ^1, 11bpNcw! &number&&table ^ ^ ^wbaHNbpb, !!element#PH ^ &1# ^buffer, &_N ^ p1Hb&char&!cH, &1d&& 1n ^, pHI ^ cPp#Pb!1db&Nbw ^ MPI&, ^1 ^ cb!Hbd&char Pb} &pw ^ 0dp#string.sub } Rc, #pP, !dHd ^ _&dZPfwpNP :table#0#&&ddc #wedp4NNPwPd !wPbHHcp bb! ^&, HbOp!string.sub#number#cb# ^HN&#pointer * buffer ^ 8cCcN NNcdc # table# ! cb, fHw ^ 1P #p1P1Hb#Ndw  wPw& ^^NdP <number&char # !NdNb  %  bb &, dw#pcbNc char, HHH&dd #&HwHbPpp, PPPN, 1 Pb& pointer# ^char ^ char #buffer ^ pH ^cPp#Pb!1db&Nbw ^  <number?&, ^number ^ cb#HHb&buffer!! ^rwP, ^Wbw, string.sub, Pb!&#NPpdHd&buffer& ^char ubN&string.sub ^ number ^ char&table#table#& ^&1 ^ buffer ^ ^, ^global&1Hb#number ^ PNHd!, !table&dcbchc, 11Ob ^ !!! char, &, wbd&buffer, #number!pp, PP, !number#dPbd#buffer! ^pdP Nwpd, bc##!HpcPd, bbw&, NbppNbPEP!!Pbc, cbb! ^3wbvpbdp&1b -buffer!wc!!number!Pbw ^ Hw ;pointer ^ pbNPPNP#!cw#1HzHpwb, ! - &pH, 4Pb! HPPH array&number&buffer &bpwN, number, Hcp#1bd&&db#buffer ^ wb! ^char ^ PbwPHc #dPpdN PHbwdw accumulator number#PNPcc &string.sub!#dc Nw } ^, bNpppbb, cwp!Hd!, !table&dcbcBcppb, number#NH#buffer!number&, pointer ^ ^ buffer ^ / ^pbbHpc!pHH&Nd1bbd&number&hHNPRNPH!number! #, di!dbbdpFNbwpb, dPbp!#1!NdpbN ^ pointer&wy!number#, moppppp#buffer& ^!Pbb ^ !pointer!buffer Ebd, number!table#pHcdP!bb ^wdwN!, !math ^ number!NbH!&QdbbpHd, bit3c, NNNN ^ number#number !Nc#&HdNbNb ^ NN <cPw1b#dP ^ !&table&buffer& #, PLNpdp, pb!1H <& ^dc#! ^cwH HplPpN#pMp!&3&dd ^ bb&number, bOcp!1NPb!bpwH ^ dz#3&#, db, Nd ^ wPHcp!cHPPbdw&char ^ 1 ^, memory&0 .read ^ TNcNp, #table#&&&dc ^ 1 ^ 1w& ^^pHp&char?pcPNHb#&buffer#dbwww, number!number ^ Nb!Nc ^ # ^table& table #buffer ^ bNrdw, 1!3&pcPcHc#1 * accumulator ^number!number ^, NbPpP * char ^ # ^!1dbbpbw  string .concat!state#string.sub#1bc ^ !number##! ^dw # ^#wbNNNNp#number !PP&& !1#, &, ^, buffer ^  % dN#P3Pcb&table&&table number, ^Hdp6bprb&1, string.sub ! HHdcd ^ #wwZb#hcNNb * 1, 11Hb!Nddd * buffer ^ <char )
-- PHASE_BOUNDARY:INIT                         cN 2, cdc Hpc##1 cd, & ^cp -pNPHP, Pc&1H, pointer, wdw& , 1bbpN!Hb char### #dcwpw, NHN ^ NNcN#5#bPwd&bH ^ Pd!6NNwb PbNP#1H!char! wd {dbdwNHppbccPNb# Hwcwb!wH ^bHbbb!PGcb#pbd&! cbw&string.sub, ^ number!, (bp, PNPp&buffer ^HPwb, !buffer!, number {wcdNwHH&pdcbPHb, string.sub, 1NbN, number&number ^ !1PPc HbbQw!number, nNpNS#number#!!#pc, pointer!table ^ buffer ^ gNfcpwp, char!char ^ cb&buffer& ^bPb db, buffer ^ Hb!SHcw1bP, !for XH&& pointer ^, string.sub!, &Ncbc#char!1dxd ^ ^ ^ buffer, + b1pb * number ^ ! ^cb&1 string.sub wd number ;Hpcp ^, number!number!cHc&number, ^char !buffer ^, cbccP!WbpH ^ ddb#buffer, dQ NpwpPdpbbNP ce * dbP ^ #, ! wNdb&cpN!Hlc, !dHc&0 pb&buffer!string.sub (PNJH!##dPd#1&string.sub ^ wdpAbN!string.sub&PHNO#pc&&#dbb ^ ^number, cbbNc - &Pbpv#number#, pointer!pointer ^ Hw ^ number dNHwdPhNcbNPp&number& ^buffer buffer * pointer ^ bb ^ &pbN&cN1bHd!number# table <^ buffer& ^string.sub, 11Pcb!bb + table #& number&PwP Pywp number, 1, # char&#char&cwIwNTN , acP&number, ! ^# ^#number * number ^ table ^ bb&Np, #1wNNp ^ number ^ table ^ #  Hbcww, 1w#pPPdcb!cHc! pointer * bd ^ !bb * number ^ bp, 1 !char!&Pw& ^pointer& ^# ^# &wNpd >, char!string.sub&Pc!cdc&1 ^ object ^ ^string .format!? 1b!string.sub! # ^& ^H1bbwpww ^  number * 1Hccc ^ pw&table .insert## cbNw number, N1wd1bp#!Nbw&buffer& ^bPb db, buffer ^ Hb!fHcw1bP, !Ad, number&number&buffer wN, #Pdb#!, cNdH#, &&&number, #number#, eNNcp#NHdPwd&&# ^buffer * pTp ^ ppbP ^ NP! ^char ^ &&##&1 * 1, number number, string.sub ^ pb!#! ^table & table, buffer, ww, dw#1vNccbp, number ! pointer && ^!wb + bNN -cPc!number#gPp& ^ bbH&pointer, cNPpY, pP ^ !buffer#HPddpbH ^ Nw1nbw&string.sub&PHcPPNHN&number  bb&number, ! -, number&string.sub ^ PwNH#dcDd, #bbcdH, ^ ^PpNe, cl!, HHPb number&char&number * array ^ < ^hpdP Np#NHPcP# ^&wwHdbN!p41bcpNd#&HbcbbPdP  bPbd1PbwcN#3bH&number& buffer, char, &9, CcP!number, !, # pointer&pointer&, 1, bwNpH, number#1###!cdpd, ^table ^ ^ ^NNNpwP c1pPHb&!!!bw, Obcbw ^ PbwPHc #dPpdd * 1 ^ number ^ NNd ^ bb PwNwPcdH# ^bHHb, !q9N1bp, dcbPbHNH ^  #  pointer , ^ ^string.sub!string.sub#number#cbHNHN&#table ^ ^, number ^ 1w, 1Np##ccN&buffer& ^bPb bNe, byte string.sub 1#!!!char# !, table& ^wP # ^1, 11bpNcw! &number&&table ^ bd, 3, &user string.sub NNcN#7#buffer!& number * char ^ cwNI positan, pcN cb!cHc&number ^cb&Np, #1wNNp ^ number ^ table ^ #  Hbcww, 1w#1#number!!string.sub! ^table!cO dbww#number ^ ^ number&1!cbc pbHw#char 1, number&number ^ wNbNR, cHc&#&Hc 1 * 1b& ^mHT&1 {YcpN!1c&pointer#Hbbwb , ^, 1PNb ^ char ^ !&&table&#pointer ^ dNwdb, number!number&3cpc!ccb&type& ^buffer!buffer , Nwpd, bc##!HpcPd, bbw&, NbppNbPFP!bPwcdcbb! ^nwbApbdp&1bjb#number&!! #!#dwPww + NpSwHPP!1#bP_d&table&&Pd& pointer ^ ^number, } Pd! 1p&NdP#number&, b8Hbbb!Picb#pbdd <dNbNb ^, #, NN, pS&1N!number&number& ^pointer, buffer, char, cNPpyK ^ cPb #&Hcd, 1 ^ buffer ^ ^AP } % NPdP #string.sub#&cdddH!wP !IbwN, ^2wcwb#number ^ dHH ^ ^Pd#b1w1pbNNPwc HPH&# ^ dwQw&, number XNPN!_!bc&&& ! ^1 ^  dbNpN111b, !&! ^Hb!number# d1wbXpuww:1 cH#char# ^Pwd ^ bu&array, table ^ pointer ^ , number!table#pHcdP!bbHw#eSbPpw_ ^ NH11bw!flag###Pbww, !NcpH, HpNPQHbck * dbP ^ #, ! wpKQ#PccN# #, &##db, #, Nbwpbp ^ cPc 1bHb!Hb!&Hwwbb ^ Bb, number #&#&char #NH# ^db#3 wNbHl, string.sub&pwH###HadNwpTNNd ^ wb&string.sub#!bPp&string.sub!string.sub * buffer ^ ^dP, ^number ^ string.sub&positan#p1PbHwH, pointer, ^ 1w, ^number string.sub number, char, #wHd##buffer / dcwb -- BUFFER OP, ^, 1 string.sub&!!#1&bdN&char ^ string.sub, table >NN11bN&char&#HHP#number * bHd ^ ^number&NbN#, bP char#HcHc!#table, ^table ^ number ^ #, 1N1cbPN#wH  number &pointer ^ wdNqN&string.sub number 1N#number& * &bH&buffer&number!0b  ^bbwpc!1!, &&& ^ char&Hw ^ ^char ), wbPdP #string.sub#&cdddH!wP !IbwN, ^Vwc ^ !&&#&##&table, dc, Hwcp& char!string.sub ^ number#Pbdc&char&number, nTN, 1H, bc#PcHd!table .insert (H_ ^ pointer, bpN math .max number#pcPN!Ndbd ^ buffer ^ ^ ^NQ&number 1&number&1 ^ # ^&bdH&char ^ wbbgd ^ ^, &number&char&number#HP&number pointer, 1, 1NpNw, JP !pointer#!PHdbbpbwdj, Ndp!, Hcb#string.sub#wcBd * bHwcw ^  wpjb&Pbc##HPp& ^table buffer& ^char abpbp ^ number ^ char cN&pointer&   buffer&ddbNN11pbwN  %  ! HHdcd ^ #number ^ ^, Ybxw#, bpS!Ppw&Hdp * char ^ number&buffer, wN#pNbcc!pqHp!#dHb#number {dP_Lw ^, !rHp1pHHpdb!db& ^bdb ^ 1b!0 PdNdHPHwdNblHHwww, -, number PcP&char, #1&1&, buffer ^ buffer ^ wb ^ &ppp1PbP, #number# ^&1H# ^( char, bb, number char number 1&#!Hbdb NdcwcgpN, string.sub#, HcdPN#, table char &wpw1hdNN, pPpNw#bPwdP#&&cd!, cyNp, string.sub, NNp##&&HdP#! ^number, x, bbwp&number!!1! 1b& dw#wwfb# ^^number#, bjp!buffer#!table&dH#4 ^ pw, cc&pd, PcHb ^ # table# number * char ^ pointer, 1, ^NNbp, buffer!N1PHb#Nd HHw!number#number <Nc, !number!ppHZcpdd# ^&&dd, &Mc111bNcp PN&PHN, &, Pb&wbwHPd!1! ^HNdp!bb# char * number ^, pKb, cHNbH:!cdbHG ^ <pointer?, dN * wpb ^ string.sub !&Pc!NHNbbb ^, ! Nb&1 char !&char ^ & ^ bbH char, cNpp, 1#uH!dHbH ^ dNbpHbwwbPpb, EPcNb!cPH&cH1bPwb, bbIpHJ&NppPPPPP&number, table!wc, HbH, yNpp##pb!dDdd ^ ^bdPIbN!number!x ^ pwPc& (cP * wbH ^, dbppNbP} number!bPw!1!buffer#string.sub ^ bw!, &NHwAbbc #PbH&rHNH dN * string.sub ^ Pw#wHPp!1pdH&&buffer!buffer&1 Po .bPpwbHP !dbp&number#  &bcw 1w#1#Nccwc, #, table  & &buffer, bbsw <, 1!3 string.sub#!&char, pointer ^ table& ^number ^ char, b3b, &number#Pb!1!, &number& ^ 1d#, zone ^ cNbw, user string.sub ! char&&!dbbb ^ NbcxppH1NPb!1P&table&dH * PdNwbw ^ } ^number&PbP#char ^ cb&number& ^ ^buffer&, #, #count ^ rNPdp, #!number&!cHcbc 1, global, ^string.sub!string.sub number, cbHpH & ^ ^d1wb + pKw, 1 cH#char# ^Pw table&# ^cwN * bit3c, > 1c1bN#pointer# & pointer# ^char ^ cw ^, pdp cpp#PbHc# buffer&dc, key, NNHN, Nc!1c, #, table  pointer &buffer, bbGb, NbHn string.sub#number#table##char string.sub, wHw ^ wNpNPgPbNw#&&! 1  Hb, string.sub, 1NbN, number&number ^ !1c&&dd1bbb ^, ^Nb  %  #cabc#bP, ! table buffer  &, !l1pbbNpc!cHP&0 .read!string.sub ^ ^pointer, # ^Wp, PpNpbbcb#number bHJwd, number (#string.sub!wwP ^ !Lbn&table#dH, &cd, PNwpHb cdpp#number& ^ !#dwPbbb ^ number, PNPpbpdHPdc!bb ^wdwN!, HEb - !# + #dH ^ db#number ^ ! ^, ;#1Nbcc&1s#&! ^pointer#HPwpwb  %  dNN, pPpNw#bPwdP#&&cd!, cONp, string.sub, NNp#1 ^ & ># ^ char&#wwbc ^, wPb ^ string.sub ^ 1!char#&table # ^object&Pw, ^ ^pp, HPHNH#string.sub&1cd * 1db ^, ^ ^&, &PPPc!char#1!&pointer ^  1 ^ NwN ^ cNcbPPMp ^ #!char dp#char&number number, number ^, Nbp&cpc#number HHdw #buffer&number&buffer, x, pwbdp##pPg&1&, buffer&buffer ^  pfNz ^ 1 * 1 * number ^ PcHw#1 * dH ^ pointer&buffer&key&, #1PPN!pointer!, !1dnb!buffer, wNfNw#string.sub#number!cpb, #, &buffer &bN&string.sub, number ^  number&pcP, cb##Pw&#table bcdp / RlNpHp, number !vbb&pointer!bbp&# 1bPNbN, number ^ number ^ string.sub, Pcc dw& ^1 cKbwb, ^ )pc number cP#char ! ^cww * pA ^, PLN!!!1!&table .insert number#table ^ NbN, ^ ^, number#!string.sub!1Hb&NH#buffer ^Nw  11bcpcwP &number#&buffer + &1d, buffer, math ^1dP## } #char!&pointer&bH ^ Pd!SNNwb PbNP#1H!char! wdKd&dwNHppbccPNbHPH ^ dw &buffer, number !NcpH, HpPHpc#dp!! ^array ^ dw ^ ;buffer ^ Pb!number ^ char !#&number&char number, number!number ^ wbpbp ^ cPc 1bHb!Hb!&Hwwbb ^ VPmN&string.sub, Hd!, !table&dcbc;char, 11Kb ^ !!! char, &bbpb ^ ^, ^w1p1PpPwb table!table#pointer# 1 ^ ^wN, # ^Hw, number#!##!&string.sub& ^ !Hxwd, wN#number ^ 7&number&!!HbH cbbpb1wbw, number&number ^ 1bNPp cb&1 string.sub number&3w ;dN!wHPb!string.sub!wPc&  db!&table, 1NpNw, _P !pointer#!PHd1bpbwdc, Ndp!, Hcb#string.sub#wcad * bHwcw ^  wN ^ 1B:;!pPHcc#7!number ^ Hwp, cNP ^ bb PwNwHx!table# ^table&& ^dp?bN!string.sub&PHNs!, Hpcp# &number global, !bQpdbPP#!!pwH ^ df#function&& NbwNP ^ wPHcp!cHPPbd  wHw # ^<wbbp, buffer!!#sHbdp!dbbwcw, + 1pPwwcup!#table!NdpbN ^ pointer&number, dw#, _nppfpp#buffer& ^!Pbb ^ !pointer!7p, ( .cNfNP#wHH&  dHpwN, PbPpZ
-- PHASE_BOUNDARY:INIT                         bN&NbH!&mdbbpHdwb ^ 1NNN ^ number#number 1, Hp! ^ ! # ^#wbNNNNp#number !!!#Hw!1#, bN #, HwNpbp ^ cPc cN&string.sub&   buffer#, !, cT PHp ^ #PP#!1H1bb Nww, pPp&number ^ char ^ #pointer&#&, #Qb, wp * pvwbbNNN ^ piHd&Pd#buffer!Hw, number, cNcpNP number, !char#&&&dc ^ 1 ^ 1w& ^, number ^ string.sub&cHc#number table * dHbcb ^ &number .PzcpcbNc char, #char!, ^ pointer, number ^ &pV, 1 (, string.sub, !, char ^ &dd# ^array ^ cb& )&pHbPF!!NH  %  Hbcw & ^!, 1, bbp 1wN 1#char!! ^db#bw!, WObppwdP!!char#wPpd -table &cdw * buffer ^ ^, number, pPb! ^1P&1d!#!& ^id ^ cNPwPPwcH! Hdcp table & ^&wcK, Nbp&1 ^ char ^ !&&#&#pointer ^ dbwbw ^ state ^ number&PHP#char ^ cN&pointer#, buffer!&& char ^ cNc81PeP ^ #!# !, db ^ string.sub ^  number ^ string .concat ^, 11bcpcwP &string.sub#& #bbw ^, NNdN PpP&pd#dc! PH! ^buffer * Nb ^ ^wp ^ 1&!#!#number&char, pointer&, number! & ^char, c1cpb!table .insert! ^&!& table, bb, string.sub, * ^string.sub ^ N1cb#string.sub#number! pointer * bHwcw ^  wpPpcPccN# #, &cd&buffer& ^cj1GbN&table, cHc&#&Hc number 1b& ^ !number 1pycpNPNHN!, db &wpw# ^ number 1dP!NH#1&string.sub&number#4b wd, !bHpbPAc ^ !cb!&buffer& ^ ^buffer&, 1, #function ^ e1b NdHN#&&&dc ^ 1 ^ 1w&bwp!1#cXp!#HP, ## # ^!wp number -, pbP&cNppHN&number!Pb!dw &buffer ^ ^pbbP!char&#HPf&buffer  ^number&table > 7wNw EVNpbNP#PHdpbbHdw&, bbbpwc!string.sub 1#number, cD * dbP ^ #, ! wp9b&Pbc##HPpdP#db#pointer!, ^pbN, wcdb&HPHcdc * number ^  ^ cw pbbccc!NH, table, dc&&wpb#CwwN, ^number ^ char ^ number HH&char wbb # <pG1pbp, char&char ^ #1!&dd * 1 ^ 1 ^, < ^ ^pbN#! % PcHbc, # & ^ buffer&string .concat!N11bPNbc#buffer!1dNd ^ ^ ^ buffer, table .insert ^, ^number!number#!##1dNdN #pointer, !, #Nw, 1 {, cNP#Hb#number * buffer ^wPw * wNN ^ string.sub number char#table!Hc& table, ^table ^YP ^ #, 1N1cbPN#wH  number &pointer ^, Hb!number&pcP, c1bHH#&1bNbNdbb NP, &P3Nbp, number, table, # ^ db#, math .max, cw&1zN#cc!NH table, 1Hdw&buffer#kN ^ w1bb ^ !number! Pb&buffer#table ^ !dH, number ^ 1w, =YP, char table&table&! HN&#wd ^ #pc, NPHN, 1&1wd!table#& > number, pNNpdwwP&1##bcpdp#pbbw ^  PNb, ^PHN#11cb&number& buffer ^ bbx#temp ^ 1db string.sub, !, Hw&dH# ^< char, bb, number buffer number 1&#!Hbdb * Ndcwb ^ 1NNN ^ number#number #number#char&bdb&&wpwbGdNN, pPpNw#bPwdP#&&cd!, !buffer, wcPtpc!bb, char #   pointer&number!, 1NbpNNc!handle!NHNH ^  #  ^number pb&, NpwcPc ^ !, table, #char * char ^ PwAb ^ NPp ^ 1#number !bb!&string.sub!number &&pointer, &buffer!Nb, pPwNw#PPd&, Hcb!wc, wbppP? NPp!number!number!dAbNHHw#, dbd, pNPp&!wbHdpdb, ^wd!LcNHwHPdbjP#char <char!bhbd ^ ^, bbPpdp number char#HNHc& &number ^ pointer ^, > 1cbcP char, #, table  pointer &buffer, bbTb, NbH {string.sub#number#table##char string.sub, wHw ^ wNpNbwc !1bP&1d!#! ^HbOb&bwbHPpcc#P1bdpd1bbb , ^NbA&cpcb#1#, pointer ^ pointer ^ bb ^ #, #h11pbNP#1 HP!& sHb&  number ^ pdb#!state!cc&&& ! ^1 ^ dbNpN111b, !&! ^Hb#& db1wbw, number ^ number ^ 1bp##} cc&buffer!, table pointer * number ^ number!pbPbcNPcHcdP * OHp ^ ^, bGH ^ dbccp!, ##PHd# dHdwb ^ pwNwpPbc!!&HHcjd, bp&, &Nb, Nb!qh!pointer#PH#pointer!!number ^ ! ^, ngF * number ^ number!RH!##dPd#number&number ^ HdpQbN!string.sub&PHNe#pc&!pHb ^ char ^ buffer, 1hbN wbPwb!1 cccd * number ^ char&buffer, 3w ^ wX#pH!bb!dTdd ^ ^bdP7bN!number!PHpwPcPwcP * wbH ^, dbpNw? number&1c#char&pd, #HHw#, pointer ^ #, NcPp&!wbHdpdb, ^wd!gppNbd, wc&number#cN!table#table& dddwhHp&, yP, !pbpc& buffer&number ^ !deZdNPp#number!fw#&char#dbHN * wwPw ^ number, .cPc!number#mc ^ &&table ^1 char, pNHpN11c1b&#&&HdP&number ^ Nwwh N1wPb * string.sub ^ #cc#&# !bp&Pw, lwNdwbP#!PHNH&cd &bb&bb!wPpd, Pcw!table# &pointer!pbN ^ PdPQ!wwMbu ^ Np#bH!&& HHi ^ buffer, NP ^ H1bpNpwP#cp#cH1HHwpGbbdp&1bMb!wc!!1!Pbw ^ Hw ?pointer ^ pbPN pNbbc &table wb# ^&, & ^, number, 1wPdb#Hpcn * 3HRb ^ pointer& ^N4w1Pb ^ number, !, cc&char Pb;pointer ^ number ^ odp#string.sub, Ed!!1P&number!number * NH ^  char, cNPpg, pP ^ !dH#table, ! =, ^pd, buffer&pb / NP!number;#dHP&# !#number ^ pointer, &Np ^ !1NN, pdb, char * # (HpH!wmQNbHp#1d -pointer!bcp!;!pbb ^ !number&3H ^ Wp&number&cH!1&1&NHcbpwH, N_1pb - &number&!table#number!NdwH, bw ^ &, cj#, 1Hcw!##&&&# ^wwd ^ #number#1PcNc&pd&string.sub#1 * string.sub ^ ^&number ^, number, 1wPdNb##&!dp#Pb, ww, dbbpwNccdp, number crd * bd ^ !dHBb, NbHy string.sub#number#table##char string.sub, wHw ^ wNNwPPP ^ char, #, !cdcbP ^ result ^ -Pw, PNc!#!wHc&wd ^ # (ww -bHb )^number#wbP!!#pwH ^ dj#string .concat ^ string.sub dbPbH1pbbP, !wb!&cdH#HdbbL ^ #Nbw!cacd! ^HbcP 1b!&!, Hwj, ckNEP!number#HH dd#string.sub ^ dwbDPB, pNPdgb! #wPw#pointer&table ^ bd!NfNdp ^ PbNP#dPHdH#HbcdNb&math .max!pbbcP#!#number ^ table ^ db * Hdcwb ^ 1 ^ &, PNb!1#pHw&& string.sub#bw!, dNbN&9cPc!string.sub#, table#cH ddNd#bpwNpNPJPbNw#&&! 1  Hbw, wbwbRN#string.sub ^ 1dbbd! rbbwpddNp, 11pb ^ char&! char, &, buffer ^ &wN pm, 1dPc#char#1!#pointer#buffer! ^pdP Nwpd, bc##number&number&&!db& ^bdbuw, PQ * NPNdHPHwdNbaHHwP ^ Ng 1 cH#char# ^Pwd ^ bf& ^ HNdw, 1P, number!table#pHcdP!bbHw#iKbPN, handle ^ Nd1Nbwc, !, #Pbww, !NcpH, HcdPpP ca * dbP ^ #, ! wp&math#c1bN!number&number& ^pointer, buffer, char, cNPp_g ^ number&1 Hb!cdpbH ^ Nw1fbw&string.sub&PHcPPNHN&number  bb&number ^^string.sub& % #number#!!#pPP&, wbd&buffer, #number!pp, Pc!1 ^ Hpc##1#table ^ 1, string.sub, number ^ 5bPN&!G1bP, !, pointer, & ^^dw#NeNc / &char&!HHPH, dH#string.sub ^ buffer, Sl&state 1 cH#char# ^Pw string .format&#dLbNN1NdbNPdc&pdHb#number#&&1&table, pNb ^ db&PbNbPc!!dd#number ^ wwH, NdwpPNcPpPH!!bHbHb&string.sub, buffer <!number&1H / rcbP&table##1 * 1 ^ Xw ^, cb!pcbHNcp, &string.sub!#db#!number:wd, ^NbwPPVc, #Hbb&#HcH, pointer! ! ^&wHwbP!!#pwH ^ dS#handle&#, db, NP ^ wPHcp!cHPPb #&cwN bppp * 1 ^ char ^ P1Hbdpdw& ^ buffer&NN, 1b / char!char, #number&number## # ^!wpb, 0, pbP&cNpp#&!  1&char ^ char, Ph; ^pp ^ PbcHpdHcdp, buffer#&table, #Md ^ d_Ppp!Hbp&bd! & ^HdJ NpwpPPpbPNP char <  dbP ^ #, ! wNdb&cpN!#Nc, !bHc&; 1bNb!string.sub;PNfH!##dPddb&PdNdpjbN!string.sub&PHNM#pc&char, #pointer&& ^!, bBcN#1#number ^ char ^ #bHH#cbfHwww wv number#0 .read, Pb#string.sub# table ^ pointer ^ &1 ^ 1, string.sub, ww string.sub PH!char! ^1wdP#string.sub ^ pdpw, buffer, 111cpcwb;table * dHbcb ^ &number, ^New ^  !db, HPPw * Hbp ^ char, number bNHb#char?NP!, char ^ !table# ^Hwdwb
-- PHASE_BOUNDARY:INIT                         bPNwb } !!char#HPHdd& + &wdG -dNPp#number!4w!#char#&!dN ^ Nb, bbTrp!string.sub, PN!NP#table#pointer! string.sub&, wbb ^ LbN#11Pcb&#!&bdc # ^# ^, ^NbpHNccc#pH, &#!table ^ table .insert number, table, number#string.sub&number ^ char ^ #bHHcd * char ^ Pwz * po ^ pbbH <pointer!bcb&table! ^table&Hww&hHNPw!Pdp, #!number&!cHcbc 1, 3, ^string.sub!string.sub number, char, #wHdcb # ^number, number, &bdp&1b / buffer!number&!! #pointer#dwPwwsNpBwHPd1Nbdc * pointer ^  Pb wP, 1bPp!JwNbp ^ 1pHbd ^ #number ^ 1w! !NH_SldJw#HHp&char number#buffer ^  ww wps (HNPN!HoHd& ^ bHPwb, !buffer!pHNTpc1NbP&wdH  ^ddp?dN11Pb, cN#dbb& dw#wddrH ^ ^ppwbc!!:#1&pcdbKHwww wZ number#0, Pb#string.sub# table ^ pointer ^ &1 ^ 1, string.sub, ww 1pN&number, 1dc&pointer& table ^ number ^ HbppbP .char&char, number table * dHbcb ^ &whP ^ pbpYpP, string.sub cb&1 string.sub number&nw = Hpcp ^, wc ^ # / Pg!&HHbw&table  %  pWbN, 1wn!!wP, Hw&& cb#, NH1cb ^ Rw!#char#&!dN ^ Nb, bb } 1pppwT + char #dH!cH * 1 ^ 2w ^, cb!pcbHaHp, cV!#db#!wAwd, ^NbwPPbc!1bPw mHcbd&number, wxHN 1d } string.sub!pointer#1&number&, number ^ pointer&buffer, uw ^ wZc!Hb ^ HpPb !bu ^ 1, string.sub dpclbP, string.sub ^ !pointer&5&&pointer buffer  number, NN (Nb;&Pcb##, !number * Nbv ^ bw#xFbdbPPH!number!#cb&1 * 2b ^ ^cd!NNw, 1 number&char&#HHPc! Nbww, 1bPpCB ^ number 1###&!dp#Pb, ww, dbbpwNccdp, number char:pointer * bd ^ !dHyb, NbHO string.sub#number#table##char string.sub, wHw ^ wNpNbwc !1bP&char# ^  buffer#, number, cNwN, PcP ^ PbHbH ^  1  &bwbbHp!, HP ^ p1b, cn&, pointer ^ ^   ^NpbPpPwpR# &dd!#table ^ 1, string.sub, number ^ {string.sub Pdc!pHHTd!pointer, bNwNb#5#string.sub!1pN, char, #buffer&&dN#string.sub ^ Pw ^, #positan pb, !cHpw# cd &table! ^ string.sub = ww ^ 1Hb&char&!cH, &1d&&, wiw&memory&NcP1Pbc&number ^ &!# bp&char * number ^ NNN 1bP&#string.sub##! ! # ^#wbf ^ NNp#number ^ cw!#table#&1bNbN ^ #buffer NP, &PENbp, number, table, # ^ db#, string, cw&1nN#cc!NH table, HbbN number, pointer, number string.sub#cccc! char, ddd ^pd#bbEc, 1#pc#function#number&table&, &char ^ number ^ , element 1db&number, PbHb#number HH pointer#buffer#handle#, c1pb, !table! ^!Ndb#db ^ ^ Fb?#wbb number##char#cc##, bHd ^, Pb#w1Q1P1bN!number# dPd&& ^wPb global&Ncb, Pb#Nbw&1# char&string.sub, element, NNHN, %:chpbHdcb pH#db Pv1f, 1 ^ 1 ^ number, 1cP &wH buffer, dc, buffer ^ 1w ^, pcdb PP!cd!bc ^ wdp, ^number 1 / window!char!string.sub!HidN!table ^ + number, bb number# % #cpcb#1HN##bcbNwww, w1p1PpPwb HP!& (Hb&  number ^ pdb#! (!cc&dgH#bc ^ number , pHp&ctc#number ^ &!&# wbcd!, ! ^(pbT -pcHp )^number&cdddHb&&, number ^ &string.sub ), 1a, string.sub, !, char ^ &dd# ^/ ^cb&NPNcbcPN! !, Hc!!# ^dcwchPN*wpb ^ cb!Hbd&char pb, ^ dHM#NdwdPbbPP&cc!pointer!number ^ Hwp, cNP ^ bb PwNwP#cd number&1 ^ HdpabN!string.sub&PHNI!bH dP!HbP * number ^ ^:wp} NNdNH#string.sub&1cd &bb&bbc ^ pointer, dPj -pointer#number#number&number count#table ^ pointer, 1, ^NNbp, bcHPc&#table, pointer, number&number& , 11dcbc ^ #number&pcb * Pd1wd8bi ^ pNPp_b!wccd&bN&char ^ pbbowwkX pNbdc&! pointer >&cbwdnX&pNw!number Pcc # &!dp &wp ^, bpN19b !string.sub! ^table&&number!wbd&ww ^ buffer#p3b&Pbc##HPp& ^table ^array ^ char, cub, #PPP ^ #pH&&bdw#! ^number ^ ^buffer&for number, 1, number 1H#&table, H1bbwpwwbbNcp * cXc ^ HcH ^ dH Pb, Pb, Aw1bPpP ^ #number#, &  GHr ^ number element ^bbPAccw##HN&char !Hn ^  buffer&?wN11bPNc, ! char#&&pointer ^ buffer ^ ^ buffer!_#number ^ N1cdb ^ # ^&bdH&cw ^ pointer, ^ NHb#cSNP#&char ^ !##Hb# ^1upgNNwb, 5!!dP, &!!&HcdcwbScK, pbPPmw!&char#&PdNbdb, bbe#NdwdPccN#NH#&cH dNd * bO ^ & ^bP!cJ!1HpPddb * number ^  pointer, buffer& / ZNcc!KbpHNH ^, Nbc6cppb, number#NH#pointer#, pointer&# ^&# ^&buffer, p111GeP, char table&table&, &1 ^ 1, string.sub, ww string.sub&1#Nc! number&!cd#& ^wpb#type#string.sub!1pN, !pointer! table &#bNbc ^  ^NK&wHbbNH!PPP&!! ^&char ^ string.sub, HRNN11bN&char&#HHP#number * table ^ number ^  number, Nr ^ d1wpb!number! ^&#& bPbcww, 1w&1p1bcb!NPp&string.sub!wbb&number, !buffer&wc, !PccN#, #, !number##buffer!wb, char - #string.sub# + ^number ^ !buffer#table!cdcbp ^, number# HNd11b ^ cN#p1bdWHcbbb , ^string.sub!string.sub#cSccP &number&char wbbdP, number ^ tpwX -cHp number#cHd# 1wNwNbb ^ &string.sub Pdc!pHHbdv ^bc&!, c_H ^ H1bcb!wbq&!&# #bbw ^, Ni#1PbwcN#;1H&bHNbH&  # ^#number#1PcNc&pdHw#1 * number ^number * number ^, number, 1wPdb###&!dp#Pb, ww, dbbp#PP!number!&1d&&db#buffer ^ wbP ^  number!sNRj!pointer#PH#pointer!!wb ^ wc < ^table, pNDcPNwHH&pdcbPHbwwg#NNpcP!number )#pPH&char#Pb&dl bbpH:#cpcb#1#, pointer&pointer ^ bb &, dY1pbp, char ^ char ^ #1!# 5&char ^ bd, buffer number string.sub number&char!!1Hb&NHc ^ versan ^ number, number, ^string.sub#string.sub PNb##HHNdNd ^ ^ ^, NwcpwNbcdp ^ number&!&pointer&&# ^PwN -dj, K1PdbN!, # dcd&& ^^ buffer NPNcbcPN!, !, Hc#&bPbcwbbN ^ ^number, NccNb, HdH  string.sub &pointer, number, &number&pccPcb!&char ^ pointer!table ^pdcbNwNpN;, Pbc&HpH## buffer!&Pw#, 1N ^ pNj!cc!NH, table, #number&&wpb#AwwN, ^number ^ char ^ number HH&char wbb #, wwcpbp, char&char ^ HNcH #&cb, dbhd > 1pb&Nd!dP!dP#!bbdN ^bwN ^ string.sub&char#char#1&number, !char Hdc, 1, number!number ^ table .insert#_b#Pcccw#, buffer =^ table bN#_cPdpX# -number <&pointer  Hpwdb number!wcCNpN!buffer! ^table ^ & &number ^ char ^  2Hn&, ^1 ^ cb!Hcc&wHbbd& ^ & ^&number&count#PPcN#pointer#, #1 * ddN ^, number NcN&PpPb!pointer#number!# zone * number ^ table ^, buffer / NswbPdNb -- BUFFER OP#pP#!1#PbP& ^ 1gw, 1bd <^string.sub&number&table&## PbNwdw, wbpwp, number, char HcH&&, HK&# , Nbb&PNNp#NHPcP !& ^ 1 * number ^ table ^ HPpPbc, #wP!dbd ^ buffer ^ ^ 7b - #number ^ NbcPc ^ # ^table& # #buffer ^ bNldw, 1!state&pcPcHc#1 } ^number!number ^, pdp number char#HNHc& &number ^ pointer ^  } #1cbcP char, #, table  pointer &buffer, bbkb, NbHv string.sub#number#table##char string.sub, wHw ^ wNpbp ^ number ^ char&HbH#& ^&1 ^ buffer ^ ^, ^object&1#1#number ^ !NHNH ^  buffer  ^Nbchw, 1bdK ^ string.sub&number&table&## PbNwdw, wbpwp, number, char HcH&&, &char ^ number ^ , global 1&1&number, !1HbH, number ^ ^1b#Nv, cbbS, string.sub number table #& !bbwb, Nwc1RbNcNc ^ table#table dN&#wqwNfNM ^ 1 * 1 cN!cHc&NbF, ^cb&Np, #1wNNp ^ number ^ table ^ #  Hbcww, 1w#1pkjcbc, table&table ^ #pbNb ^ ^ ^kcPw1b#dP ^ !&table&buffer& #, P_Npdp, pb!number!, table, & bcb& ^, ^cN!number, 1, number #&#&table, H1bbwa, ^ec ^ !1HcNc !, &ocd buffer&pwPb ^ Jwp ^ number!8d!!cbcb!wHbHwwHV& ^Jp, PpNp!wcb!char!pointer ^ number ^ number, NNL ^ Hb#PdNd#!!string.sub!, #string.sub ^ bw!, &NHwdPpp&!##1& ^dN&char ^ HbbDbm ^ string.sub ^ 1&!#!## ^#number * buffer ^wP & ^cN#2 ^ Pwb#HpHbdd Nd#wH, NNNN ^ PbP !Ncc&wHbbd& ^ & ^&number& + #PPcN#pointer#, #1 * 1 ^ )number ^, cb!pcbHhH!number&string.sub!##char#!number .wd, ^NbwPPbcc#!HN&1 buffer#number ^ ^, GbzwdPdN, cwpw&Hdp * char ^ number&bQpJ1pbp, char&char ^ #1!& ^ ^cd&, string.sub ^ #Nw, Nv ^ string.sub ^ ! ^char &Hdcbw ^ 1b#xPpd1bPc!cP table dd !dbwww, buffer, number PcP&char, #1&1&, buffer ^ buffer ^ wb ^ &number#pbcpcNPc&cdPb?buffer wPdwNHpbPcP 1###&number number &Hd, {, NNNN ^ number#number !Nc#pointer bb&#wibc_b ^ number char number&table!&1 bbN char, cNPpG, pP ^ !buffer#HPddcbp ^, number# HN#pd, dc!PPc&char, #buffer#wwH, pRcpPwbcPc ^ #wH&& bPH!wc, HbHwwNXchp Hd&Pd#buffer!Hw, 0 .write ^ #NcpNP number, #table#&pointer * pointer#HH ^ table PNpwPbdT, string.sub 1bH &#bcbcd# ^NH, ^PPN#11cb&1HN wb, number, &number ^ pdcXc&! table #number * number ^ string ^ bb&NPNcbcPN! !, Hc&& &bc, 1, 1e& PHP&!&#cdPdb &pointer ^, ! ^ pp, cNNbN#Nc, &bd& ^string.sub ^ #buffer number pdP!cN!dbP&number * pb ^number ^, ^Ndb#1, NX#pc&&#dbb ^ ^number, pointer, ppp&Zdcdb!&number!! buffer&Nd ^ w_ ^ number&number#number#string.sub&1, &pointer#, buffer!&& char ^ cNcObPCP ^ #!# !, pointer, bw ^ ddb:#string.sub!1pFPc, #wHdcb # ^!wp PV, pwbdhb!#HPdNd&#pointer ^ &wb bNw + !number string.sub!P1Pedd Pb#number!dwA ^ pX} NHbN& (!cdd#number ^ wwH, Ndwpbwc ^ #!1d&!Hb&rd# number ^ !wbwdPP!cpbH &number!number&#ddbwNp ^ bP!char !1HpPdd& buffer&number, string.sub, 1NbN, number&number ^ !1&pointer!, pointer ^  &wHw#buffer&pdbPP#!!pw&string.sub## number&Nd ^ buffer ^ ? ^pdP#number, pFHP!&pointer# 1wNwN ^ cNcbPP / string.sub ^ !pointer&positan&&pointer buffer  number, NNRNb )&char !&#1H#dH#pbwdd, buffer ^ !pbNNcbc ^ # ^table& 1 #buffer ^ bbLb >^string.sub ^ 1&!#!## ^&number * number ^wbw 9N, c1wpb!db ^ char&#& &pointer#wP, NNdN, Nbcwc, #, table  char &buffer, bcywS, string.sub, 1 !&!&#, &1 * 1, www ^ > 1, #number / pc!bb, char #   pointer&number!, 1NbpNNc!0!NHNH ^  #  ^Nb#NDNN1Nb ^ ! ! HN&char cbN, Qw, Xc, &Ppp#!wPNc ^ # ^ ^pointer wH, cNwpbN#!pb + HbH, & ^dp, number, ^string.sub string.sub ) ^1c#number!1dd# ^&& &, &number#pPbNcdc, cb&PHN, buffer, &, &number ^ 1_N !number!cH!&1 * string.sub ^ NwddwC&, #1!NNp ^ 1wH ^ &&bHb#wPAcbbpdNcc!1pPHdrdNbNb, b1ibpppwN !!!#table#&1 ^bN ^ #buffer ^ >number, #number .pc!bb, char #   pointer&number!, 1NbpNNccbPbHNH ^  #  wPwcObNb, PPPp (#wcad!# &#dH, #v11N1NNbp&HP!& 0Hb&  number ^ pdb#! !cc&pointer >table#bc ^ number  1bPpN!pointer! table &#bcbc ^  buffer, NdN PpN#1b#char! dd&cwMwNgHI, .cPPP, !, # ddd&, 1, uN!number, 1NcNb###&!dpH, buffer, wb (&NNwpPPc ^ !## &buffer!!bp&number, + bdp:_cc = cN#number# ^pointer#pointer bN #mfzNpNp ^ char char #NHcdc*Nw ^ cw&1pN#cwbNP ^ ! ^pointer ^ & ^Hwc4wN1c#cpcb#1#, pointer&pointer ^ bb &lpi1pbp, char ^ char ^ #1H#pointer# 1wpwN, #number 1PN&!31bP, !, pointer, & ^^dw#NsNch&cPcc#cHNd pointer, bc  5P <cpcbNc, char, #cH&pointer& cwPwb, &number ^ 1!number !pbccN#number number&, ^bw&NpN#array char!pP##Hbd ^  number&!wc, NN, number, .Np&#pc#&number#NH ^ pointer ^ number ^ ^ NHpcPwcbP#HH#char 1, number ^ number ^ wNpPL, cHc&#dH#pointer!bc ^ wdp, ^number * pd_cpNbpHNH ^  buffer  ^table, &bmNwM&Pdp!1b&number&char cbb #, #number!pp >, cdc # table# number cb bNMpw 1PN&!t1bP, !, pointer, & ^^dw#NXNc;&c6b##cHNd pointer, ^table ^ & {7E#wHbHNP#pPP&pointer!, table &bw, #pcpcR#number ^ #Hc ^ dP##&1 * 1, 1wNNwp cPc&number ^ &number#  &bcw 1w#pHNccwc, #, table  & &buffer, bb .we, 1! * string.sub#!&char, &wH& ^number ^ char, buffer < 1, &1HPb!1!, &number& ^ 1d#number# / !NpwPb, cb#&HNcp * Pb ^ ^ number * Mb ^ !1Hewc#1d&&!!  &pwwb ^ Jwp ^ number!;pointer!1cbcb!wHwHwwHT& ^ % string.sub, PpNp! cd!#!pointer ^ number ^ number, NN_ ^ Hb#PdNd#1!number!buffer#string.sub ^ bw!, &NHwrb, cppp# !bHNH#dbd!number .Ndp ^ PbNP#bHcd! NbbwbdwS ^ string.sub ), ZN#1H#cPH string.sub bb, ww !NH 1 ^ number&#1##! dc&&wpw19b -, 1 ^ 1 ^ cbP#&string.sub&1 dH, pointer * number ^ wbN ; ^cHc&HZH## ^ cb#number#, 1pppNb#string.sub #Pc&pointer <#1H, pointer, number, ^ ^Ndp#caccP&table!db cb#number#buffer ^ object ^ pbbHpc# / #number&number& ^buffer#buffer * wN ^ #NHpNPNP ^ # # &NHcbw 1, db ^ number&8&number&1##PHNddd, db, 1opNwp&Ppvb#!Hddbd&&char ^ char, pz, number#wHPwP, !, # dcd&, char, ! number, string.sub char&char&!, !1db&number ^ Hd buffer#number#string.sub#Nccpc, HHH ^ HNbNw * wb wN&1!cbc pb&string.sub&1 * 1, number&number ^ 9b, &1dPb!1!, & ^& ^ 1d#, {^cNbw, % string.sub ! char&&!dbbb ^ NbcMcpP1gjpc ^ #pointer&#&, #ub, wp * string.sub ^ ^, bb#9d#number#number&number element#table ^ #wdb#wN} pb, Np#bH!&& HH (^buffer, NP ^ HPppNp ^ Pbcp#cHpHHwp:1bdp&1b -buffer!cc!!number!Pbw ^ Hw >pointer ^ pbPN char&!cH, &1bNHwwbb >cwpPyPN!table!, cKdi#buffer ^ ddbdp ^ #, 1rPcbc, table ^ table ^ !, Hc& ww ^  number cPbp1b ^ PpddH &number char, !Ncpw, pP ^ 1 Hnc!pointer!#! ^/, number HpiENPbN 1#char#dpd1bb ^ Nb#NcNN1wb, 1b#1&string.sub&wH ^number & (2 ^ 1w, char, number, 1 ^ #dH# array cd&number!qbNcp#number#string.sub ^ ! ^Hb&HHc ^ char&number, number, ^string.sub#string.sub NTc, ! &&&&# dbwb ^ NNHw ?#string.sub#!#cc&string.sub&, bHb ^ bN, wpPp ^ 1, char, PcHcdP user& ^^ ^, dN#number 7cpb&##Hbd ^  number ^, dbzNw&pb - .cwc, table!table ^ !number number&pointer, HbdpQ, cNNpp#number# ^pointer pointer * table ^ db & * buffer, &1 ^ Nb!dPNc !zbHd& string.sub ^ 1NP1bPbND! char&&number#PbP&PwwL, ^ 1wN, !db&cc#cb:bNwNw, wc1bp, cbc ^ cN&number  bd&, string.sub ^ #Nw, Nt ^ string.sub ^ ! ^char &Hdcbw ^ 1b#char#string.sub!1pgPc, #buffer&&dN#string.sub ^ NwP * Pm ^ 1wNbppppHb&!pointer&bH&global, string.sub ^ &number#pbP ^ cN#pointer# dpd&&, wHw&NDN#, HPHpPHpcPdd#, & db, buffer ^ cw number!string.sub #pPc!NHNbNd, wb, &ppp#number char #table&char& ^!number ^ number ^ char, cLNp string.sub, Pcp!1 ^ !cdcbP ^ 2dp, ^NbpH, dcc#PHacpd ^ bb ^ HddycpPbTfpc ^ #bHHcd * char ^ PwV * pf ^ pdP#number, string.sub {, string.sub!pbPdb * Hb ^ ^5bdPPc##!1w& ^ JHKwpbd ^ !wwwwcH!string.sub#char&Pcb  bw&number:WwH, Pmweb#!table?&1 string.sub#pointer ^ &wb bNw + PNbpPpd&number&number * number ^ table&table, pNb ^ dPpP #5H#&ddb#number ^ pointer ^, string .concat#1NbcP !&HH&number!!bN ^ number, qb ^ PbHN ^ char !#&char&cH&buffer&wH, Pb!pNbwc !1bP&1d!#! ^HfX ^ cwp, pointer, pointer!number!wHNdO!table ^ _ ^ &, pointer (cN#Pljp!number#PPPd!Hb&pointer number pNbp!1&cHpq#buffer&  number#HwpbNbd ^ buffer, #, bc!##1w& ^ >Hjwdad ^, number&wwcH!string.sub#char&Pcbbpb1wbw, number&number ^ 1bp&!pointer#1&1&, buffer ^ buffer ^ wb ^ #pYecPbN, 1 char & table&buffer! ^1, bEN, cbccp!, ##PHd# dHdwwncpawpPHP&!&#char&, db &number!, F41ppwdPw1b#dP ^ !&table&buffer&number!rbS ^bPYpc!1!, & ^& ^&number ^ number, ), bw&string.sub&PHcPp!HNd + db#number ^ !, bfcN#1#number ^ char ^ #bHH#cbKbNwNw ^ number#number 1Np#char, 1wdc& ^ ^buffer&, #, #0 ^, pPdc #PPd&buffer#1& number, dN!pNbdLP!wHp& dNH ^ buffer ^ wdq# {, wgP!number#!##1& ^dN #pointer ^ wcbPp p1PbP, # ^# ^&1#table ^ )wN, pointer ^ opp, &pN!NHnHbcw & ^HwP !NNpwP c1pPHb&!!!bH * nbc ^ pw&wdcPcw#number&VcH #bd&dbP ^ pointer, HX, cPNwHH&pdcbPHbwHZ#pSwPbwp ^ 1#cccw#, &type&PwwW, ^ 1cPHNHPpcd * HH ^ ^string.sub&be!number + p1Ppjd!&#bPb string.sub * 1 ^ 1 ^, global&string .concat ^ pbcRcd! ^HbcP table& ^wP # ^1, 11bcg! ^#cP!ddH, buffer ^ ^ < array#, 1 cd!!cb&_ !, ^number, number ^ #number#1!Ppp, #string.sub# & pointer# ^char ^ cw wNpdp number char#HNHc& table, bb, string.sub, result ^ string.sub ^ N1cb#string.sub#number! pointer * bHwcw ^  wN ^ 1I * table!!!#table#&1 ^bN ^ #DPTwpNP * EH!bcN&table! table#pointer#number#hPpNp&, dcwPbHNH ^     pointer, number, gwNdV#number#!!#pPP&, buffer ^ &wN * pNPp ^ 1#number !bb!&number#, ^buffer&, 1, #pepNPNP, PcHwH, pointer, ^ wwwbdpH, dP&pcPNcpdp# &Nw1ipSwwQb cd!!1H&1 * 8b ^ ^cd!8cNHwHNppcP!char ^ dp!buffer ^ !wM, 1Np ^ db&PbNb#number!!#pHcHd, number, wNNb?, Hc#!dbd!number##&Hd number wpHbpPc!PpbHHd#bBHPwab ^ ^ ww, wp:pwbPHwd, #! ^cwH HNdKpVwppp!&table .insert&dd ^ bb&number, !byte, number&string.sub ^ PwNH#dcVdRH ^ ^, =1p ^ 1NP#1 ^ #wH#pointer# 1wNwN, #number 1PN&!71bP, !, pointer, & ^^dw#NiNcG&cRb##cHNd pointer, dbwP ^ NNdN 1 number##char#cH #, bdb, pb#wbpcN cdPc&result&number table, char, number number, string.sub cdc&!, !1db&number ^ Hd buffer#number#string.sub#Nccpc, HHH ^ HNbb&dw ^, &pbp#qbc !#&char&char##&, wHb ^ NPw#f1pb!1cNHw& bPb& ^aPw string.sub&1cc, !1HbH ^  number   number, pointer, ppp& (dcdb!&number!! buffer&Nd ^  number  %  ^number&number#number#string.sub&1, &pointer#, buffer!&& char ^ cNcubP  %  number ^ #!# !, pointer  ^ number#NNNcp pN!pointer! table &#bcbc ^  number, positan, number PdP&char, cb&bHNbH&  # ^#number#scPpP, #table# ^#number * buffer ^ ^^number&NbN#string.sub ^ pb!number! ^table ^ &&buffer#buffer# ^^ ^NNd number!number&1ccc&cHbbtb ^, !, number, 1db char !#&number&cd dNwdw _ number#PcPcc !, table, & bdb& ^, ^1N * 1!1, cN#Nc#&# !bpd bit3c, number&string.sub ^ PwNH#dcTdpH bbw _PbHpPNNNdpbPbPbd!buffer#Hww ^ 8z ^ bit3c, &NHp, !wbwdH pbcwPdbt NwwwNHb!#!number! {db ^ wb PNbp!, !Nwbwcc&number!Pbw ^ Hw * nd ^ p1dPb!number!, HNdd!bb ^wdwydbH ^NbNbH!&ydbbpHd, :, NNNN ^ number#number !number#char&cdNb, buffer, wc ^ number&pccPcbP#&} #char bH, pointer*buffer  %, &1!Pb!buffer#number!cdpbH ^ Nw1mbw&string.sub&PHcPPNHbH ^ pointer ^  &wbw#, ^NN1Nb ^ ! ! HN## cbN, Dw, w11bPpcw!&HpPb !bdwbw& ^cNcbpP, char#pHHwH, pointer, wcw& N111b, ! ^! ^Hb#& #bb, string.sub, NwcpwNbcdp ^ number&!&pointer&&# ^PwNudg, 81Pb!string.sub!wPZ&  table ^ char ^ ^dwe ^ pT, 9N#1HP, HwcwbH ^ pwc?Pbb1Pb ^ cw!&# dP!!bc ^ HdHjP, string.sub, ^ <bit3c!pointer#PH#pointer!!number ^ number ^ char, char >Np string.sub, Pcb table, pointer## bPd&, ebb ^ , 1, string.sub ^ !pointer##dSdc&& ^!, bxcN#1#number ^ char ^ #bHH#cb <HwwNw ^ number#number CeP, char table&table&! &1 ^ bbNuH ^, #number#char#PcHpH, table ^ NDNNMpbb#cBNdHP&table number #d1wbAmN ^ pc, !cbpd# ^table& 1 #&bw, #pcpcK#string.sub, #Hc ^ dP##&1 * 1, 1wNNwp cPc&number ^ table ^ db HHdwc?PN <wpb ^ cd###, cad, bp&pww ^ buffer, number, element )!pointer#PH#pointer!!wb ^ number * memory ^ !, HbHxH#string.sub#bH, dw#! ^ww#JHNbpcPwNq!, Hpcp#& ^buffer number, 8bApdbPP#!!pw&object## cbNw number, wbp!NNcdc # table# char cb, Id; 1pM#pb!cc &bHc ^ array ^ number, table , cb!1, char, ! &pointer&&pointer, dbwb ^ NNHw 7#string.sub#!#cc&string.sub&, bHb ^ bN, wpPp ^ 1, char, PcHcdP buffer& ^wPb buffer&Ncb, Pb!buffer! ^&number& &number ^ pointer ^  ;pl&wdbdN!#PP!&buffer#NH ^ &ww ^, &string.sub#string.sub#for&number, #dc, pointer!#&&char char, cwbpGp ^ char!char number, &, dwbd ^ cww Hppb!number, ccPNHN&number  bb&number, ! ^^number string.sub#cNccP&Hb##bobNwNw ^ number number 1Npc#goto#number&table! ^table&buffer bN_pw 1!1#cw!cc &bdcbc ^ NJ / Nc * &cpb##wcN! ^table ^ buffer ^, HRcpw1bp#!#table!&string.sub!number, ^buffer, &QN ^ pbHX!char&!cH, &1#Hb# ^18NjNwbL cPb&table + cb!, table, buffer, ^, dF#1Qbcp&!&HH&number!!bNwfwb wN&1HPPN!!number&number& ^pointer, buffer, char, cNPpeL ^ number ^ !dH#table, !Jbp ^  wc, &NdwPP!Nb!bc#dpd1bbb , ^NbT&Pdcb#1#, pointer ^ pointer ^ bb #khwcpb number 1 # !&pointer! 1 ^ bwN ^ cNbEbPNP ^ ### !, state& ^number!number#user#NbPNPNc#number &!&# number&1d Nw#string.sub!NNcbc ^ HPH HNb -buffer number, #string.sub!pcb string.sub, #Hc ^ dP##&1 * 1, 1wNNwp cPc&number ^ &table!! &bcw 1 ^ Hp#1b!number!NPb!  number&&wx 1b, number, string.sub, number ^ cd!#&state&cH& ^3 #, char  %  Np string.sub, cHc&HKH## ^buffer!buffer#ww, char ^ !string.sub!Yp!vbpHHc ^ #&Hd ^ &wcN1Nb, c_ !!number &string.sub!cHNdNwNb, {bN&PpP#1 table!table#pointer# 1 ^ ^wN, #number ^ 1!1#char#!1&number&Nd#  ^ number#number!Ncp number, !HP ^ &number!#H1d1wb ^ NKwN PPP&1 ^ HHH&pointer& char ^, wb, &number, 1qb&char&!char&1&1d&& ^number!buffer Npwc
-- PHASE_BOUNDARY:INIT                         NpN!NP, Hb&&bpb#  table!char#string.sub#1bc ^ !number##! ^ ! # ^#wbNNNNp#1 char !#&!&cd &, ^ wZd ^ bb#cP#number#&Pddbbcb, w1XPbwb:0 .write!cHPNHpdN pointer#number ^ db# ^owpW .Mpcb# ^PPdb !table!wpbwwcw Pcw!table# &pointer!pbN ^ PdPAKw ^ RbQ ^ Np#bH!&& HHXwpb&5#N1b ^ PN!pointer! &string.sub&&#dbdd!fP ^ !pb >NN ^ pw# ^table& # #&&pointer, (dw, 1!8&pcPcHc#1 * zone ^number!number ^, number, 1bc&!Nbp&table&& &bcw 1 { number ^ 1 ^ number&####table ^ Hbbbb ^ number ^, &pHp#1 ^ 1N#dc, pointer!#&&char char, cwbpYp ^ char!char number, table, dw dHbw# =PpNp&, dc&!bbb&HHP& pointer!ddNPNwbNcnNH#pointer!number&, pointer ^char ^ &buffer ^ number -, PPPc!char#number&, &, cd&, number, cNb, NO ^ number, PcH!!, pointer  wpw& ^, string.sub + string.sub&number&ccHPHb&&table ^ ^   ep ^ char, NNNcNb, #bH& string.sub #pointer number * 2Hpcp ^, wc ^ #CP - !dH&&, ^wdwNHpp1ccPNbHpH1dbd, ^ ^ ^, 1 {string.sub#1b!number!number##! ^pointer #number!wc ^ &number&1!cbc pb&string.sub&1 * 1, number&number ^ gb, &number ^ !cb&Hp!#dwHN& ^ ^, ^number pHbccw!1c#&# !bp&Pw, :wNdwbP#!!#pPP&, wbd&buffer, #number!pp, PP, !bH&&number!pbN ^ PdP * !wb 1G, pdpH&string.sub&bd, bw&!, HNNN string.sub, cfNdHP!NdpbN ^ pointer&wsvw#, ?} ppppp#buffer& ^!Pbb ^ !pointer!bwwwbP, number!table#pHcdP!bb ^wdwNS, !: ^NdNbH!&EdbbpHdw&, bbb, !number!cdpPHw&Hd bd&string.sub, table, &number&pcP, cb!&char, dHd&buffer& ^cf1qbN& (^char!1 Hpcc#number&number ^ number bs&1pb#string.sub ! HHdcd ^ #wwPwcQcNNb * 1, ccP &number&char cbNw, number, :char, &Ppp#!wPNc ^ # ^ ^pointer wH, cNwpbN#char##!HpcPd, bbw&, NbppNbPMPpwHw!1dH#string.sub ^ bw!, &NHwdPHcN#string.sub# ^table, table#pointer ^ &wb bNwE!NbNP#wHH&  dHpwbb array&Ncb, Pb!buffer! ^&buffer& &number ^ pointer ^  td (&wdbdN!#PP!dP#NH ^ &ww ^, &string.sub#string.sub#goto&number, !number&number& ^pointer, buffer, char, cNPphG ^ cHc&#&Hcd, 1b&, EHg&string.sub&1c!1!1#&! ^ !& wp * char ^ number, NbNN, cb!&&string.sub&#table ^ wd <!NNpd, Pcw#pH &number# ^ ^ ^pointer, # ^4bdN&char#!1H ^ &number pointer  wdw& ^, pHp&cHc#1HHH!Pbp&number, string.sub, ^ wbb number##char#cc#! ^, ^wwd bN#1!PpNP!, Hbd& NHpwN, PbPp! + wpbp ^ 1p&bd! & ^HdA Npwprd!bPNH!cW * dbP ^ #, ! wpPpcPccN# #, &cH ^ ^char, char  %  Np, string.sub, Pcb&Hp!#dwHN& ^ ^, ^number pHbccw!1c#&# number ^ number ^ &ddNiNN1Nb ^ !#! HN##bcbNwNw ^ number number 1Npc!wcb&pointer! ^table&pointer&number& ^#NPpNPdP, P1HbdpdwHB ^, HNcN ^ wwcPcc#cHNd pointer, bc  buffer&RcpcbNc, char, #char!& string.sub&# ^number * Nb ^ number ^ string.sub ^ number cH!cHw&1H#buffer#number!, pbPN, 1wPdNb##&!dp#Pb, wbB&NNwpPNcPpPH!!number#&&1&string.sub, bF!number&1Ha_!table#number&string.sub& ^pointer, ^table&pointer, &_b ^ buffer >cpN#bcN&!!Kbd ^ Pw#versan!bwp ^ number <NH#!##&#dbb ^ ^Nw# ^^, 11bb ^ char ^ !&&table&#pointer ^ table /, dG ^ pb, PcHb ^ HPc##1&1 ^ 1, Vq ^ Ncw!Pdp, ! ^#&pointer#pointer#& ^, pointer * !, 1b )
-- PHASE_BOUNDARY:INIT                         char!char, #number&number## # ^!wpb, NdN 1 number##number#cH HN# ^wswNBNc ^ 1 * 1 cNPc&cdPbfb wPdwNHpbPcP 1###&number number &Hd, object, NNNN ^ number#number !Nc#cb ! # ^#wbNNNNp#number char #dH!cH * 1 ^ string.sub ^ number math .max {pdb!WH!1HpHw!  ^dw! HN11pbwNG! Hd&!!HbbwpwwbupP (&N1pb#bc, &, wbd #, #number!ppr, cb!cHddN Pb!Hw, number ^Xp Pdc!P1Hddbd ^ bNwpdbNN, char, wcb!3#!!NdHbNb ^, 9Vbd1PNb!##, cb&pointer * 1 ^ ^number, string.sub bNwzcl!pc1bc dp * bc ^ &, dbPp ^ global ^ _ ^ pbP ^ cSdPb& ^Hw1gdNcbNP!number!#pPb&buffer char, ^1, number wpP <#PwN!#table&number& pointer, ^string&pointer, Pw1wbPdNHpwbP&!pointer, &buffer ^ ww HNbINyd!Hb!Pbcp table& number, pI!string.sub 1dPc!buffer##&1dH#Hbbdc, Yw ^ w1HpHbzHwcw#pointer#Hwpwb Nww!Pwc##buffer&1d! HHs ^ bdbS#string.sub!1p_PcwP ^ Hd!#H1HHwb ^ number ^ ppcfNNb#dcN&NdcH# ^!pointer, bNwpP9f, char&pd&string.sub& bu ^ #wd, bbbN cN!#PPpc # &number&pointer, Hb#bbpbP!cppbHndc number, number!, Nx ^ pp, pc_N, #cHHcH * buffer ^ 1ww % NPN#PpPc#string.sub#bH, dw#! ^number ^^, Pcpprb#1bd4dbbw ^ Nb#bHw!PPNdpNP&&#####bpd, buffer&buffer Pbp## #bdN goto * wpw ^ temp&Nwwwic!NbnP#&& HbP, 1b#Nc, cPNNppHb#Hp! ^Hp&table ^ dbH ^ ^number#NNcN#byte#bPw !, wP} wpCwHcp!!#, Hcc! number ^ - ^buffer #buffer array#1dcpPbHbP, &, bpbwd * table!:#, pcCpn!NPp!5 * wH ^ dPw buffer&Nd, 1:&!char#wPd& ^#1&number, pbV ^ &, &math, NH#!PPPddNbP ^ vdd, wp11pb ^ !number!, table pointer <#Fbw& ^, 1l! ^!1dcN!bpw&string.sub&cbKbb, 5, pointer )^pb, PP, 1 ^ # char##string.sub ^ for&number char dNwpNPbP, PcP!!Pbpbbd ^  char ^ ^number ^ 1bPHNdHpH  .buffer# ^dwb PNwbpP cNpp# ^&bdHHb&#bHNP, #Npc#number ! Hw&pointer!buffer ^ string.sub ^ 1 wNbw * string.sub ^ } number!pb ^ cH !Hcdp global, ^cbNPdN!!&1, !; wHbdcbc ^  wPPpNpN!! ^&0 .read&buffer#!bdw wY&1Vb char#!bbb&pointer!&, ^pdpG!number ^ 1H, dcw!NHbH, bb! ^&, HbcN handle&number#p1bw&buffer!dHNH!wdw ^ NHN NNNpbiHw!1#dHNd&, 1, cwppbN&Nd###&!!pointer#Hd&number, bj#wRbPc&!table#1&ddcbN ^ !pointer! ^NwwH cN#buffer#bcdd!Hpwbd, bc ^, 1HPbNb#&# !#pointer&Hw ^ pointer !number#wb, & /, pcb ^ char&#&bHbcwb, 1w&1 ^ ccp&#1c#&, dNHwb, bbRd, Nb!; !cP#table#pointer! pHPwb, cNdbNPPc!NwHH&buffer char  Hbw#_!Npw ^ tN!PP#!pdb&PHc ^ char, HaP ^ !1bb ^ pHH!char#&##Hbbd#bppQ, !APNbp&Hc&number!string.sub wHww&qHNPw, mHNd!number&1dpd ^ ^number ^ NZwubnu ^ !1#!number!dQ&3&table, !buffer!7wwePdcP!#table!Pw !, wP, KwprwHP >NP!, Hw&pointer!bb! char, pb, number, + number 1&1dH ^ !&HPwpwPb#table ^ number, 1dN#string.sub&PddH##&char&string.sub, dz1pHb, cp!PbPH#char ^ #number ^ bddb1wb, &xp!5pwbPH dw pointer&PwHj ^ Nbp#Pwc&#cHdcd HH# ^^, 8bvpPb char!NH#buffer#, ddd ^ ^dwP, #number! ^wb&string.sub#!cPNcb dHH&, dP + H_ 1!1&string.sub, 1GPwdbd &string.sub&, buffer#5#string.sub!1p + number!buffer#char&pointer * NbP ^ !&wqHNb1cb qb!#table!&string.sub! ^HN ^, wcw number, 1&lccc#HHPc! buffer ^dH (! ^!number#, HN!#PPb! * !, #, bbd&, number 1PT9cbp&PddH#!table, pointer, bcbwpb, bg + char##dH!! * number ^ &wH, 1NdpcPNc!string.sub!HPcbd& bHb, fg#ppwPPHP #!#&pointer! 8bbwpddTc, 1bNe ^ pHH!cP! #: ^number ^ #yptc bNd#table#HH ^ ! &1 ^ 1, string.sub, number ^ KbHPN!!# ^&gdp!pointer ^ PwHXNd# ^H11cpcwb&number ^ table ^ bH } ^cwc ^ NpNPPcSppHHH&#number ^ pd1wbbPNP, 1zw!bb ^ cH!!#cH number#8fbbN cN!#PPpc # &number&pointer, Hb#bbpbP!cppbHsdc number, number!, Nk ^ pp, pcaN, #cHHcH * buffer ^ 1ww ZNPN#PpPc#string.sub#bH, dw#! ^number ^^, Pcpp6b#1bdqdbbw ^ Nb#bHw!PPP!pdb#char, pointer ^ table ^ wNw, bD ^ !wc1fN, 1Hb!table ^ !&HPwNgN ^ cpPpNPHP, PcHb&&#pH& number, table ^, pP, & + bpp#number&char key#string.sub ^ ddb ^ #NeN#pwc ! HNHb! ^  ^wwd * bwbwHP ^ !!pdcfc, table# ^char ^ 1, 4N, #, #PpbNPdP, !bHp ^ ^ ^ buffer#buffer&, ^number#number&1!##! ^#! ^number ^ Hww ^ &number&1HPPN!#wH#dbbb ^ !wH ;NdpwP#number ^ Nw#&&HdP#, &1 ^ NwN, 1NdPHN#!#Hd&!!Hbwb, dNHw#string.sub&Cdcdb&cP pHN&, db  ^Np ^ number!3d!pb!&number 6 buffer&# .bpN!1 Pdcc#bH#db HHHw& char + NwwwPHbHP <&number!wHbHH, string.sub, bn, pw, !cw!#Hbdb !bH&table .insert, & bN#1!PpNP!wc ^ &pointer##&1&table, 1wNwpbcNNpbHdHw#number &&#, 1, ^number, pcJp2b!1ddpd ^_w#, dhb ^ bp, 8cp!HPcp! table * dNddiH ^ ! ^b1bc!!pbb&buffer cbPb ENN ^ 1p + string.sub!Qp, Hc&table!Hbbwb, wb + pPp#cpccHpHb&, wH!wNb, 4 ^ number&QP!pbiP#Pb list * 1 ^ wwN ^ # ^table, !cPccPrP#!, pointer, bw ^ ddbNPN ^ Ppc&!buffer#wP! RbP ^ ^wb Pm, pwbdNcp&table ^ &pdw& buffer&pointer ^, ^string.sub = pb, number!number!ccydw#number, pointer >  wNbwbbpN, string.sub#HccN!#bb ^ bdH, ^number, pc2Nwb#char#! ^#! ^PdPdH pppwYHcbHN&key& bpb ^ number&, wbwpb, cN!PbP&Hd, bdHb, 4, 1NwpNPwcH! Hdcpd ^ & ^  char ^ 3pw, bNbNH#buffer#, ddd ^ dbdPbppi, GhcN1b HdH#dw cd, 1 ^Hw, number#cwPcHdc, && ^, de! ^HPjP&!wHc&Hdd#string.sub ^ buffer, v_&?, w7b cd!!PNccHdddw&bd, string.sub ^ &string.sub&PbcHpd&4&number#buffer ^ dd number * bbp ^, number!#PPP!number#!# ^&1w, xH ^ Pp#, ^Nw#bPd!1Hb&&dpI .buffer, ^Pp * PwcdbPHHd ^  bb#ww, &Ncpd, dcHp## ^&6!rbP ^, ! HNbN, PdP ^ #dHP&# !#number ^ &buffer# / cwN, bcdpHb, PPdHd ^ ^ buffer, ^xwwPbcS1Nb, !#pointer#buffer! ^pdPkbNcbdcN!number#!1wdH * buffer ^ char ^  dbJ#string.sub!1pK ^ pNcN#1dN&#bbdc, cNHpP, !cbc ^ PHd!#char #&table, &buffer#wpPENNccb number&char, ^number&table  %  NbPN, 1wPdpcH, &table&&HPwp number, 1 ^ number, pc {number, !HPb!table!, bNwRwbb#string.sub, number#number !string.sub# Hc&& dHP ^, buffer ^ zcwP1PNi#pb ^ cb# bdb# number, cw 1, char#string.sub #pointer##!1dc& ^  pNPNN, ^1, pN!number# ^ 1db ^ char ^ 1 ^ bNpp, pwb!!bHNdPdb&char ^ bw ^ user!number string.sub number&cNbZHLcb wH&& wI#pbPbc!!HbTH !PHd&!db ^wcpcPPcgppHd&1 Hb, wp, number * bpap ^ 3!Nb#accumulator&cdPd, ^ wN, ^Npwp, &cp! #cH&dd#number ^ table ^NNp&pwP#cN!cH!cDd &&dpevbwwcycPb!char!, HbdP!number ^ number char, &Xb ^ bPPN!PN#dHN&Hbc ^ cw * number ^ bwbHPpcc#PbbdpHc ^ qdpb ^ positan! + ^pPcN!number###&!string.sub wb dc, #NP1Nb& <pointer#Ec1cb!& ^ ^bwH dN&pb, buffer!Pb!#!&table&!bd ^ dwp?1d ^, !cPp!HpcPHN&char * char ^ string.sub ^ ^number ^ 1bppNc#!Hj&1 string.sub#pointer ^ cbbAN ^ ^, HN&char&#!&1& !bb# char, 1b, number _ number !pointer#!PHdbd, buffer, ^ ^^1 ^ bbd;HpRb, HHH  number # ^#wcb&wPPpNEp#!&char, !Hb!&Pd ^ buffer NHpNP!char ^ #_HpPddw&number ^ number, %, buffer ^ #wbx1NbbPPd!char#Nbbwpwwb& ^number, PPH! ^#bH#dw & ^cwd dNHwdb&number!!wPp& !wb &dwHb1Nb1cb, cb#Pbw&HHcb& ^bdb ^ !, number { cPNdHPHwdNbjHHw#, dbdbANpppppHb&!pointer&bH&7w, Lp ^ pbHNbpPpd&number&number * number ^ math&table * string - &pdbcP##5bp&NdP#number ^ pointer bb bbb!Pqcb#pbd&buffer char, ^1, number wpPS#number, 1N#table&number& pointer, ^_&dTP ^ ppH, wPbb table#cp#string.sub#, pointer#number!_#bwb!1, !number# Hwdv!HbPw&, table * 1pdbccN!!1!number ^ pointer!, buffer& ^^, wbHbNsFc&pbHPcHd#&char ^ 1dbqH ^ bb!IP!pbPHwc ^ #! ^* &number, bbwpH, #string, string.sub ^ 1&!Ndb#pointer&bd#buffer, NbpcPd!number#PH!char!pointer&HPwPd, buffer# ^db!tH!O1bP cw * Hb ^ buffer #buffer, string.sub ^ * number !pointer#!!1dbbpbw, HNwp#1&char&1, #, &wdd&# ^number, #ANNcb!TK!!number&&number#1 * string.sub ^ 1&dFpk 1oP#cd!bbP& %  cbPb <NN ^ 1pipN&#pH &cd&bd&Pw, ^ ^number, PcipP#wPbdd#buffer ^ !dc wNHw!PPN!#Ob, cc# ^bH&! cbbw 1HPN!!# ^&Jdp!dbc number, NNGNbA&number&!table#number!number Nb * ^bw#RJbdbPPH!number!#cb&1 * Cb ^ ^cd! * HpNp 1, !Tpd& * #1  & ^wP, ^x#number 1bq!! 1wHb!db#pointer#, 1 * number ^ ww Nbcp#1bddpd ^7w#, dJb ^ Pbmcc!number!, &!dN ^ ^pdp &Npp 1cP&!dbP&table!buffer  &HwwbPpptNb, NH#PPHdp#obwde, db&wp1bcd!Hbd&number!1# &&dcb ^ NHw! <HN1b HH&number !buffer ^ wR, pbppP, KP number 1bP!dA#PbP&, #bdN ^, Hc#p1b &number## # ^!wpb, *, pwbdp#!#table!&string.sub!number, ^buffer, &vN ^ pbNPPNPPNcwd!!buffer ^ !number {, 1Np ^ dbPccNbHPH ^ pb& ^bww !number, number ^ number!number !&HH&PHNbN ^ number, kb ^ P1bP!number!PPc, #char wHPww, table / pd, pPb! ^1P&bdcbdwN, number} !bwbp )
-- PHASE_BOUNDARY:INIT                         string.sub! % 1pHd&  PHdwp * 1 ^  number 1dP!NH#1&kd ^  cH!w_ = NbH1gb&cw#cHH&pointer!pb ^1, H_#Nc1db ^ !!!&table .dld, HH, Ne&bw1bp&global char&!, Hp#cH bP #buffer state!, Nj!pPcwP&cw#bHNb ^ b1epp#1!PN!table#1H, dP#Pb#dP, number ^ 0p ^, bccpHHkcNd# dHdww !pzpdb ^ cbpPHb&char * pointer ^ NwP, ! wN&pcPwcb#NHwd * 1b ^ wE * 3Nc ^ bP!char )!1HpPd string.sub  we, #KdNbwPb, number / ! HHdcd ^ #number ^ &wcNyNbr&ccNH#1&string.sub&number#5b wd, !pcw#1&cH!Pb!&number 2 bHww& >HNPw!PN!?!bbw&& ! ^1 ^  dbT NwwwcPbHPNP! for * db ^ wb PNbp!, !cbPfPHPw * Hbp ^ char, number bNHb#char -NP!wc ^ !table#, Hwd, bcbPNwb, ;!!char#HPH#temp ^ pd#, 7 !p9pdb ^ cbpP#number&, !!bw ^ #, bNbp!1Hxlc 1Pcb!number#db&dpbP ^ pp wc#pdHpc!dc#, &Hw#bkwb, XP ^ Nb#cPHdi#Nbbwpww ^  NHbwP#char&#&char, &, wbd #, !number# ^wP!number, #PH &number:#table&, pointer ^ Nw#, ^8wp1bwPd!pointer#, &cd&bpbwwdBbNdNd#char&PdgH ^ bd, user, &0 string.sub NNcN#state#buffer!&pointer&buffer!wbw  bN!1#, number!!!, &Pd * number ^ buffer&table, 1bbw, &Np!Nbdcb!db#&!number, bpNdwwb ^ number#1d#, cH# HHwc * PW ^ wobH &char #dH!#1 * 1 ^ string.sub ^ number = key * pHPcP ^ Nw# ^&;! ^Hdwd, 6HbwbHPpcc#PbbdPd ^ bw ^ &number * NP ^ !1cPHNH#wdp##HGH!, %, dh ^ pb, PPw!, 1!&wd#bbwb, ! / table ^ ypbcN!?! &string.sub& ^ &bw&number, bbwN ^, dcppb#&HbcbbTHH, string.sub, buffer;, pw, !cH#number# table, _#pointer ^ cbbbPpp, #NjcpbpHc!1# ^table dN * 1 ^ !NH, Hxw!db, char&!#HN&pwcbb ^ ^number } 1N, string.sub ^ ccdpd ^ew#, pointer:buffer ^ Pp, string .concat ^ char 1Ncb#1 * 1 ^ ?number ^, cb!pHPNP char, HrPddc&1&ww
-- PHASE_BOUNDARY:INIT                         bJNb, NV number&PNHw&# buffer ^ 1w!, HbHp!, NRdc ^ 1&table&!1HwdbwN  _&pbbH = d1Nb!&  number#table&number , NwpdN#char##!Hp!, pointer, bw ^ db#YPpd1bPc!cP table dd !d1wph1bd1pb !0 .write##Hd&buffer!number, &table #bc ^ wp ^ error!pHb!&1!string.sub  Hww! dh&wb, bP pPP#cP * NHg ^ &db {number ^ cp#number!cpb, table, &number * dbc ^ wdHNpp!1, PcbN#NHwd * 1HP ^ number buffer!pwb#cb#1H!&table!element  &number * 1bN ^ dp&vppPbpH, cw #Hdwp !8c ^ HP#p3Pbc  %  pointer ^ #buffer ^ cdHW: ^Np1PpPwb # &dd!#table ^ 1, string.sub, number ^ _p Pdc!pHHbdpdwH&dp * pointer ^ 2w!, #';
-- PHASE_BOUNDARY:INIT                         local zdBktXZkIMIhWuVqJxkskSyayWvYBpM_ = {"WZ} zone } } zZZ } &temp .LXXXWd&azzdWGa .dY } .bL&zZYG } daXLWbG!WGaGL .WLcGLb .YbZZd } Lz!char!0 .read!vz } z", "dYaWc&YbLZZ&ac&& } cdXY } array }  .zWb } vaGZ!aYGLL!&cLWczG } dWYZGXG", " } Lba .zY&zGZ!zLWd .vX } char } zdd .window } LYYcW } }cWcYa", " } .LXWZL .Xa!ZLXYLzcYdLcXWLz!aXWbY &bbGaz .window! } YbbG&aY } bbcb } char&for&temp!vGG&zc! .Yvz", "YccXG!bGbLXGbzvZ&&for!dZ& } LYzG&YGd .vYaZ!char } &table .insert } LXb!dv } vYZLLa&&&YL } .dZ&&cGdvbvWz } versan .YdGcbdGvGz } buffer } cW } WX .dLLZG& } XWLGL } .versan !avczX&dvdYv", " } char&GYcc!Xbd!window!WGLd!dYY!ZGzZaba!avXWdz } pointer &GG } !Wcz!window .ZG&dWd&window!!", "&&pointer .avWGGvzW } Zz .table .insert&zzaLczdd&WbZ } YaZ &&Wc .dzaz .Zz!0 .read .XG .avGGYzZav!cY ", "bWX } cX!cY } cLcc!zone } ZWczvZabdv } vcbY } .bb!!zvzLccXL } dz!pointer&versan!bvvdvccdv& .pointer!!window!bcGzvXWLWcv&bvdbGa&GzdYW .char } vc", "XdLGZvXW&!XGd&cL!&& } bzzGdLbYzzL&Wv&&for&vZL } window } GWWWZ .cXZL .vZdz&Zcb } bvzbvXvzva .versan } XG .YabZL&vzzLbvd } ", "&! } array } GXGbZLX .GGcZ } for } WLY&zone!window } .YYvcYbW } vb } temp&for& } vL } !XadzZG!ZbaYW .versan!WZG } zZXavcLddWZWbcba&&XaWcZ } L", " .ZdvXWv .vXXb& !cz!aY&!dLb .aXcd } }za!azzbLdYG&&!WbzWYzdXv .dd!WZLv !bcaLcb!", "aXXadWacz!YXX } WvbGZ .versan } &zXzWb } GLc!LWdZY!Xb! .temp } Zcb&zcac } 0 .read!dcL&Xc .GXXd&cLZZLbvbGYd .cYv&WvaL&&ac }  !dZzY! } }XWb } YvvYXZzYbaLWd } buffer } zGYWZaWzbzbGZ", " .LWb !XLW } WdaZb&XcczLLGLdvWz&dbZYZWXdaabaaz !zone&cc!YL } ! .dv .zvGabX .ZLLbabzXbW& } vYX } ZZczb } ZYL!bL }  !Xa!char } YWWc } }Wad .for } Wv!Wd&for&!XYvZ .window&LLZ!array .pointer .XXvbXd .XZddYY } Gzda!bbzY } temp&&vdLdZb&bG .WbWZ&!array&Lb!char } zone &YLdWzGb!cb& } Ycc .daYzvaX .vXZYz!! } char&WLb&Wdc&char& } LZXYaX .XazzYWWWLXzd .WcYdz } for&Lb &czLGcWbXaWdd } Gvzzd .buffer&cWcvaGZ&bdWzLcvZb&GWGbbYGXbGdbXLX&table .insert!pointer } GW .aXz&versan .WvZXzcXXWvbaa!ZZ!zcd!WdvXZvY!WdbZYX .zaa!aWWL&WZc .zd!YYcv .vZbYGZ&GGLWdzdWaX&& } aXbzLLdZ&zz .dZ&buffer .bzz&buffer &LZz&temp &!bLGGbbXX } dzXZX& } .temp!&dWXZaZ .LLX&YWbbZ .LXcb!GbXcaLd&window } &&LXX .GzLZd!zX .pointer&XGGdYcc .vXaLvWbbYbLL&LzdvdYWzGcz!YG . YWczGZWzZbYGdZbd .versan } vYXb &window .zone!buffer!dWGWZvz&GYzGZzWc } temp .ccXGYGcLGa .for&LZ&&buffer&GYbb } zzdvz } WvWaadY .vvaZWLa!dG!WcXG } temp!dY .cdadGGX!YGavZWLX&vLGcGW } azYG!&bXG! } cXzzZYXccZ!pointer&temp&Xdd&!&char .pointer } vbWL .zGzL .XLzXcd .GZ } ZYLG&zcb } vXvz .bzWbdYLaz .0 .read .LLvWzZ&ZY .WX&versan&cX !&GLXb! } ZdvcdvaGY&char&aX!table .insert&for .aL } array } zone& } bGd!& .buffer .Zz&GG&buffer! } aXbLYc } XXdvLdWvcaad .Yz&cGWLZdXazZb!vvZbd } czavdvWWvZWLdbcb } }vvLGGGzWa&LzGYczLdc!char&LGWb & .XXvzXbb!dWX&bz .dL .LXczvbWZdW!bzYcbZd } .LWabZdWdvcXvaa&&cdbX! } Za!GazYW } temp&cvdLa .buffer&Ld .WbvZ&za& &Xc } WGvzzcXYXXa!avWL } bZcXGd!Gbcv .XZb&LZ&zW&GczccYZW && } zadadGcWacW&for .zcW } LZWacZ!&zcWcddvc } vGY!zY } for } GWGYZZ .versan } pointer } &Gd } dv .Gb } array .ZbZWbXLcXb!Yd&!zone&window!dz .ZW . } bzbzYGbXZcdYLcaz } .buffer .bbazXdGdGv& } cv! !zv&GLbGG } aGcG!dbXGc .cXGdZYbXcZZX&ZZWddYc&cY } }versan&GL .aazaGaLzGddadY } & .vbWYvzZLXvdva&0 .read&WLazbWaYzb } zbL!WL!GdYvZ .pointer } WLGdbcbccXvWabzz .vvL .Xb .vY } zzzzbc& } dabYabZbaYLddcb .aaXb } ZvaXLvYGZ } GZLYZvzv } temp } &array ! } cLZbbcG .cYYZ&Zd&&buffer!!aWadvvvWvYzad .bvd&YLzLa } versan&buffer .window } cYv& . vaXvz } !XYG&window&YzvYa .Ld .zbYYWL .WdG } }YdaaLGZYcbaZXvGbbXz!dYdcz!array .Xz!zd } zZXLzdGZ& .XGb .dLvcz .ZLzbZvaY } &XYbz!window!LZ } zz&cGGd&YczzLc!table .insert .LGcW .LWbWb .WbcY &zW } zone!! .YzXWzGbbZWbGd .char } .XvaZYz&bbY &dz!dWYYvG } versan } vzZLZvzz&XcGdb&czd } char!aXLGcz .GcaWbGL } buffer!ZWLLLXzaWad } bWa } buffer&Lcbc&bLbdcZZzWa &dGLGG!bXGadv! } char&cc .char&&Wc .ZZGdzbzbW .WG .Yv }  .&dzXv!buffer!YWXv } char } GXXYZ!Wvvzc&LYcccc!temp!aL .czcbvLGXvdzd .ZadvaG } 0 .read } table .insert .char&&char .WzG!bZdcvG .WbbYv .versan &azXXzvv } &bzYzZ } GvaYZWdv } YX&aZ } dvL&bd&table .insert .avXcab!dvGLbXcz&table .insert .buffer } GLWadXz } Gc!&dbad! } GZbXW&buffer&0 .read &cvLGLGbzb } dvvL } table .insert& } for .cz } Gz&temp } &buffer } versan!cbLbdLz } cccb&dvXYva } !&cWYX!window .Ld } zWYLZWbWdazGY } Yc . db .zZLWLLda } } XZXzL&XLd .cWzdcGaWvd&bdcv } aZbZX .zLX&zabddcL&cGXXYW } .char } ZWzva&cXadZYXb } versan } LGzLcbzYXvX!bzbdzbZa } pointer!char .LLczbvXG ! } WGW!YWZvWbXdYc } YLaYWZ .bdz&LW } cXzvYLWZvW!ZXdWGcvcLdvLLYXaGv", "" } ;return (function (handle )
-- PHASE_BOUNDARY:INIT                         local function;
-- PHASE_BOUNDARY:INIT                         local pointer;
-- PHASE_BOUNDARY:INIT                         local list;
-- PHASE_BOUNDARY:INIT                         local array;
-- PHASE_BOUNDARY:INIT                         local result;
-- PHASE_BOUNDARY:INIT                         local string;
-- PHASE_BOUNDARY:INIT                         local element =  ;
-- PHASE_BOUNDARY:INIT                         ;
-- PHASE_BOUNDARY:INIT                         local accumulator =, {} } while count do count = count + 1;while count 1fe and*element  %  0x4cac <  do count = count + 1 element = (element +  ) % 
-- PHASE_BOUNDARY:INIT                         local object = count + element if (element  %   )< = 0xc1e
-- PHASE_BOUNDARY:INIT                         then
-- PHASE_BOUNDARY:INIT                         element = (element + 0xdfb ) % 0xcbe while count <  and*element  %  0x21be 1ada do count = count + 1 element = (element + 0x17e ) % 0x28f
-- PHASE_BOUNDARY:INIT                         local  pointer = count + element if (element  %  0x3iea )> = 0x1c7f
-- PHASE_BOUNDARY:INIT                         then element =(element *  ) %  if not accumulator .ethen accumulator .element = 0xb end
-- PHASE_BOUNDARY:INIT                 elseif*element  %  2 ~=0
-- PHASE_BOUNDARY:INIT                 then element =(element * 0x27f ) % 0x21ja
-- PHASE_BOUNDARY:INIT                 local  element = 4314aif not accumulator .ethen accumulator .element = 0xb string = tonumber
-- PHASE_BOUNDARY:INIT         end
-- PHASE_BOUNDARY:INIT else element =(element -0xea ) %  count = count + 1 if not accumulator .ethen accumulator .element = 0xb result = {} ;end end end
-- PHASE_BOUNDARY:INIT elseif*element  %  2 ~= 0
-- PHASE_BOUNDARY:INIT then element =(element + 0x2ja ) % 0xb9fe while count <  and*element  %  0x3bcc <  do count = count + 1 element = (element + 0xcBD ) % 
-- PHASE_BOUNDARY:INIT local list = count + element if (element  %  0x46ba )> 
-- PHASE_BOUNDARY:INIT then
-- PHASE_BOUNDARY:INIT element = (element +  ) % 0xbf4c
-- PHASE_BOUNDARY:INIT local  element = 9231fif not accumulator .ethen accumulator .element = 0xb pointer =(not pointer
-- PHASE_BOUNDARY:INIT and _ENV or pointer
-- PHASE_BOUNDARY:INIT end
-- PHASE_BOUNDARY:INIT elseif*element  %  2 ~=0
-- PHASE_BOUNDARY:INIT then element =(element *  ) % 0xb0fa if not accumulator .ethen accumulator .element = 0xb pointer = getfenv and getfenv () end
-- PHASE_BOUNDARY:INIT else element =(element - ) % 0xeecd count = count + 1 if not accumulator .ethen accumulator .element = 0xb function = string;end end end
-- PHASE_BOUNDARY:INIT else element =(element + 0xce ) % 0x8feb count = count + 1 while count 10b and*element  %  0x329e 19ea do count = count + 1 element = (element +  ) % 
-- PHASE_BOUNDARY:INIT local object = count + element if (element  %  0x103a )> 
-- PHASE_BOUNDARY:INIT then
-- PHASE_BOUNDARY:INIT element = (element +  ) % 0x195a
-- PHASE_BOUNDARY:INIT local  element = 1692dif not accumulator .ethen accumulator .element = 0xb array ="\4\8\11g\11b\11a\11h\10j\9i\10b\11e\7a\11e\8j\10e\8d\9i\11e\10h\0\6\11f\11g\11e\10f\11a\10d\4\9j\10e\9h\11e\6f\10d\8e\11b\10b\10i\6j\8g\0\6\11f\11g\11e\10f\11a\10d\3\11f\11h\9i\11e\11c\7h\6g\11g\8f\11f\10h\0\6\11f\11g\11e\10f\11a\10d\4\9i\12b\11g\10b\8i\6h\7j\11d\7b\7j\8g\11b\0\5\11g\9h\9i\10i\10b\6\9j\11b\11a\9j\9h\11g\8d\11c\10e\11d\9a\11i\9a\9a\0\5\11g\9h\9i\10i\10b\6\10f\11a\11f\10b\11e\11g\6h\10h\6j\8g\11e\9h\10g\10e\5"
-- PHASE_BOUNDARY:INIT end
-- PHASE_BOUNDARY:INIT elseif*element  %  2 ~=0
-- PHASE_BOUNDARY:INIT then element =(element - ) % 0x33db if not accumulator .ethen accumulator .element = 0xb end
-- PHASE_BOUNDARY:INIT else element =(element -0x2be ) % 0x4dff count = count + 1
-- PHASE_BOUNDARY:INIT local  element = 4630jif not accumulator .ethen
-- PHASE_BOUNDARY:INIT accumulator .element = 0xb list = function (list
-- PHASE_BOUNDARY:INIT x0b
-- PHASE_BOUNDARY:INIT local  function accumulator (count
-- PHASE_BOUNDARY:INIT element = element + count return list:sub (element -coun, t, } element -0x0b )
-- PHASE_BOUNDARY:INIT end while true do local count = accumulator (1 )
-- PHASE_BOUNDARY:INIT if (count == \5" )
-- PHASE_BOUNDARY:INIT     then break end local element = function .byte (accumulator (0x0b ))
-- PHASE_BOUNDARY:INIT     local  element = accumulator (element
-- PHASE_BOUNDARY:INIT     if count == "\2"
-- PHASE_BOUNDARY:INIT         then
-- PHASE_BOUNDARY:INIT         element = result .FrYhSbrk (element
-- PHASE_BOUNDARY:INIT     elseif count == \3"
-- PHASE_BOUNDARY:INIT     then element = element ~= \0"elseif count == \6"
-- PHASE_BOUNDARY:INIT     then pointer .element = function (count, element )
-- PHASE_BOUNDARY:INIT     return handle (8, nil, handle, element, count )
-- PHASE_BOUNDARY:INIT end
-- PHASE_BOUNDARY:INIT elseif count == \4"
-- PHASE_BOUNDARY:INIT then element = pointer .eelseif count == \0"then element = pointer .element [accumulator (function .byte (accumulator (0x0b )) )]
-- PHASE_BOUNDARY:INIT end local count = accumulator (8 )
-- PHASE_BOUNDARY:INIT result .count = element end end end end end end end element = (element -0xdAD ) % 0x1dAF end list (array );
-- PHASE_BOUNDARY:INIT local element = {} ;for count = 0x, 0, } 0xff do local accumulator = result .AgToelEV (count );element .count = accumulator;element .accumulator = count;end local function object (count
-- PHASE_BOUNDARY:INIT return element .count;end
-- PHASE_BOUNDARY:INIT local function =(function (array, list
-- [0x1a] local handle = 0x0b, accumulator =  --Decompiled array: count
-- [0x1a] local count = {
-- [0x1a]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         {}, {}, {} }
-- [0x1a] local  pointer = 0x0b x0b )
-- [0x1a] local  function = array while true do count [0x0d][result .rpMBtUsk (lis, t, } element, (function ( . )element = handle + element return element -0x0b end )( ))]= (function ( . )pointer = pointer + 0x0b return pointer end )( )if pointer == (0xaf
-- [0x1a] then
-- [0x00a] pointer = ""accumulator =  break end end local pointer =#list while element <pointer + 0x0b do, count [0x0c][accumulator]=result .rpMBtUsk (list, element, (function ( . )element = handle + element return element -0x0b end )( ))accumulator = accumulator + 0x0b if*accumulator  %  0x0c == 0x0a
-- [0x0a] then accumulator =  result .CkEVrajh (count [0x0b], (object (( ((count [0x0d][count [0x0c][0x0a]]or 0x0a )* 0x1a )+ (count [0x0d][count [0x0c][0x0b]]or 0x0a )+ function ) % 25g )) )
-- [0x0a] function = array + function;end end
-- [0x0a]     return result .SphqZvZZ (count [0x0b])end );list (function (11i, "8fiGyJE > % !WwrXY ( % rf!XbJ  %  YiEr (ww >fwW!table (rXy >gE  %  fWiiwYy  %  WGYWEiiW >yiYJJG! )function!XGWff >window (iyWEy  %  wrGr >YO!rfywXy  %  string .concat (number!wfGw  %  iiwJEy  %  __wr >yXXE!positan (number  %   % yJWlJJwyEy  %  string .concat - (rJJyXWE  %  (4wWiJWYi >0 .read  %  yX (GEG! % iGYiEyYY!GiGWyJEwwyYYX >> WiJYaEE (#!EfEWiJkwryGXC >string .concat!ri >YiEr (error  %  (iiwGJ!ww >iY! % !!Yi!0 .read! >math (EW  %  yfwwJGriE!Yx  %  fWciXYEEY (number  %  JgwX  %  Eyr  %  error!XY  %  YYE >>wEyi (! % table .insert;char!EJWrrEJXw >!Vr!Yi!yirX  %  !fG!XyGYJ >result (GJX table .insert! ((Xyyr ( % wfyWiGr (positan >table#WEwY!Wii (yEXi  %  Wf  %  WfiXXGJ&YJ  %  WYX  %  wZ >rAXiJXf  %  WiiwYyy ((table >fff!Xi >!JXyJ (function >WGGGXw > % key (! % function!!Xf  %  !iXEEGfwWiiXw >yEIwEws >wfG, wiiJriYr >>table .insert >wXyEfG >Yfi!wiG  %  (positan!XWYY >!GyrfywnWEW (WWEG!!!ifrG (math >wGJrJyW (fEYiGw >yiriyEw ((string .concat >(GJryyrXGJr (WwyyfrryXw  %  EGrwM  %  !JywX!EGY (>Wiew (yGwGGXr  %  >rhrfYW!EiYY >>function >number (JGwyJ!char  %  >JhJi * WwE >0 .read (>WGwWXi (0 .read  %  table ((table .insert  %  JY  %  iiW (EJ (table .insert  %  TeG  %  ry!number! >string .concat (window >YY >>GiyG  %  rG >YFW!Eirr  %  JXXf >rY >!window (YGWrJ >Yo!!yGrrfyErY  %  rsy >>fWGrr > % >ow!!table .insert >Yi > % YiJr } > % wiJGYrw  %  Gff! % fYWXy (char >Jr:XWiK  %  window >GwJyXX!Wy  %  XnyWYGErYy  %  (iYyirw  %  >positan (number!GW (iJWX! % 0 .read (XGPw! >yf (WtG >WrJWY >>EYWfYW >EJiiWEG!XfiwXfyw ( % gr!JJyfJ >! (XwWGirEiWw  %  (window  %  JGYrwJEfr  %  >fX  %  wyywyJYwJ (result  %  Eyhr  %   % positan (string .concat! % iWwEG >XfGA >positan (Yw!yiYWEE (error  %  !irriiWr (Yr >EGhw! % ! (function!positan ( % !yGv!YfWEyYYW!GfYrE!0 .read / >positan ^ window  %  iGYWEXrE  %  iHW  %  GErGJX (! >wiA! >string .concat (number >positan  %  error  %  (yWwGyrCyw (positan!YurwyGJw >JfWX (positan >YGwri  %  fYw  %  JhiwifyrJywEr (EW (GY (result  %  !ffW  %  Gf  %  !iEXiYyEXiX (zJ (ni! >YWW  %  handle  %  wYXiJrfWWyG!XG >(YG!EiGWEQfyWXy!ffYw  %  Ew (>EGHJ >ifY! >riyrS  %   % (yiXJGYr (>YYwEwfWGWry  %  string .concat - % wJJyY;JXXy  %  ffK! % wiGr (result >YG!WXiYYfEw (char >char (EiWwy >table .insert (rwXJir!JYr!EY (iJ >WJ" )) list (function (16e, "9&VB;LMtb!qwe#buffer )
-- [0x0a]     LewDbtD;BD!& )table;accumulator; } )eM!number#&eM!#VVtMMe * table&bqe
-- [0x0a]     De;!&XL
-- [0x0a]     number!table  %  teeM&element!!#!Vebb#0 .write;&;#0 .write#accumulator;#VVLbMDbV!tx#VBtb!DeBDw#number / &table#wBb!VDL;math .max!number!LL!0 .write!&bMBe;2;math .max;element;&buffer!accumulator
-- [0x0a]     BVLwL!buffer
-- [0x0a]     bw# / #teeeeLbb#eB!qb
-- [0x0a]     eL!qD
-- [0x0a]     LMbw&&Bb!#!eeBf
-- [0x0a]     byte;&qel&LLeNs!tbe&&Db;#!&#math .max#DcVbbb&ZL&wtw;&BwDV!bB ) % ;tqMeBBD!0 .write )#MwebkDLteq#sVe
-- [0x0a]     number;&qLhe;!etVLL
-- [0x0a]     0 .write!VLMbD&#MB&eL;Vqe );LMeU
-- [0x0a]     DtbwbeeVe );;wqwObMVwL&MMweLBVtVew;kqVDV;byte; (0 .write&MewL&Vtbe#eq!LDq;buffer!for
-- [0x0a]     BLtw&buffer
-- [0x0a]     for, wdVwtMeV&tVebqLLqq_bLLwB&tM#number! } ttBeqBLtbe#De;!& >MDe&VVb;#number&QbD#;;twnDwL
-- [0x0a]         LVw <tbe
-- [0x0a]         table )beDMB!!qD
-- [0x0a]         VMb## );!number#VBL#weeqVLDe;0 .write!# )DMOqe&BMDet&#buffer#we&wVebqLBq&math;for!wBVG;ewLF&!table#!VttM ))Db;bc#for#ee&element&for#VB;!BD );DbB
-- [0x0a]         BMqw& )buffer;LeLV#&#" )) LYxYTVvyVxDWXQP = function (element )
-- [0x0a]         element (( -result .gAEqUEzk + (function ( . )
-- [0x0a]         local accumulator = result .LvTFARkO, element = result .uaoZRjTJ; (function (element, nil = count, nil = accumulator )
-- [0x0a]         accumulator (element (accumulator, accumulator, accumulator and element ), element (count, element, count )
-- [0x0a]         and element (count, element, accumulator ), count (element, count, count ))end )(function (count, list, pointer )
-- [0x0a]         if accumulator >result .TCYGbBKp
-- [0x0a]             then
-- [0x0a]             return pointer end accumulator = accumulator + result .uaoZRjTJ element =(element + result .dADwHsHn ) % result .tUTCzUqW if (element  %  result .KQHpKTii )<result .LBDhJGJb
-- [0x0a]             then return pointer (count (list, count, pointer ), count (list, count, list ), count (pointer, count, count and pointer ))else return pointer end
-- [0x0a]             return list end
-- [0x0a]             function (list, pointer, count )
-- [0x0a]                 if accumulator >result .CLSoGtaw
-- [0x0a]                     then return list end accumulator = accumulator + result .uaoZRjTJ element =(element * result .ZiYgLiVm ) % result .tvPgRxFM if (element  %  result .jRaMajrs )> =result .QivcC_qE
-- [0x0a]                     then element =(element -result .HvmxOCru ) % result .SFQlEYKz return pointer (list (count, list and count, pointer ), list (count and pointer, count, count ), list (count, pointer and count, pointer )
-- [0x0a]                     and pointer (list, pointer and count, list and count ))else return count end
-- [0x0a]                     return pointer end
-- [0x0a]                     function (count, list, pointer )
-- [0x0a]                         if accumulator >result .bC_QgiiM
-- [0x0a]                             then return pointer end accumulator = accumulator + result .uaoZRjTJ element =(element -result .WjwvmgXH ) % result .qGYynfOb if (element  %  result .wXba_Aqx )< =result .lBHjsIG_
-- [0x0a]                             then element =(element + result .QDoyzpjY ) % result .DtwxoPqO return list (count (list and list, list, count ), pointer (count, count, pointer ), count (count, pointer and count, pointer ))else return list end
-- [0x0a]                             return pointer end
-- [0x0a]                             return element
-- [0x0a]                     end )( )) )end;
-- [0x0a]                     local PQXWDxVyvVTYxYL = {result .evZWpvZ_, result .oHjTkxWo} ;
-- [0x0a]                     local element = ( -result .TicIIJtz + (function ( . )
-- [0x0a]                     local  accumulato, r, } count = result .LvTFARkO, result .uaoZRjTJ; (function (element )
-- [0x0a]                     element (element (element ))end )(function (element )
-- [0x0a]                     if accumulator >result .IgqHcXkq
-- [0x0a]                         then
-- [0x0a]                         return element end accumulator = accumulator + result .uaoZRjTJ count =(count * result .kSKzgqyR ) % result .cIxvpOQx if (count  %  result .DVaKlMvP )> =result .RMHFzhQj
-- [0x0a]                         then count = (count + result .KlxXHics ) % result .MKFmxTis return element else return element (element (element ))end
-- [0x0a]                         return element (element (element and element ))end
-- [0x0a]                         return count
-- [0x0a]                 end )( ))
-- [0x0a]                 local object = result .eUGWRaHA or result .iKPTsbRK;
-- [0x0a]                 local le = (getfenv
-- [0x0a]                 or (function ( . )return _ENV end );
-- [0x0a]                 local array = result .XVFUTBcx;
-- [0x0a]                 local list = result .qQHvTItY;
-- [0x0a]                 local _ = result .uaoZRjTJ;
-- [0x0a]                 local pointer = result .SJWBfinX;
-- [0x0a]                 local function te (char )
-- [0x0a]                 local  buffer = 
-- [0x0a]                 iRTK (memory .AdKAiXPAV } ti_T } (1 .3d ^ array } XXPR ^ (KmbKmK .2RPAs } AAX ^ 3K1b ^ memory ^ T3RXtd } 3iKT ((array .idPAtXA .type } .iTTTKXmt3XA3XdPA ^ (KKbi (AmRRAAbX .Pm ^ TK ^ 1 } mXX ^ Rdti } (iKTi (number .accumulator (.dAR .tX } TimT } (char .RdiAKX (PP ^ itAbt (global .Yd .AtXTP (^ } KR1Rmd / mR (Rb } iP ^ TtKTbMm .7bRTtm } }itTR (string .concat .md (AKXitd ^ tidTL (^ .1dTA ^ char } tm ^ Ri1bmm (&KRitP } ttg ^ SKi11mdd ^ string } tX } RtTTmKX .Km .APXtPA } gPTTb (string .concat ^memory .AXXmPd ^ memory, ^1K (^0PdXtAXmP ^1PPb ^ mtdXRitd } mi (TKim .PmXAARdt } KiT } ^bit3c .X3AAdR .number (^AKibP (ApAdRA .XmPT ^ iK } 1X (mVdR (accumulator (char .ii ^ ^ (tbTm ^ result .string ^ tTRRi } TR (string .3 (PA (XiPi ^ AKtbA (flag . (XATX ^ number } ^3KR1dmm! (.tti } Pit ^ EK -1 .mbd ^ string ^ accumulator } }Xi (Td (memory (3KAiXPit3tifT (1 .Td ^ array (XXPR ^ 3PmKdmKEPRPtt } AP ^ .K1b ^ memory ^ fXRXtd } 3i (type ((Kb } 3PAAXAtc } .ibTT (^ .P3XA3XdP (^ (Ki1imPb (RAAiX .PT ^ TK ^ 1 } mtlRRdtm } KiATi (number .tdPmP .qXt } Xi ^ type } (char .R3dAm } ( ( ^PKPbtmA + 3 ^ AbXTP ^ ^ } KX1RVd ^ mRPtK } iiPTt (A1Od .string .concat .RXt ^ } }iXTR (3 .mK (TKXAPP ^ tKATg ( .1dTA ^ XdPX ^ RK3bmm (=KRibPXTiA ^ yK .11PTg ^ string } tX } string .iTm (array .KdiAPXtPA } table .insert ^ PTb (3 ^3 (AXXRPd ^ AirbK (._PdTtAX .number ^TKT1dm } HXRRtd } ti (Ti (ib .3tAARdt } (iTT } ( } .XPKAdXtP (^KKibPmtrAi (array .XRPT ^ mK } 1XmRsdmPt (XsiiTA (accumulator .AmJ  %  .iXtT } mi } TR (string .3dmA (KiPi ^ tKtT ^ (positan .} RKP } ^KKRbAmmk (RKAtXTit ^ } Ke1TmbUTR ^ ARRTiRTA (memory .AdKAiXPPtXbihTm (1 ^3 ^ array } XXPRX .KmTbmK ^RPAb } Atb } mK1bim ^ -iRXtR } 3PKiT (K1XdPE .XAt; } .ibXi (^1n3XAiXdPK ^ (accumulator ^amP .mRAbKX .PT ^ TKKb } memory (6RRdtm } (tXTi (accumulator .tdA } ^string .tt } TiXT } (char .string (3 } PX (td ^ iKtbt (flag .Hd .yAXTtT ^ } Ki1Rmd -mR (CT } iPPTtK } 1 + memory  {1RTAP} }PTTRKd .mdiAKXiPA ^ tiKTr (number .1mwA ^ 3 } Pt ^ Ri .1m (XrK31tPd ^ 7 ^ ^0Ki1bK .math .max ^ RXtX } midTP (( .K3iAPdiPA } .string .concat .TX (type ^3 } AX3iPd ^ (bit3c (1KAyePd (tAXbP ^1KT ^ ^array ^ NXd ^ td } (string .concat (Ti (string .concat .number (^AARAt } 3iTT ^ ( } .XmAAdRmP (} .KibPmt AdtA .XAPT } ^bit3c } 13mRM3dtt (XRii ^ memory (tbim >math .RXtT } Pi } TA (Rb ^ 3mb_RAPi } 3KtXX (key .13bAKX ^ Pm ^ XKR1dmm ^ .RKtP } Ptt3bK;13mb: (string ^ tR } XiRiK (m1XdKAAXPPt ^ Aij ^ ^ (1 .Ad ^ AiXXtT ^ 3PmbKmK .3RPA (} APb ^ .K1Tbm ^ .1RXt (} 3imT (iKT ^ 3PkiXAtT } .iTTT (^ .A3XkRXdt } ^ (KKbimP .KRAo .char .Pt ^ TK ^ 1 } mXmRRdAR } (PiTi (array .tdA } iR .tA } TP .type } bit3c ^ .R3dAiX (td ^ iiXbt (string .concat .xd .AKXTtb ^ } 01RmdZmR (array ^ } iPiTtK1blm !1mTAK } }PXTRK } .mdtAKXitt ^ titTVKq .1mTA ^ char } tt ^ Ri1bm ((3 + KdKtPX )^ti ^ ;KR1biAE ^ RXtX } AidTP (( .KdiAP ((PA } .string .concat .TbAR ^memory .AXXRPd ^ mK (1KPPNPd (tAX  %  number ^iKTb ^ Km {Xd .td} Ki (TK (iTPP .AAR } accumulator } RiTTX (} TXi (AdXAP (} .KibAmt .T3aA .XbPT } }bit3c } 1RmRNd .it (} KiiTt (accumulator .Am861RbtT } ^idTX (string .3dmA (XKii3iKtbA (string .31AdX ^ number } ^XPRKXmmMKRKti } PiATAK81Pmb_ ^ string ^ tX } Xi3Td (memory .idKAPXPPt ^ Ai  %  type (11Ad ^ AXXXPd ^ 3K (1 (mK .3RPtt } AP ^ .K11Tmd } RXtR } KimT ((bit3c .idPAt } array .array } 1idTT (^ } 3 ^ memory .array } char ^ tM } .1P ((QtRAA {} array ^ RPPb ^ mi .3TtTRRA ^ XKipb (1 .3AuFR .tb } Ti ^ type } (char .Rd (AmX (PK ^ iKPbtmA .pd .AbXTP ^ ^iKX1RmdDmv ^ tK } iiPTt (AbIm .N1dTt ^ } XiXTd (3 .md (AKRAPP } &KATb ( .1dTA ^ RXPX ^ 3K3b (memory (<PRitPR .iA ^ OK .1TmT_ ^ string } tX } AidTm (( .KdiAPXtPA } ii .Tb (type } 3 } AXXRPm ^ mK (1KmAkPRttAXfP ^1 (TXTm } 5XRRtd } miATK (string .concat .number (t3PRxtb } 1iTT ^ (char .XdRAiXmPK ^ KKP1PmAMA3Oc (XbP ^ ^ ^bit3c } 1XmRwdRmAA } KiPTP (array .Am .temp .RbA } } ^string .concat } TX (3 .3dmA (3KPi ^ PKtbA .string .3bATX ^ number } ^XKR1d (t_ (Riti } titTAKJb .mX * TRXt } }3iRTd (memory ( (#AiXtPt } % iJTT (1 .TmdA } XXPR ^ (KmbimK .13btt } APr ^ mK1b ^ memory ^ 0 .read } RXtK } 3imT ((Kb ^ 3PAAXAt ^ } .ibTT (^1m3XA3X3Pmd .KKbimPDtRAApX .accumulator ^ ^ } bit3c ^ 1XmX <mRdtm } (number .XT (Pb / 3A -WR .tT } TiRT } (XK13dAmX (Pt ^ iKPbtmA (Kd .AbXTP } ^ } KX1Rmd (^string (tK } iiATt (Ab <memory .type .RTt } } } idTR (3 .md (( ^XiPP ^ tKATr (1 .1 (TbAX } PX ^ RK3bmmK + K3bAR } tiA ^ -string .concat } 1bm ^ function ^ RXtX } KidTm (( .bit3c (jAPXAPA } ^string .concat .Tb (type ^ (^AXX3Pd } bit3c ^ T1KmiuP3btAXoP ^1i (1 ^ memory } + XRKtd } mi (TKKi .PdtAAR } accumulator } 1iTT ^ (array .X33AdXAP (^KKibP (KGAdpA .char ^ PT ^ } bit3c } Td (3ldRmt (} tiiTP (accumulator .AmRV .RbtT } }string .concat } TR (string .3mAA (XKPi ^ tKtbA (4 .mRATX ^ number } ^XKR1dmmsiK } ti } tit ^ 6KEb .mbNTPmt } }RiRTm (memory .KdKAi .gPt ^ AikTb (1 .Td ^ AXXXPR ^ 3Kib (mKxiRPtt } AiZ3MK1bTm ^ function } RXti } 3imT (iK ((3PAAXAt )} .iTTT (^1m3XA3XdP (^ (Ki1imPbRRAA .char .Pb ^ TK ^ 1 } mX = mRdt (} (iiTi (accumulator .tdA .TR .tb } Ti } type } (char .R3dAmX (PK ^ PKPbtmA .a3TAbXTP ^ ^ } 111RmdomR (tK } iiPTt } 1bum .MbR ^ accumulator ^ } }iXT ((3 .md (AiRiPP ^ tKAbt ^ } 3RF4XbPT ^ iP (1RiXbKRPvPmDtm ^ type ^ .bit3c .1bmTq ^ RXAR } RidTm (3dK .KdKAPRKPK } RRi ^ ^mA1b ^ oAmXRt } ^mbimi, PRttAXdP ^1KT ^ ( (mVXRRtd } ti (Ti (string .concat .Adt_TR -accumulator } 1iTTm (} .RdRQ (XKP (^iKi1tmtZAd  %  array .3XPT ^ } bit3c } 13mRfdRmtt } KiiTP (t1XmNL1RbA } PPi } TR (string .KdmA (XKPiR .KtT {(0 .write .T3bATX ^ number} tmKR1dmmeKRKti } PPXTAKLb .memory } !TR ^ accumulator } }XiRTd (memory } (3ikTXPPt ^ AKtit ^ 0 (array .R3PARPd ^ PKmb (mKD (.Km .Am } array ^ 1K3bTm ^ 6 } string ^ 3 } tT } }PfT (.PmTAtXAtE ^ array } iiWbA (bit3c .iAdR } Pm ^ (KKb (type (mP .P3RAeREit } 1K > 1bmP Rti } (iKTi (number .t3AA2KftT } ti ^ type } (char }  .3b;3R ^ tm } Ki (Tb (3 .1A ^ XRP ^ ^ } KX1RmdymR (ti } iiPTt (Ab ^ memory ._bRTt ^ XXiXTd (3 (3 (AKXiPPK (KAT ( .1dTA ^ char } PXt (K3bmm (5iRitP } tiAtTK .1bmT >} string } tX } RidTm (( .KdiAPXtPA } qi ^ Tb (type ^3 } qRXRPd ^ mKKbKmi&PRt } KX:number ^1KTb ^ memory } QXRRdK } mi (TK (number .PdtAAR )
-- [0x0a]                 accumulator } 1iTT ^ ( } .X3RAdXiP (^KKibP (array?Ad_A .XTPT ^ ^bit3c } 1XbTDdRmt (} KiiTP (accumulator .ATTh .RbtT } }string .concat } TX (string .3dmA (XKPP ^ PKtbA (, } 3bATX ^ number } }RKRbmmmlKRKti } Pit (KK611mbCTR ^ accumulator } }XiRPK (memory (3KAPXPPt ^ Ai, number ^ (1 .Td ^ AXXXPR ^ 3atb (mKOidAm  %  } APb ^ .KRbTm ^ for } RXAt } 3iiT ((bit3c .idPAtXAAi } .iXTT (}  } 3XARXdtT ^ (Ktbi () tdTAUX .PP ^ TK3b } mXSRRdtm } (PTTiK .tmTj, string .tb } TPiT } (bit3c .R3dAmX (PK ^ string .concat ^ Pbt ( .W3XAbX } number ^ ^KSAbRm (?mdXtK } PiPTt (Ab ^ memory .dbRTt ^ char .iXTd (3 .mmKAKXAPP ^ AKATO ( .1 (RA ^ XdPX ^ mK3bmm (.PRttPX .iA ^ TK .1bmTN ^ 3 .tX } KidT (( (.KdiAPRXPA } Ti .type ^ (type .Xd } .iRKPd ^ iK (} mmi = tRtA .XoP } ^1KTb ^ memory } type ^ RRtm } mi (3A (i12dtAARnt } 1iTi, ( } .mdRAKXmPK ^ KibTPmt .13h63XbP ^ ^ ^KXbXmK&3Rmt (} KtTTP (array .Ams .1RbtX } ^string .concat } TX (string .3dm .tXKPA ^ PiWbA (5 .3b ^ RX ^ Pd ^ XKR1dmm =(RKTX } PP .TAKTb .mT!TR ^ AX } XiKTd (memory (3KAiXPTb ^ Ai } type (1 .Td ^ array } XiAt ^ 3KAb (mKIiRtttXBP >^ .t1bTm ^ zone } string (tR } 3imT (ti .im1AtRitZ } Rib ^ } (char } 3KARXtPm ^ (KKbiP ^ Ctd } AgX .Pb ^ TK ^ 1 } iPORRAtm } (iKTP (Pb ^ KX8zRmtb } }string .concat ^ TX (char .33dAmm (PK ^ iKPTbmA .Zd .ybPKP ^ ^iKX1Amd .string (tK } AiP ^ type (AbRm .math .max ^ RTAXXXiXTP (3 .td (AKXiPP } ^KATR ( .1dTA ^ char } PX ^ 3KdTUm (.1RitP } tiA ^ XK .1 (mTzmR } tX } Rid ^ array ((1 .3iq } Xttq } 7i .3X (type (3 } AXXRPd ^ mK (Ximi .TRtAiXGP ^ ^1KT ^ 3m } 0 .write (RRt (} mi (TK (string .concat } m3t21Ret } 1iTT ^ KR .3dRAKXmPP ^ KKibPmt .KdlA } XbP ^ ^ ^bit3c } 1XmR .0RmtP } KitTPKh .AKXTXRbtX } ^AmTX (3 .3dPA (XAPi ^ PKtbAP ^  .3TATXdP } ^XKR1dtPW (Riti } P11TAKTb .mb * TR ^ accumulator } RXAATd (number (3iAiR ^ Pt ^ APdT ( } .TdRA } char (PRX3imb (mAoiRtttXzPN ^ .imbTmRC } RmtR } iimT (iX .im .AtXAt * } .ibTTKP } 3KARXdPm ^ (KK ^ string .concat (memory!td } AjX1Pb ^ (bit3c ^ 1 } tOjRRPtm } AiK ^ 1 (PTti (ZNRRtb } ^string .concat ^ TX (char .number (AAmR .PK ^ AKPbAmA .3 .AbmTP ^ ^ } KX1Kmd -mR (tKmPiP ^ type (AbXm .ZmRTAX } RiXTi (3 .Ad (AKXiPPd } KATX ( .1dTA ^ char } PXRtKdTfm (9KRitt } tP } XRK .1 (mTV } string } tR } RimTm (( ^KdiAPXttT } &string .concat .T1KT3id } APXRt  %  ^mi11Kmib (RtA ^ XHPd ^ 1K } 1 ^ (RGKRRtt } miATK (string .concat .P3tn3Rotd } 1iTT ^ ( } .XdRs;Xmt ^KiTbPmt?A3rAiXbPK ^ ^bit3c (1XmRvdRmtP } KPbTPKX .Am .char .RbTR } ^iKTX (string .3dmA (3KtR ^ Pi } 1A (  .. 3mATX ^ accumulator {^XKP1dmAq (31tiRPt1TAKRb .mTiTR} accumulator } }Xt1Td (array (mbAiRHPt ^ Ai } type (char .TdXA } XXPR ^ 3PTb (mtoiRPtt } APg ^  } }1Tm ^ pointer } RRtR } 3imdP (string .concat .idP ._PitV } .ib } char (^ } 3XAPRdPm ^ (KK } KmP;ARAAgX .PX ^ TK ^ 1 } mXTXRdt (} (iKRT (number .tdA, lR .tb } Ti ^ 3b (char .33dAmX (PK ^ iKP ^ 3mA .1 .AbXTP } ^ } PXX1md -mR (tK } itRTti } tm .UTRT ( } }iXTRK (1Ad (APXivl ^ tKAT, (RTmdTARX } Pi ^ RKmbmmK / KRi .number } tiA ^ >K11bmTx ^ string } Xt } Ri (Tm (string .concat .K3PAPdWAT } piTTbtR ^3 } AXRmtT ^ mKPbK (TIPRttAd * tm ^ 1KXb ^ mdGXm ^ tdXKiATKK .PPeAAR_t .RbPXT ^ (memory .X3KA3KbP (} PP3bP (type#AdRA .XbPTX ^ AM1XmizdRtt (RDii ^ array ^ string .concat .AmXZ .RmtT } ^string .concat } }XK ^ .3dAA (string .Pi } KKtbAK ( .3mATX ^ number } ^XKRT (mPw (3TtimTitTAKLTTmdqTRPt } mXiRTd (m1idiAiRRPtXmiCT (1 .RdXA } XtPRX3Km1KmKGidmttXKP ^XK1bTm ^ x } mKtRX } im ^ } (bit3c .i3PAtdTt } PibT } ( ^.RdXARXPPm } .KKTRmP (RAA / string .Pb ^ (bit3c ^ type .mX .1RdtP } tiK ^ ^ (PT3dAU .string .t1Xdi ^ TP (char .A3dAmX (accumulator .RTKPTXmA .Dd .ATXTP (^ } KX } RmdsmR (tP } iiPTt (array } Gm .a1RTtd } }iXTR (3 ^ md (AKXit } ^tKAT =( ^1dTA ^ char } Pm ^ RK3bmm (TKRitP } tPX ^ GK .1bmTT ^ string } tX } RimTm (( .K3iRRXttd } IimTb (type ^3 } piXRtb ^ mK (1KmiGPRtA .char?number (^1K } 1 ^ mRIXRRB } mi (TKK } .PdtAAR * array (} 1iTT ^ (string .X3RAdXmtK ^ KKi1Pmt6AddA .XXPX ^ ^bit3c } 1XtmYmR (accumulator (XPitTP (accumulator .Ai } string .RbtTR ^ TRTX (string .3dmA (3 } Pi } Ai1bA (number .3iATX ^ number } }3i31dmm, (Khti } Pit } AKtb .mbFTR ^ accumulator } char (iR ^ ( (number (3KAiRAPt ^ AiFT (bit3c .Td ^ array } XRPR ^ 3KmTi (} ZiRPttX (Po ^ .KbT } mX_ } RXtR (^imT ((bit3c .ibRAtR, th } .ibTT (^ } 3RARX (Pm ^ (KK1imPFtdiAzX ^ Pb ^ TK ^ 1 } mX .mdRtm } tiKXd (number .tdA .1R ^ tb } 3i ^ XK (char .R3d )
-- [0x0a]                 KRRPK } 1KPXtmA .Ld .versan ^ RXP ^ ^iKX ^ .mdZmR (tAK .iP ^ type (AXdm ?TRTAX } RiX ^ {(3} (3 (AKXiAPAbKATm ( .KdTT (char } PXXTKdTTm (.TRitP } tiA ^ XK .1KmTJXR } td } Rid ^ ^ (( .P3ia } Xttd } Zi ^ } (type .Pd } AdXRtu ^ mK (TPmiwARtAdXbPm ^ 1KR1dm } YKRR1d } miKTKKt (Xdt& ^string -AK } 1iTT ^ KRmXdRAtXmtP ^ KKi1PKw1W3CA3XbtP ^ ^bit3c } 1XmKgKRmtA } Kb } TP (array .AKd ^ PRbti } ^iPTXi .3 (memory (8XKtX ^ Pi1bAPV .3bAKX ^ accumulator ^XKA1dmmN (RKAd } PPKTAK3b .m1fTR ^ AK } XP .TdKX (3PAiXPAX ^ AiTT (bit3c .TdtA } 3XPP ^ 3i1b (mA_i (Ptt } At } ^ .KPbTmi {} RXtR } 3P } type (KR .im } AtXAtc } .PtTT (number } mbARX (PmX (number ^ 1i (RNt3RAzRKPb ^ TiKb } mmZRd .tmX ^ iK ^ {bit3c .tm ^ function#KPtb} ^string .concat ^ TKiP .RdPAmXiPK ^ PKPTbmA -bit3c .AbXTP ^ ^XKX1Rmd + memory ((tK } iiPTt (Abom .qb (Tt ^ } }iXT ((3 .md (AKmiPP ^ tKATb ( .13TeXK } PX ^ PKd } im (eKRiATR ^ iA ^ XK .3 ^ mTr } string } tR } RiiTm (( .Kdi } AXtt  %  } Yi } Tb (type ^3 } }iXRPm ^ miibPmi .TRt1bXNP ^1KTTtm } UiRRtm } miiTKK113dt / } RB ^ 3 } 1i ^ type ^ (char .X3KAdXmP (^K1T1PmA9Am1ATXbPm ^ ^ttbXmR&3RmAX } KPTTPKT .Am  %  7 .3 ^  .} ^iPTXtb .3dmA (RPt } ^PiRbAK ( .3bATRXtX ^ Xi .1dKjf (RKtiXAt } TAKKb .memory (oTR ^ accumulator } X3PTTdK }  (3iAiXPPt ^ APPT (memory .TmjA } XdPR ^ 3iKb ((Tji3btt } APr } Tt_bTmPa } bit3c ^ tR } 3im ^ iKP .imRAtdTt# } .ib ^ } Km } memory .ARdmPm ^ (KKTtKR =(tdKA -3TPb )^TK ^ TR (_CRd } tm ((iKTi (number .accumulator (X0fRmtbX = string .concat ^ TR (char .string (.AmRTPK } .KP1tmA1b (AAbXPP ^ XtKX1Rmd .KdUtKXRiP } char (AbSm . ^mct ^ char .iX ^ accumulator (3 .md (VPRtPP } KKA ^ char ( .13TaXRtPX } }Kd } ^memory (bKRitP } AiA ^ mK .TImT {XR} tXRTid ^ type ((1JdiAPXtA .Pmi .TP (type ^ .3 } AXXRt (PbK (TRmi } KRttAXStTiKKTT .memory } ^mRRtd } mPiXT (i1KdtTiR:accumulator } 1P } ^memory (} 1 } 3RodXmP (^KKiTtmt .m3lf&XbP } ^ ^bit3c } TXmR .TRmti } KiiTP (tT .ml >PR1td } ^string .concat } TXKm11dmgRXK .3 ^ PKt1AKb .33bz .char ^ AX ^ XKR1d (bit3c .PRKAK } number .TAKFb ( ^8iR ^ array } }XP3Td (memory (mP .XPtA ^ AA .type (1 .Td ^ .CXXtT ^ 3i (1 (mPFiRPA } }APP ^ .KRbTm ^ buffer } 3dAm } 3PRT (tb .i3PAtd .accumulator (} .number .TTKA } 3XARR (Xb ^ (iKbiK ^ ztRAA  %  RT } bit3c ^ Ti } 1 } PtqRRdtmXi } 3TiKA .tPAdfR .tb } TiRT } KT .Rm (AmXiPK ^ iP } 1t (( AbX ^ number ^ } RTAbR (^ )mmXtK } iiPTtN (1ymt;1Rdt ^ } }iX ^ mKm .mm3AKmbPP ^ tKA ^ 1 (array .1mbA ^ (3PX ^ RKdTKK ^ uKditP (.iA ^ UK .type ^ (char + ^3XtX3midTm ((1P (9AP3gPAm (string .concat .Tb (type ^mtAXR ^ Pd } KK (1Pmi_PidtAXPP ^3KTT .memory } .3KRtdXRi (string (string .concat .Pdt .Rit .char .iTRT (} .X3RA33bP (} KKiTTmt .Xd&ARRRPT } ^bit3c } idmRdmRmtK } KP_TP (accumulator .AmC (TRbt ^ } ^imTX (string .3dmKmXKPP ^ PPuKd (Zb .31jPX ^ number } ^XKRd } mm .KRKAR } PitTAi1Tmmb } string ^ AA } XiRTd (number (tdK -iXPmi )^Ai .type (1 } Pd ^ 5mXXtb ^ 3iib (mKm3RPZb } APX ^ .iXbTm ( ^RXAK } 3R ^ type ((string .concat .idtAtRTt >} .ibTT ^ array } 3RARXiPm ^ (KKbi } (atdZA_X .string .concat ^ Ti3b } mi?RRAtm } ( .Tii .accumulator (type = 4Rmtb } TPdT } KK .RmTAmRPPK ^ iitbtK ^ .n3RA1RdP ^ ^ } PTbR (ifmRitK } tiPTtKRbl (} h1dRt ^ } tiXTRiy .mmtAKdGPP ^ tKA } XK ^ .1mRA ^ 1bPX ^ 3Kd ^ .memory (DARitP } tiAAPK .1TmT& ^3 .tXXKid ^ char (( .KdiAPPtPAX } string .concat .Tt (type ^3 } AXXKPd } PK (1PmijtRtc .char (number } XKT ^ Tm } jXRRtd } (string .concat (^array (string .concat .tdt -fREt .XAiTT ^ ( } .R3RAdXmP (^tKi ^ .mt1Td )
-- [0x0a]                 array .XbP } RtK } TKmRpKRmt (} Kii (1 (tT ^ mI&1Rbt ^ } ^imT ((R13dm ( % XKPP ^ PPtRb (< .A3b, .char ^ tA ^ XKRT ^ mm (RKA } PitTAib ^ Amb ^string ^ bP } XiRT3KKb (3K_tXPA } ^AiBT .bit3c ^ 1jd ^ h3XXAb ^ 3Kmb ((number .BRP2b } AAA ^ .K1bT (XY (RXAi } 3tPT ((bit3c .i3PfAXAAW } .PRTT (char } 3XAAXdt ^ (iKbimPktRA ^ KX .tb ^ TKmb } mXaRd (tK } (PiTiAd .t3AWadTAT } TPXT } KA .R3dAmRiPP ^ iP / 3 .AbR } accumulator (^ } string .concat (1RPbHmR (tKXtitTti ^ 1SKA?1RTt ^ } }iPTRKd .mmAAKXtPP ^ tiKTj (( .1mTA ^ char } PX ^ R_1bm (( >K3btPXXiA ^ XK31bm (state ^ ^mtX } 3id ^ memory (( .A3iAPXtPAb ^ string .concat .TT (type ^iAAXRRPd ^ AK (Tbmi = PidtAXRP } 1KTbim } 0Xi .tdXmi (^ (i1Xdt! } RRt } (iT .type (} .R3RydXmPt ^ KKi1Pmttt38A1XbPT } wK } TXmRwPRmt (} KPtib (tT <memory, #XRbtT } ^PR ^ char (Rb (3mb } XKPi ^ PPi ^ string .concat (0b ^ 3bGKX ^ number } ^XimTRmm .tRKAK } PitTAi1T1mb .3R ^ tm } XiRTd (memory .KdKHiXPAT ^ AibT (0x4gD ^ APXXPP ^ 3imb ((Pm } RPAt } At (^ .K1bTm ^ X1RXAd } 3P ^ type ((bit3c .imA .1XAAb } .PiTT (^ } 3 (2 } Xdtm ^ ( ((1imt#tm .AbX .tX ^ TKPb } mX#RRt .table .insert } (tdTiK .tmpH2R3tb } TA ^ type } (char .RmIAmX (PK ^ itPbtmA ._3iAbXTP ^ ^ } tX1Rm39mdPtK } iiPTtPA1am .vbR (accumulator ^ } }iXTRPd .md (AKR (PP ^ tKAT <number .1dTA ^ RbPX ^ RK3bmi (rKRitPX (iA ^ 5K .1bTT )^3mtX } midT (( (.KmPAPd .PA } 8i .Tb (type .33mAXRRP3biK (1imiTTmbtAXtP .TiKTb } memory } TiRRti } mi (TK (string .concat .R3tUjR = accumulator } tiT ^ ^ (} 1T3RAdXmtim ^ KiTtmt .KdkA .XbPTXLK } TXmRI (RmtK } KPt ^ > (t1Amsb >RbtT } ^string .concat } ^number (R13dmAKXKPP ^ PKtTm (math .3bA ^ char ^ number } ^XKRTKmm (RKAi } PitTAKb } Kmb ^string ^ tX } XiRTd (mRAdKgPXPPA ^ Ai .type .ib ^ td ^ window } XXtb ^ 3iPb (mKRbRPA } }APX ^ .i1bT (char .RXAR } 3tTT ((bit3c .idPz ^ XAA } .iPTT (^ } m3spXdtK ^ (number } 1imPjtdTAmX .tb ^ TiT1XmRJRRdTT } (PATiKd .accumulator (1_ )
-- [0x0a]                 string } bit3c } TPdT } (string .concat .RmiAmROtt ^ iP .1t (^ .31AbROP ^ ^mKX1RmdMmRAti } PiP ^ 1 (A1fm )1d .accumulator } }XiXTRK ^ .mmtAKRmPP ^ tKATI . .1mdA ^ string .PX ^ RK3bm (number {Km6tPXiiA ^ .bit3c .type ^ (array? ^3mtXRXidTm (( .KmRAP3bPA} .string .concat .TT (type ^33AXXRPd ^ (bit3c (1KmiuPdttAR ^ number } XKTb ^ memory } + 3K .tdXti (^ (string .concat .PdtAAP } accumulator .XRiTT } ( } .RdRAiXPP (} KKibPmA .7d ARdmPT } ^bit3c } 1tmROmRmti } KiiXP (accumulator .AmY_RRbtT } ^string .concat } XX (string .3dm + ^XKPi ^ PKtm ((x113bAXX ^ number } ^XimbAmm .iRKAt } PitTAKbT1mb .XR ^ accumulator (} XiRTdKK .AdK .VXPt; ^AigT .bit3c ^ 1id ^ 5 (XX_ ^3Kmb ((number .6RPY ^ } Atd ^ .K1bT (char .PRXAt } 3 .XT ((bit3c .imA3RXAAd } .tmTT (^ } 3X  %  AXdti ^ (PTbimA&tRAwiX .tX ^ TKmb } mXvRd (array ^ } (tWTit .t3ApfdTtT } TP (type } string .concat ^ .R3dAmRiA } ^iP ^ 1tKX .Hd .AbR } array  %  ^ } it1RP6cmR (tKXtiATti3b!PXZbRTt ^ } } } XTRKi .memory (TAKXtPP ^ tW (type = Kb .1mRA ^ XXPX } memory ^ .1m (iDKmXtP } tiA ^ ?!t1b (Xv ^ 3XtX } Rid ^ KK ^ .bit3c (xAP3dPA } zi .TX (number ^mRAX (.Pm ^ (bit3c (TPb } / Pm ^ tAR (number ^1KTb ^ Ab?X3ttdX ^ string .concat (TK (i1AmRAA3dt .XiiTT ^ ( }  (3AAdRAP (3 ^ KP1tmtLAdiA .RiPT } ^bit3c } 1XmR  %  3Pst (RXii ^ 3 (tTdmn - .3itTRJi } ^string (R1PdmA (RPPiXRKt ^ bit3c (buffer .T3bAmX } number } char KR } (memory (8KRKtP } PP1TAKQb .mbT } string } tX } XiKTd (memory (3KT ^ XtPA ^ AibTP (11Pd ^ hbXXPR ^ 3Km } RmKbRRPA (} APg ^ .K1b (memory ^ .ARXtm } 3i (type (KPb (3P .3XAAA } .ibTT (^1tdX .XdP (^ (KibimP .DRAA / char .PT ^ TK ^ 1 } memory (dKRdAA } (AXTP (accumulator .tmTB ^ string .array ^ } TtKTX (string .Rm (AKX (tP ^ ii (1tmA + 3R ^ KXTtX ^ } array ^ 1dmmQmR (tKX!iPTt (AbniAMTR ^ accumulator ^ } miXTR (3 .mimAiXPPPXci .type?KT .1dXA ^ char } PX ^ Ri ^ 1m (number:KdttP } tiA ^ ) ^} 1b (Rx ^ 3RtX } RidTmi .bit3c (.APRTPA } Hi ^ ^KK ^mKAXKXPd ^ mK (TP (PgPm } tAdsP ^1KTTXK .BX3Atd (Ri (TK (ibA (RAAdmt } 3iTT ^ ( } 1dm .A3dTP (^AKibPmtqA :array .RRPT } tK } 13mR5dFtt (XAiiTA (tb .mSj .3 (tTXdi } TR (string (3m / iRTPiXbKtRX (flag . } RRP } }iKR ^ Pmmz (RKtiXiit } TK6TRmb >TR ^ accumulator } }iiR ^ bit3c (memory (3KAtXPtfdmip ^ } (1 (3 ^ array } XXPRXXKmTPmKbrRPtt } APL ^ TKbTXm ^ 0 } RXtR } 3im ^ > (bit3c .idPAtXAtQ } .ibPX (^ } 3XA3XdPm ^ ( ) 
-- [0x0a]                 local count = result .LvTFARkO;result .ZTuYPPFQ (function ( . )result .UwyWEeLi ()count = count + result .uaoZRjTJ end
-- [0x0a]                 local function element (accumulator, element )
-- [0x0a]                 if element
-- [0x0a]                     then
-- [0x0a]                     return count endcount = accumulator + count
-- [0x0a]             end local accumulator = handle (result .LvTFARkO, count = handle, memory = element, nil = buffer, nil = result .XCOqGOVo );
-- [0x0a]             local function function ( . )
-- [0x0a]             local count = result .XCOqGOVo (buffer, accumulator = element (result .uaoZRjTJ, nil = result .qQHvTItY ), nil = element (result .hbkyIeUx, nil = result .mGAtblFJ )+ result .SJWBfinX );element (result .SJWBfinX );return (accumulator * result .rS_CrXxE )+ count;end;
-- [0x0a]             local ne = true;
-- [0x0a]             local user = result .LvTFARkO
-- [0x0a]             local  function key ()
-- [0x0a]             local element = count () 
-- [0x0a]             local count = count () 
-- [0x0a]             local list = result .uaoZRjTJ;
-- [0x0a]             local pointer =(accumulator (count, result .uaoZRjTJ, result .bFbjlcsH )* (result .SJWBfinX ^ result .PBHQjvTo )) + element;
-- [0x0a]             local element = accumulator (count, result .wUnHZlPB, result .bUBLXFxV );
-- [0x0a]             local count =( (-result .uaoZRjTJ )^accumulator (count, result .PBHQjvTo )) if (element ==result .LvTFARkO
-- [0x0a]             then
-- [0x0a]             if (pointer ==user
-- [0x0a]                 then return count * result .LvTFARkO
-- [0x0a]             else element = result .uaoZRjTJlist = result .LvTFARkO;end;elseif (element ==result .GYQlYgel
-- [0x0a]             then
-- [0x0a]             return (pointer ==result .LvTFARkO )
-- [0x0a]             and (count * (result .uaoZRjTJ / result .LvTFARkO ))or (count * (result .LvTFARkO / result .LvTFARkO ))
-- [0x0a]         end;return result .qjUlY_ym (count, element -result .RrVtkcsE )* (list + (pointer / (result .SJWBfinX ^ result .gGWJpHok )) );end;
-- [0x0a]         local string.sub = count;
-- [0x0a]         local function zone (count
-- [0x0a]         local  accumulator;if (not count )
-- [0x0a]         then
-- [0x0a]         count = string.sub ()
-- [0x0a]         if (count ==result .LvTFARkO )
-- [0x0a]             then
-- [0x0a]             return'';end;endaccumulator = result .rpMBtUsk (buffer, element (result .uaoZRjTJ, result .qQHvTItY ), element (result .hbkyIeUx, result .mGAtblFJ )+ count -result .uaoZRjTJ )
-- [0x0a]             element (count )
-- [0x0a]             local element =""for count =(result .uaoZRjTJ + user ), accumulator do element = element .result .rpMBtUsk (accumulator, count, count
-- [0x0a]         end
-- [0x0a]         return element;end; )
-- [0x0a]         local user =#result .evZWpvZ_ (string ('\4j \4i' )) ~=result .uaoZRjTJ
-- [0x0a]         local  element = count;
-- [0x0a]         local function fe ( . )return {. }, result .DQAvaSFs ('#' )end
-- [0x0a]         local  function de ()
-- [0x0a]         local buffer = {} ;
-- [0x0a]         local handle =, {} } 
-- [0x0a]         local element = {} ; --Decompiled array: string
-- [0x0a]         local payload_chunks = {} handle, nil, element } ;
-- [0x0a]         local element = count ()
-- [0x0a]         local  object = {} for pointer = result .uaoZRjT, J, } element do
-- [0x0a]         local accumulator = memory () 
-- [0x0a]         local count;if (accumulator ==result .LvTFARkO )
-- [0x0a]         then
-- [0x0a]         count = (memory () ~=  {} )
-- [0x0a]     elseif (accumulator ==result .qQHvTItY )
-- [0x0a]     then
-- [0x0a]     local element = key ()
-- [0x0a]     if user and result .LPTRooEy (result .evZWpvZ_ (element ),  (\4i + ) ' )
-- [0x0a]         then element = result .K_zeVAeq (element );end count = element;elseif (accumulator ==result .uaoZRjTJ )
-- [0x0a]         then
-- [0x0a]         count = zone ()
-- [0x0a]     end;object .pointer = count;end;string [result .qQHvTItY]=memory () for, element = result .uaoZRjTJ, count ()do handle [element - (  {result .uaoZRjTJ} )]=de () end;for string =, result .uaoZRjTJ, count ()do
-- [0x0a]     local element = memory () if (accumulator (element, result .uaoZRjTJ, result .uaoZRjTJ )= =result .LvTFARkO
-- [0x0a]     then local handle = accumulator (element, result .SJWBfinX, result .qQHvTItY );
-- [0x0a]     local memory = accumulator (element, result .XVFUTBcx, result .mGAtblFJ ); --Decompiled array: element
-- [0x0a]     local element = {function ( . ) function ( . ), nil, nil} ;if (handle ==result .LvTFARkO )
-- [0x0a]         then
-- [0x0a]         element .list = function ( . )
-- [0x0a]         element .array = function ( . ) elseif (handle ==  {result .uaoZRjT, J} } )
-- [0x0a]         then element .list = count () elseif (handle ==char [result .SJWBfinX])
-- [0x0a]         then element .list = count () - (result .SJWBfinX ^ result .jmkxwEXz
-- [0x0a] else
-- [0x0a] if (handle ==char [result .qQHvTItY])
-- [0x0a]     then element .list = count () - (result .SJWBfinX ^ result .jmkxwEXz
-- [0x0a]     element .array = function ( . )
-- [0x0a] end;if (accumulator (memory, result .uaoZRjTJ, result .uaoZRjTJ )= =result .uaoZRjTJ
-- [0x0a] then
-- [0x0a] element .pointer = object [element .pointer]end if (accumulator (memory, result .SJWBfinX, result .SJWBfinX )= =result .uaoZRjTJ
-- [0x0a] then element .list = object [element .list]end if (accumulator (memory, result .qQHvTItY, result .qQHvTItY )= =result .uaoZRjTJ
-- [0x0a] then element .array = object [element .array]end buffer .string = element
-- [0x0a] end end;return string;end;
-- [0x0a] local function te (accumulator, count, element )
-- [0x0a] local  pointer = count;
-- [0x0a] local pointer = element;return string (result .LPTRooEy (result .LPTRooEy (( {result .ZTuYPPFQ (accumulator )} ) [result .SJWBfinX], count ), element ))end local function key (ee, string, memory )
-- [0x0a] local  function te ( . )
-- [0x0a] local function, zone, positan, te, user, count, buffer, string.sub, global, goto, char, accumulator;
-- [0x0a] local element = result .LvTFARkO;while -result .uaoZRjTJ <element do if result .SJWBfinX <element
-- [0x0a] then
-- [0x0a] if result .XVFUTBcx <element
-- [0x0a]     then if result .SJWBfinX ~= element
-- [0x0a]     then repeat if element ~=result .hbkyIeUx
-- [0x0a]     then element =-result .SJWBfinX
-- [0x0a]     break;endaccumulator = handle (result .pUnyBvLx );until true;else accumulator = handle (result .pUnyBvLx );end
-- [0x0a] elseif element ~=result .uaoZRjTJ
-- [0x0a] then for count = result .wUnHZlPB, result .AQsMvyrC do if result .XVFUTBcx >element
-- [0x0a] then string.sub = {} ;
-- [0x0a] local global = { ., } } break;endgoto = result .DQAvaSFs ('#' )-result .uaoZRjTJchar = {} ;break;end;else
-- [0x0a] goto = result .DQAvaSFs ('#' )-result .uaoZRjTJ
-- [0x0a] char =, {} } end end
-- [0x0a] elseif element >=result .uaoZRjTJ
-- [0x0a] then if element >result .LvTFARkO
-- [0x0a] then repeat if element <result .SJWBfinX
-- [0x0a] then positan = handle (result .mGAtblFJ, result .HqsUmPra, result .qQHvTItY, result .ZcBInQGl, ee )user = fe te = result .LvTFARkO;break;endcount =-result .ZcBInQGlbuffer =-result .uaoZRjTJ;until true;else count =-result .ZcBInQGlbuffer =-result .uaoZRjTJ;end
-- [0x0a] else  element = 0, goto do if (element >=positan
-- [0x0a] then
-- [0x0a] string.sub [element -positan]= global [element + 1]
-- [0x0a] else accumulator .element = global [element + 1];end;end;
-- [0x0a] local  + 1 )
-- [0x0a] local  element;
-- [0x0a] local handle;function KpFMQRAdpvZS ()ne = false;end;
-- [0x0a] local function goto ( . )while true do end end while ne do if count then
-- [0x0a] count = count + 4c end element = function .count
-- [0x0a] handle = element ._;if 8f >handle
-- [0x0a] then if 4c <=handle
-- [0x0a] then if handle 
-- [0x0a] then
-- [0x0a] if handle >= 5cthen if 5g >=handle
-- [0x0a]     then if 5d <handle
-- [0x0a]     then if 5f >handle
-- [0x0a]     then local, memory, string, buffer
-- [0x0a]     function, object, result, handle;
-- [0x0a]         ;while count > -1do if count > 2
-- [0x0a]         then
-- [0x0a]         if count >= 5then if count > 2then for element = 1g, 8i do if 6 ~=count
-- [0x0a]             then accumulator .result = handle
-- [0x0a]             break;end;break;end;else accumulator .result = handle;end
-- [0x0a]     elseif 1 <=count
-- [0x0a]     then for element = 2h, 7f do if count > 3then handle = accumulator .object;for element = 1 + object
-- [0x0a]     function .bdo handle = handle .accumulator .element;end;break;endresult = function .memory;break;end;else
-- [0x0a]         result = function .memory
-- [0x0a] end end
-- [0x0a] elseif count hen memory = pointerstring = listbuffer = array;elseif count ~= -1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for accumulator = , 9a do if 1 <count
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then object = function .string;break;endfunctan = element;break;end;else object = function .string;end end end count = count + 1 end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle >= 5cthen repeat if handle ~=5g
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator [element .pointer]= {} ;break;end;for handle =, 0, 6 do if 2 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if 5 >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle > -1then for result = 2f, 7e do if handle > 3then accumulator [element .pointer]= (element .list ~=0 )count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;break;end;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle hen accumulator [element .pointer]=string [element .list]count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list][element .array];end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if 1 ==handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;end end end until true;else for handle =, 0, 6 do if 2 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if 5 >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle > -1then for result = 2f, 7e do if handle > 3then accumulator [element .pointer]= (element .list ~=0 )count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;break;end;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle hen accumulator [element .pointer]=string [element .list]count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list][element .array];end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if 1 ==handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;end end end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle ==5cthen local element = element .dt .element = accumulator .element (accumulator [element + 1])elseif (accumulator [element .pointer]~ =element .array
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY count = count + 1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else count = element .list;end;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle > 5j
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if handle > 6athen
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     if handle > 5jthen for result =, 1d, 5j do if handle > 6bthen for handle = 0, 1 do if -4 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then for result = 1h, 8h do if handle ~=1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then accumulator (element .pointer, element .list )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         count = count +  function .count;break;end;accumulator [element .pointer]=memory [element .list];break;end;else, accumulator (element .pointer, element .list )count = count +  function .count;end end break;end;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         local count = element .pointer;do return accumulator .count (object (accumulator, count + 1, element .list ))end;break;end;else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         for handle = 0, 1 do if -4 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY             then for result = 1h, 8h do if handle ~=1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY             then accumulator (element .pointer, element .list )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY             count = count +  function .count;break;end;accumulator [element .pointer]=memory [element .list];break;end;else, accumulator (element .pointer, element .list )count = count +  function .count;end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         else local function = element .pointer;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         local list = {} ;for element =, 1, } #char do local element = char .element;for count = 0, #element do local count = element .count;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         local pointer = count [1];
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         local element = count [2];if pointer ==accumulator and element >=function
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         list .element = pointer .element
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         count [1]=list;end;end;end;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     elseif handle > 5h
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     if handle > 5gthen
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         repeat if handle ~= 5j
-- PHASE_BOUNDARY:VM_3G_BOUNDARY             then, accumulator [element .pointer]=key (zone [element .list], nil, memory )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY             break;end;accumulator [element .pointer]=accumulator [element .list][element .array];until true;else, accumulator [element .pointer]=key (zone [element .list], nil, memory );end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         else accumulator [element .pointer]=accumulator [element .list] % accumulator [element .array];end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     elseif handle then if handle <= 4dthen if 3i ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then for result =, 3b, 9b do if 4d >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then local object, result;for handle = 0, 4 do if handle < 2
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     if -2 <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         for result = 1c, 9b do if handle hen accumulator [element .pointer]=string [element .list]
-- PHASE_BOUNDARY:VM_3G_BOUNDARY             count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list]+ accumulator [element .array]count = count +  function .count;break;end;else accumulator [element .pointer]=accumulator [element .list]+ accumulator [element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         elseif 3 <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then if 0 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then for memory =, 2a, 6j do if 3 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then object = element .listresult = accumulator .ofor element = object + 1, element .ado result = result .accumulator .element;end;accumulator [element .pointer]=result;break;end;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;break;end;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     else accumulator [element .pointer]=accumulator [element .list] % element .arraycount = count +  function .count;end end end break;end;if not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then count = count + 1;else count = element .list;end;break;end;elseif not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then count = count + 1;else count = element .list;end;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle >= 4fthen if 4d <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then repeat if 4f ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then local result;for handle =, 0, 6 do if 2 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if 4 >=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle < 4
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY accumulator (element .pointer, element .list )count = count +  function .count;else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY accumulator (element .pointer, element .list )count = count + 1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY element = function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle >= 3then for array = 4f, 8i do if 6 >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then result = element .dt .result = accumulator .result (object (accumulator, result + 1, element .list ))count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list];break;end;else accumulator [element .pointer]=accumulator [element .list];end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 1 <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle >= 0then repeat if 2 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then, accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;until true;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator (element .pointer, element .list )count = count +  function .count;end end end break;end;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local handle;accumulator [element .pointer]=accumulator [element .list]count = count +  function .counthandle = element .dt .handle (accumulator [handle + 1])count = count +  function .count;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]( )count = count +  function .count;do return end;until true;else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local result;for handle =, 0, 6 do if 2 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if 4 >=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle < 4
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY accumulator (element .pointer, element .list )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY count = count +  function .count;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle >= 3then for array = 4f, 8i do if 6 >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then result = element .dt .result = accumulator .result (object (accumulator, result + 1, element .list ))count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list];break;end;else accumulator [element .pointer]=accumulator [element .list];end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 1 <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle >= 0then repeat if 2 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then, accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;until true;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator (element .pointer, element .list )count = count +  function .count;end end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else local handle, result, object;for array = 0, 2 do if array < 1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY accumulator [element .pointer]= accumulator [element .list]count = count +  function .count;else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if array > -3then repeat if array hen, accumulator (element .pointer, element .list )count = count + 1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     element = function .count;break;endhandle = element .pointerresult = accumulator .ho = accumulator [handle + 2];if (object > 0 )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     if (result >accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then count = element .list
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     else accumulator [handle + 3]=result;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif (result <accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = element .list;else accumulator [handle + 3]=result;end until true;else, accumulator (element .pointer, element .list )count = count +  function .count;end end end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 4i <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle >= 5athen if 4h <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then repeat if handle > 5athen local handle;accumulator [element .pointer]=accumulator [element .list]count = count +   element =, element .pointer, element .ldo ;end;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle > 4f
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY for count =, 3b, 7a do if handle ~=4h
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then local handle, memory
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     function, result, array, object;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         ;while count > -1do if count > =4
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         if count >= 6then if count >= 5then repeat if count > 6then reak;end;accumulator .object = array;until true;else end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     elseif count ~=1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then for element = 3a, 6h do if 5 ~=count
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then array = result [handle .function];break;endobject = handle .memory;break;end;else array = result [handle .function];end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif count > 1then if count ~= -1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then repeat if 2 ~=count
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then result = accumulator;break;endfunctan = list;until true;else function = list;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif count ==1then memory = pointer;else handle = element;end end end count = count + 1 end break;end;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local element = element .d
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local pointer = user (accumulator .element (accumulator [element + 1]) ) ;for element = element, count = buffer do count = count + 1;accumulator .element = pointer .count;end;break;end;else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local element = element .d
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local pointer = user (accumulator .element (accumulator [element + 1]) ), count = nil
-- PHASE_BOUNDARY:VM_3G_BOUNDARY for element = element, buffer do count = count + 1;accumulator .element = pointer .count;end;end end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 7d >=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle > 6h
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if 7b <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     if handle <= 7bthen local element = element .pointer
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         ;for count = element, buffer do local element = string.sub [count -element];accumulator .count = element;end;elseif 7d >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then memory [element .list]=accumulator [element .pointer];else local, handle;accumulator (element .pointer, element .list )count = count +   element =, element .pointer, element .ldo ;end;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     elseif handle > 6i
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     if =handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         local handle;for result = 0, 6 do if result < 3
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         if result hen accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]]
-- PHASE_BOUNDARY:VM_3G_BOUNDARY             count = count +  function .count;elseif 1 ~=result
-- PHASE_BOUNDARY:VM_3G_BOUNDARY             then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         elseif result > 4then if 5 ==result
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then accumulator [element .pointer]= accumulator [element .list]count = count +  function .count;elseif (accumulator [element .pointer]= =element .array )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         count = count + 1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     else count = element .list;end;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif result ~=1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then repeat if result ~=3
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;break;endhandle = element .dt .handle = accumulator .handle (accumulator [handle + 1])count = count +  function .count;until true;else handle = element .dt .handle = accumulator .handle (accumulator [handle + 1])count = count +  function .count;end end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [element .pointer]=accumulator [element .list] % element .array;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else local pointer = element .pointer;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local count = accumulator [element .list];accumulator [pointer + 1]=count;accumulator .pointer = count [element .array];end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if 6f <= handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then if handle < =6f
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle ==6hthen accumulator [element .pointer]=accumulator [element .list]+ element .array;elseif (accumulator [element .pointer]~ =element .array )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY count = count + 1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else count = element .list;end;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 6d <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for handle =, 0, 3 do if handle > 1then if 1 <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for result = 3f, 7f do if handle hen accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;break;end;if not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = count + 1;else count = element .list;end;break;end;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle hen, accumulator (element .pointer, element .list )count = count +  function .count;else accumulator (element .pointer, element .list )count = count +  function .count;end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else for element = element .pointer, element .ldo ;end;end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle >= 7jthen if handle > 8bthen if 8c >=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]-element .array;elseif handle ==8ethen accumulator [element .pointer]=string [element .list];else local, result, buffer, string, char, object, memory, handle;accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]( )count = count +  function .counthandle = 0;while handle > -1do if handle < =3
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if handle > 1then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     if handle ~= -1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then for element =, 2g, 8j do if 2 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then char = accumulator
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         break;endstring = list;break;end;else string = list;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     elseif -3 <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then for count = 4b, 5j do if handle hen result = element;break;endbuffer = pointer;break;end;else result = element;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle <= 5then if handle hen object = char [result .string];else memory = result .buffer;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle ~=3
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for element = 3j, 6c do if 6 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then break;end;accumulator .memory = object;break;end;else accumulator .memory = object;end end end handle = handle + 1 end count = count +  function .count;accumulator [element .pointer]( )count = count +  function .count;do return end;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle > 7jthen if 7g <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for result = 1h, 7a do if 8a <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count + ,  handle = 0, 1 do if -1 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then repeat if 1 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator [element .pointer]=memory [element .list]count = count +  function .count;break;end;if not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = count + 1;else count = element .list;end;until true;else accumulator [element .pointer]=memory [element .list]count = count +  function .count;end end break;end;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count + , function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator [element .pointer]= accumulator [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]-accumulator [element .array]count = count + , function .count;accumulator (element .pointer, element .list );end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [element .pointer]=accumulator [element .list]-accumulator [element .array];end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle <= 7fthen if 7d <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for count =, 4c, 7d do if 7e <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then local count = element .pointer;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local pointer = accumulator .count;for element = count + 1, element .ldo result .CkEVrajh (pointer, accumulator .element
-- PHASE_BOUNDARY:VM_3G_BOUNDARY end;break;end;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] break;end;else local count = element .pointer;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local pointer = accumulator .count;for element = count +, 1, element .ldo result .CkEVrajh (pointer, accumulator .element
-- PHASE_BOUNDARY:VM_3G_BOUNDARY end;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if 7h <= handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then if handle == 7h
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     local list, handle, array
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     for object = 0, 1 do if -3 <object
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then for memory = 4e, 7a do if 1 >object
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then list = element .pointer;;for element = list, buffer do handle = string.sub [element -list];accumulator .element = handle;endcount = count +   element = list + 1, buffer do result .CkEVrajh (array, accumulator .element )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     end;break;end;else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     list = element .pointer
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     ;for element = list, buffer do handle = string.sub [element -list];accumulator .element = handle;endcount = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [element .pointer]=accumulator [element .list]+ element .array;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [element .pointer]=accumulator [element .list]-element .array;end end end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle <= 2athen if 1a >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle >= 5then if handle >= 7then if 8 <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if 6 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for count =, 1h, 6i do if handle > 8then accumulator [element .pointer]= accumulator [element .list];break;end;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local element = element .dt .element = accumulator .element (accumulator [element + 1])break;end;else
-- PHASE_BOUNDARY:VM_3G_BOUNDARY accumulator [element .pointer]= #accumulator [element .list]
-- PHASE_BOUNDARY:VM_3G_BOUNDARY end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else local function = accumulator [element .array];if not function
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = count + 1;else accumulator [element .pointer]=functancount = element .list;end;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle > =2
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY for result =, 1a, 7g do if handle ~=6
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     local element = element .dt .element (accumulator [element + 1])break
-- PHASE_BOUNDARY:VM_3G_BOUNDARY end;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local result;for handle = 0, 6 do if handle < 3
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if 0 >= handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then accumulator (element .pointer, element .list )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     count = count +  function .count;elseif handle > 1then accumulator (element .pointer, element .list )count = count +  function .count;else accumulator (element .pointer, element .list )count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle <= 4then if 2 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for result = 1e, 7h do if 4 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 6 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then result = element .dt .result = accumulator .result (object (accumulator, result + 1, element .list ))count = count +   handle =, 0, 6 do if handle < 3
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if 0 >=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     accumulator (element .pointer, element .list )count = count + 1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     element = function .count;elseif handle > 1then accumulator (element .pointer, element .list )count = count +  function .count;else accumulator (element .pointer, element .list )count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle <= 4then if 2 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for result = 1e, 7h do if 4 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 6 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then result = element .dt .result = accumulator .result (object (accumulator, result + 1, element .list ))count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list];end end end end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif handle >= 2then if handle >= 3then if handle > -1then repeat if 4 >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then local pointer = element .pointer;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local function = accumulator .d
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local  handle = accumulator [pointer + 2];if (handle > 0 )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if (function >accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [pointer + 3]=function;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif (function <accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = element .list;else accumulator [pointer + 3]=function;end break;end;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local pointer = element .pointer;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local handle = accumulator [pointer + 2];
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local function = accumulator .pointer + handle;accumulator .pointer = function;if (handle > 0 )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if (function <= accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     accumulator [pointer + 3]=function;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif (function >=accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = element .list;accumulator [pointer + 3]=function;end until true;else local pointer = element .pointer;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local function = accumulator .d
-- PHASE_BOUNDARY:VM_3G_BOUNDARY local  handle = accumulator [pointer + 2];if (handle > 0 )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if (function >accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [pointer + 3]=function;end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif (function <accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = element .list;else accumulator [pointer + 3]=function;end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else accumulator [element .pointer]=memory [element .list];end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif -2 <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then for function =, 2g, 9a do if 0 ~=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if (element .pointer <accumulator [element .array])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = element .list;else count = count + 1;end;break;endcount = element .list;break;end;elseif (element .pointer <accumulator [element .array])
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then count = element .list;else count = count + 1;end;end end end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY elseif 1f >handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then if handle > 1b
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if 1d <=handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     if handle > 9then for count = 2a, 9i do if 1d <handle
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then local element = element .dt .element = accumulator .element (object (accumulator, element + 1, buffer ))break
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     end;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     local element = element .pointer;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     local count = accumulator .element;for element = element + 1, buffer do result .CkEVrajh (count, accumulator .element )
-- PHASE_BOUNDARY:VM_3G_BOUNDARY end;break;end;else local element = element .dt .element = accumulator .element (object (accumulator, element + 1, buffer ))end
-- PHASE_BOUNDARY:VM_3G_BOUNDARY else local  function, object, handle, result, array, memory;
-- PHASE_BOUNDARY:VM_3G_BOUNDARY ;while count > -1do if 4 >count
-- PHASE_BOUNDARY:VM_3G_BOUNDARY then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY if 2 <= count
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then if count > 1
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3G_BOUNDARY     for element = 2a, 9g do if 3 >count
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         then handle = list
-- PHASE_BOUNDARY:VM_3G_BOUNDARY         break;endresult = accumulator;break;end;else handle = list;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     elseif count > =-2then for accumulator = , 8b do if 0 <count
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     then object = pointer;break;endfunctan = element;break;end;else function = element;end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 6 >count
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if count > 2then for element = 2f, 8d do if 4 ~=count
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then memory = function .object;break;endarray = result [function .handle];break;end;else array = result [function .handle];end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 5 <=count
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then for element = 2a, 5c do if 6 <count
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then break;end;accumulator .memory = array;break;end;else end end end count = count + 1 end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 9 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if 1a ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then local buffer, string, memory, result, object, handle;accumulator [element .pointer]=accumulator [element .list][element .array]count = count +   element = 0, #memory do result = memory .elementobject = result [1]handle = result [2];if object ==accumulator and handle >=buffer
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then string .handle = object .handle;result [1]=string;end;end;end;break;end;if not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then count = count + 1;else count = element .list;end;until true;elseif not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then count = count + 1;else count = element .list;end;end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle > 1h
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY if 1j >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     accumulator [element .pointer]= accumulator [element .list] % element .array
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle then local, handle;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .counthandle = element .dt .handle = accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]count = count + , function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list );elseif (accumulator [element .pointer]= =element .array
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY count = count + 1
-- PHASE_BOUNDARY:VM_4G_BOUNDARY else count = element .list;end;end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 1f <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if 1f <=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then for result =, 1g, 5d do if 1h >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then local result, buffer, user, key, string.sub, zone, char, handle;for handle = 0, 6 do if handle > =3
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY )
-- PHASE_BOUNDARY:VM_4G_BOUNDARY if handle >= 5then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     if 5 ==handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         then handle = 0
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         while handle > -1do if 3 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY             then if 6 >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY             then if 0 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY             then for element = 2d, 9a do if 4 ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY             then char = buffer .user;break;endzone = string.sub [buffer .key];break;end;else char = buffer .user;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         elseif handle ~=4
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         then for element = 2g, 9e do if handle hen accumulator .char = zone;break;end;break;end;else end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     elseif 1 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     then if 2 ==handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     then key = list;else string.sub = accumulator;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 0 ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then user = pointer;else buffer = element;end end end handle = handle + 1 end count = count +  function .count;else result = element .dt .result (object (accumulator, result + 1, element .list ))end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle ==3then accumulator [element .pointer]=string [element .list]count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if handle ~= -1
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if 2 >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then result = element .dt .result =, accumulator .result (object (accumulator, result + 1, element .list ))count = count +  function .count;break;end;accumulator [element .pointer]=memory [element .list]count = count +  function .count;until true;else accumulator [element .pointer]=memory [element .list]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY else accumulator [element .pointer][element .list]=accumulator [element .array]count = count +  function .count;end end end break;end;accumulator [element .pointer]= (element .list ~=0 );break;end;else accumulator [element .pointer]= (element .list ~=0 );end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY else local, string, handle, object, memory, buffer, result, char, user, key;
-- PHASE_BOUNDARY:VM_4G_BOUNDARY ;while function > -1do if 2 <function
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if function > 4
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY if function >= 1then repeat if function > 5then reak;endcount = key;until true;else end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 0 <=function
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if 4 ~=function
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then char = string .memoryuser = string .buffer;break;endchar ==user and handle .ror 1 + object;until true;else key = char == user and handle .ror 1 + object;end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 0 >=function
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then string = accumulator;elseif function >= 0then for accumulator = , 5g do if 1 <function
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then memory = handle .pointerbuffer = handle .arrayresult = list;break;endhandle = elementobject = count;break;end;else memory = handle .pointerbuffer = handle .arrayresult = list;end end end function = function + 1 end end end end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 3a <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if handle then if 3d >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if 3c >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if (accumulator [element .pointer]= =accumulator [element .array])
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then count = count + 1;else count = element .list;end;else accumulator [element .pointer]= (element .list ~=0 );end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle <= 3dthen accumulator [element .pointer]=accumulator [element .list]+ accumulator [element .array];elseif 3b ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if handle ~=3f
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then local function = accumulator [element .array];if not function
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then count = count + 1;else accumulator [element .pointer]=functancount = element .list;end;break;end;
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local function = element .pointer;
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local pointer = {} ;for element =, 1, #char do local element = char .element;for count = 0, #element do local count = element .count;
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local list = count [1];
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local element = count [2];if list ==accumulator and element >=function
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY pointer .element = list .element
-- PHASE_BOUNDARY:VM_4G_BOUNDARY count [1]=pointer;end;end;end;until true;else local function = accumulator [element .array];if not function
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then count = count + 1;else accumulator [element .pointer]=functancount = element .list;end;end end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 3j <=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if handle < =3j
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local buffer = zone [element .list];
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local object;
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local, handle = {} object = result .MAXDHtYc (, {} }, {__index = function (count, element ) local element = handle .element;return element [1][element [2]] end, __newindex = function (accumulator, element, count ) local element = handle .ee [1][element [2]] =count;end;} ) for pointer =, 1, element .ado count = count + 1;
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local element = function .count;if element ._ ==4i
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY handle [pointer -1]= {accumulator, element .list} else handle [pointer -1]= {string, element .list} ;end;char [#char + 1]=handle;end;accumulator [element .pointer]=key (buffer, object, memory );elseif handle > 3j
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY for result = 1h, 5i do if handle then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     local positan, buffer, array, string, positan, handle, char, result, user, string.sub, zone, key, memoryhandle = 0
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     while handle > -1do if handle < =2
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         if handle > 0then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY             if 2 >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY                 then buffer = pointer
-- PHASE_BOUNDARY:VM_4G_BOUNDARY             else array = list;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         else result = element;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     elseif 5 >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     then if handle > 3then memory = result .buffer;else string = result .array;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 6 ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then accumulator (memory, string );else end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if 5 >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then if 4 ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then string = result .array;else memory = result .buffer;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle > 4then repeat if handle ~=6
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then accumulator (memory, string );break;end;until true;else end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle <= 0then result = element;elseif -2 <=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then for element = 1d, 7b do if 1 ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then array = list;break;endbuffer = pointer;break;end;else array = list;end end end handle = handle + 1 end count = count +  function .countchar = element .dt .char = accumulator .char (object (accumulator, char + 1, element .list ))count = count +  function .count;accumulator [element .pointer]= {} count = count +  function .counthandle = 0;while handle > -1do if handle > 3then if handle > 5then if handle >= 3then repeat if handle ~=7
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then accumulator .memory = key;break;end;until true;else end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 1 ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if 4 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then memory = result .user;break;endkey = zone [result .string.sub];until true;else memory = result .user;end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle hen if -1 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if handle ~=0
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then user = pointer;break;endresult = element;until true;else user = pointer;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 3 >handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then string.sub = list;else zone = accumulator;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if handle <= 2then if handle <= 0then result = element;elseif 0 <=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if handle > 1then array = list;break;endbuffer = pointer;until true;else buffer = pointer;end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle > 4then if 1 ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if 5 <handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then, break;end;accumulator (memory, string );until true;else accumulator (memory, string );end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle > =-1then for element = 2d, 7i do if handle > 3then memory = result .buffer;break;endstring = result .array;break;end;else string = result .array;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if handle >= 3then if handle >= 5then if handle ~=5
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then else accumulator (memory, string );end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle >= 0then for element = 1b, 7f do if 3 ~=handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then memory = result .buffer;break;endstring = result .array;break;end;else string = result .array;end end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif handle > 0then if handle ~=0
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then for element = 4i, 7e do if handle ~=2
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then buffer = pointer;break;endarray = list;break;end;else array = list;end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY else result = element;end end handle = handle + 1 end break;end;
-- PHASE_BOUNDARY:VM_4G_BOUNDARY local memory, object, string
-- PHASE_BOUNDARY:VM_4G_BOUNDARY function, handle, buffer, result;
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     ;while count > -1do if count > =3
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     then
-- PHASE_BOUNDARY:VM_4G_BOUNDARY     if 4 >= count
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         then if count ==4then result = accumulator .handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         for element = 1 + handle
-- PHASE_BOUNDARY:VM_4G_BOUNDARY             function .sdo result = result .accumulator .element;end;else
-- PHASE_BOUNDARY:VM_4G_BOUNDARY                 buffer = function .memory
-- PHASE_BOUNDARY:VM_4G_BOUNDARY         end
-- PHASE_BOUNDARY:VM_4G_BOUNDARY elseif 2 <count
-- PHASE_BOUNDARY:VM_4G_BOUNDARY then repeat if count > 5then break;end;accumulator .buffer = result;until true;else end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif count >= 1then if count > =-2then for accumulator = , 6c do if 1 <count
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then handle = function .object;break;endfunctan = element;break;end;else handle = function .object;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else memory = pointerobject = liststring = array;end end count = count + 1 end break;end;else local positan, buffer, memory, string, positan, handle, char, result, user, key, string.sub, zone, arrayhandle = 0;while handle > -1do if handle < =2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle > 0then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     if 2 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then buffer = pointer
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else memory = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 5 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 3then array = result .buffer;else string = result .memory;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 6 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (array, string );else end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 5 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 4 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string = result .memory;else array = result .buffer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 4then repeat if handle ~=6
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (array, string );break;end;until true;else end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 0then result = element;elseif -2 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 1d, 7b do if 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory = list;break;endbuffer = pointer;break;end;else memory = list;end end end handle = handle + 1 end count = count +  function .countchar = element .dt .char = accumulator .char (object (accumulator, char + 1, element .list ))count = count +  function .count;accumulator [element .pointer]= {} count = count +  function .counthandle = 0;while handle > -1do if handle > 3then if handle > 5then if handle >= 3then repeat if handle ~=7
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator .array = zone;break;end;until true;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 4 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .user;break;endzone = string.sub [result .key];until true;else array = result .user;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen if -1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle ~=0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then user = pointer;break;endresult = element;until true;else user = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then key = list;else string.sub = accumulator;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if handle <= 2then if handle <= 0then result = element;elseif 0 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 1then memory = list;break;endbuffer = pointer;until true;else buffer = pointer;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 4then if 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 5 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then, break;end;accumulator (array, string );until true;else accumulator (array, string );end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > =-1then for element = 2d, 7i do if handle > 3then array = result .buffer;break;endstring = result .memory;break;end;else string = result .memory;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if handle >= 3then if handle >= 5then if handle ~=5
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then else accumulator (array, string );end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 0then for element = 1b, 7f do if 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .buffer;break;endstring = result .memory;break;end;else string = result .memory;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 0then if handle ~=0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 4i, 7e do if handle ~=2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then buffer = pointer;break;endmemory = list;break;end;else memory = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3h <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if =handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local handle;for result = 0, 3 do if 2 <=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if result ~= -1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if result > 2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array];break;end;accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]count = count +  function .count;until true;else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY accumulator [element .pointer][accumulator [element .list]] = accumulator [element .array]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 1 ~=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;else handle = element .dt .handle = accumulator .handle (accumulator [handle + 1])count = count +  function .count;end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else local, result, array, object
-- PHASE_BOUNDARY:VM_3D_BOUNDARY function, handle;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     ;while count > -1do if count < 3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     if 1 <= count
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then if 2 ==count
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then object = list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else array = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 5 <=count
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if count ~=2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 4h, 5h do if 6 >count
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (handle )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY function );break;end;break;end;else accumulator (handle )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     function );end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if 4 ==count
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then handle = result .array
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else function = result .object;end end end count = count + 1 end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else do return accumulator [element .pointer]end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 2fthen if 2i <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 2ithen if handle >= 2gthen repeat if 2j <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local handle, user, string, result, memory, arrayhandle = element .pointer;do return accumulator .handle (object (accumulator, handle + 1, element .list ))endcount = count +  function .counthandle = element .pointer;do return object (accumulator, handle, buffer )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY endcount = count +   element = 0, #string do result = string .elementmemory = result [1]array = result [2];if memory ==accumulator and array >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY user .array = memory .array
-- PHASE_BOUNDARY:VM_3D_BOUNDARY result [1]=user;end;end;end;break;end;if (accumulator [element .pointer]= =accumulator [element .array])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = count + 1;else count = element .list;end;until true;elseif (accumulator [element .pointer]= =accumulator [element .array])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = count + 1;else count = element .list;end;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else local handle;for result =, 0, 2 do if result > =1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if result > =-3then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     for handle = 1e, 7b do if result hen accumulator [element .pointer]=accumulator [element .list]-element .array
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         count = count +  function .count;break;end;accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array];break;end;else accumulator [element .pointer]=accumulator [element .list]-element .arraycount = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else handle = element .dt .handle =, accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 2ethen repeat if 2h >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local handle;for result = 0, 1 do if result ~=0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = count + 1;else count = element .list;end;else handle = element .dt .handle = accumulator .handle ()count = count +  function .count;end end break;end;accumulator [element .pointer]=accumulator [element .list][element .array];until true;else accumulator [element .pointer]=accumulator [element .list][element .array];end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle < =2c
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle ==2cthen
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     local, positan, memory, string, buffer, positan, handle, char, result, string.sub, key, zone, user, arrayhandle = 0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     while handle > -1do if 2 >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then if handle > =1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         if 1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             string = list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         else memory = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen if 1 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 3c, 8d do if 4 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then buffer = result .string;break;endarray = result .memory;break;end;else array = result .memory;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 5 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then break;end;accumulator (array, buffer );until true;else accumulator (array, buffer );end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 5 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 1c, 7i do if 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (array, buffer );break;end;break;end;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 0 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 3b, 7a do if 4 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then buffer = result .string;break;endarray = result .memory;break;end;else array = result .memory;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 0then result = element;elseif 0 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle hen memory = pointer;break;endstring = list;until true;else string = list;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if handle >= 3then if 4 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle ==6then else accumulator (array, buffer );end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3 ==handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then buffer = result .string;else array = result .memory;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 0then result = element;elseif handle > =-3then repeat if handle hen memory = pointer;break;endstring = list;until true;else memory = pointer;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if handle > 2then if 4 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (array, buffer );else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle ~=2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 2b, 8e do if handle ~=3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .memory;break;endbuffer = result .string;break;end;else array = result .memory;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 0then if 1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string = list;else memory = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .countchar = element .dt .char = accumulator .char (object (accumulator, char + 1, element .list ))count = count +  function .counthandle = 0;while handle > -1do if 4 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle <= 5then if 0 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 2d, 8j do if handle hen user = zone [result .key];break;endarray = result .string.sub;break;end;else user = zone [result .key];end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 1a, 9c do if 7 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator .array = user;break;end;break;end;else end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 1then if -1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for count = 2h, 8a do if handle ~=0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string.sub = pointer;break;endresult = element;break;end;else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then key = list;else zone = accumulator;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if handle hen if 1 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then result = element;elseif -2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 1then string = list;break;endmemory = pointer;until true;else string = list;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen if handle ~= -1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 3 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .memory;break;endbuffer = result .string;until true;else array = result .memory;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle ==6then else accumulator (array, buffer );end end end handle = handle + 1 end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else for element = element .pointer, element .ldo ;end;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle then local handle;string [element .list]=accumulator [element .pointer]count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .counthandle = element .dt .handle (accumulator [handle + 1])count = count +  function .count;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]( )count = count +  function .count;do return end;elseif 2c ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 2f >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local result;for handle =, 0, 6 do if handle > 2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle >= 5then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     if handle ==6then accumulator (element .pointer, element .list )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for result = 1i, 8c do if 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 0 >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then result = element .dt .result = accumulator .result (object (accumulator, result + 1, element .list ))count = count +  function .count;elseif -2 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle hen accumulator [element .pointer]=accumulator [element .list]count = count + , function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;until true;else accumulator (element .pointer, element .list )count = count +  function .count;end end end end break;end;accumulator [element .pointer]=memory [element .list];until true;else accumulator [element .pointer]=memory [element .list];end end end end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 12i >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 10fthen if handle >= 11hthen if handle >= 12cthen if 12f <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle then accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]( )count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;accumulator [element .pointer]( )count = count +  function .count;do return end;elseif 12d <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for result =, 3j, 7f do if handle ~=12h
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local count = element .d
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local pointer = user (accumulator .count (object (accumulator, element = count + 1, nil = element .list )) ) ;for count = count, nil = buffer do element = element + 1;accumulator .count = pointer .element;end;break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local handle, buffer, memory, string, handle, handle, user, result, char, zone, string.sub, key, array;for handle = 0, 6 do if handle < 3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle hen handle = 0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then if 5 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then for element = 3b, 8b do if 3 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then array = result .buffer;break;endstring = result .memory;break;end;else array = result .buffer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     elseif 2 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then for element = 2i, 6g do if handle > 5then break;end;accumulator (array, string );break;end;else accumulator (array, string );end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if -1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 2h, 9d do if handle > 1then memory = list;break;endbuffer = pointer;break;end;else memory = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;elseif 0 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for char = 2h, 7e do if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then user = element .dt .user = accumulator .user (object (accumulator, user + 1, element .list ))count = count +  function .count;break;endhandle = 0;while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 5 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle ~=2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 5then break;end;accumulator (array, string );until true;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 4 ==handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .buffer;else string = result .memory;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 1then if handle ==2then memory = list;else buffer = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;break;end;else handle = 0;while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 5 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle ~=2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 5then break;end;accumulator (array, string );until true;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 4 ==handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .buffer;else string = result .memory;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 1then if handle ==2then memory = list;else buffer = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen if 0 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for object = 4f, 9h do if handle > 3then handle = 0;while handle > -1do if handle >= 3then if handle >= 5then if 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 2d, 7h do if 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (array, string );break;end;break;end;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > -1then repeat if 4 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string = result .memory;break;endarray = result .buffer;until true;else array = result .buffer;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 0then if 2 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then buffer = pointer;else memory = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;break;endhandle = 0;while handle > -1do if 4 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then else accumulator .array = key;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 1then repeat if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .char;break;endkey = string.sub [result .zone];until true;else array = result .char;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 1then if handle > -3then repeat if 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then result = element;break;endchar = pointer;until true;else char = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 2 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string.sub = accumulator;else zone = list;end end end handle = handle + 1 end count = count +  function .count;break;end;else handle = 0;while handle > -1do if 4 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then else accumulator .array = key;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 1then repeat if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .char;break;endkey = string.sub [result .zone];until true;else array = result .char;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 1then if handle > -3then repeat if 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then result = element;break;endchar = pointer;until true;else char = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 2 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string.sub = accumulator;else zone = list;end end end handle = handle + 1 end count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then handle = 0;while handle > -1do if 3 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle hen if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string = result .memory;else array = result .buffer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 1then for element = 1a, 7f do if handle hen accumulator (array, string );break;end;break;end;else accumulator (array, string );end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 0then result = element;elseif -2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 1then memory = list;break;endbuffer = pointer;until true;else buffer = pointer;end end end handle = handle + 1 end count = count +  function .count;else handle = 0;while handle > -1do if handle <= 2then if handle >= 1then if -3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory = list;break;endbuffer = pointer;until true;else memory = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen if handle > =-1then repeat if handle ~=3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .buffer;break;endstring = result .memory;until true;else string = result .memory;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 4i, 8a do if 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (array, string );break;end;break;end;else end end end handle = handle + 1 end end end end end break;end;else local handle, buffer, string, memory, handle, handle, string.sub, result, char, key, user, zone, array;for handle = 0, 6 do if handle < 3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle hen
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     handle = 0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then if 5 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then for element = 3b, 8b do if 3 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then array = result .buffer;break;endmemory = result .string;break;end;else array = result .buffer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     elseif 2 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then for element = 2i, 6g do if handle > 5then break;end;accumulator (array, memory );break;end;else accumulator (array, memory );end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if -1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 2h, 9d do if handle > 1then string = list;break;endbuffer = pointer;break;end;else string = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;elseif 0 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for char = 2h, 7e do if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string.sub = element .dt .string.sub = accumulator .string.sub (object (accumulator, string.sub + 1, element .list ))count = count +  function .count;break;endhandle = 0;while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 5 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle ~=2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 5then break;end;accumulator (array, memory );until true;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 4 ==handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .buffer;else memory = result .string;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 1then if handle ==2then string = list;else buffer = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;break;end;else handle = 0;while handle > -1do if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 5 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle ~=2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 5then break;end;accumulator (array, memory );until true;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 4 ==handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .buffer;else memory = result .string;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 1then if handle ==2then string = list;else buffer = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen if 0 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for object = 4f, 9h do if handle > 3then handle = 0;while handle > -1do if handle >= 3then if handle >= 5then if 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 2d, 7h do if 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (array, memory );break;end;break;end;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > -1then repeat if 4 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory = result .string;break;endarray = result .buffer;until true;else array = result .buffer;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 0then if 2 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then buffer = pointer;else string = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;break;endhandle = 0;while handle > -1do if 4 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then else accumulator .array = zone;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 1then repeat if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .char;break;endzone = user [result .key];until true;else array = result .char;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 1then if handle > -3then repeat if 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then result = element;break;endchar = pointer;until true;else char = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 2 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then user = accumulator;else key = list;end end end handle = handle + 1 end count = count +  function .count;break;end;else handle = 0;while handle > -1do if 4 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 6 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then else accumulator .array = zone;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 1then repeat if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .char;break;endzone = user [result .key];until true;else array = result .char;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 1then if handle > -3then repeat if 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then result = element;break;endchar = pointer;until true;else char = pointer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 2 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then user = accumulator;else key = list;end end end handle = handle + 1 end count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then handle = 0;while handle > -1do if 3 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle hen if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory = result .string;else array = result .buffer;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 1then for element = 1a, 7f do if handle hen accumulator (array, memory );break;end;break;end;else accumulator (array, memory );end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 0then result = element;elseif -2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 1then string = list;break;endbuffer = pointer;until true;else buffer = pointer;end end end handle = handle + 1 end count = count +  function .count;else handle = 0;while handle > -1do if handle <= 2then if handle >= 1then if -3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string = list;break;endbuffer = pointer;until true;else string = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen if handle > =-1then repeat if handle ~=3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then array = result .buffer;break;endmemory = result .string;until true;else memory = result .string;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 4i, 8a do if 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (array, memory );break;end;break;end;else end end end handle = handle + 1 end end end end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 12d >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local handle, memory, object, array, string, result;accumulator [element .pointer]=accumulator [element .list]count = count +   element = 0, #object do array = object .elementstring = array [1]result = array [2];if string ==accumulator and result >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory .result = string .result;array [1]=memory;end;end;endcount = count +  function .countcount = element .list;elseif handle > 12c
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY repeat if 12d <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     accumulator [element .pointer]= #accumulator [element .list], break;end;accumulator [element .pointer]=key (zone [element .list], nil, memory );until true;else accumulator [element .pointer]= accumulator [element .list];end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 11jthen if handle then local result;for handle =, 0, 5 do if handle > =3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle > 3then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then for array = 3a, 6g do if 5 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then result = element .dt .result = accumulator .result (accumulator [result + 1])count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         element = function .count;break;end;if accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then count = count + 1;else count = element .list;end;break;end;elseif accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then count = count + 1;else count = element .list;end;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen accumulator [element .pointer]=string [element .list]count = count +  function .count;elseif handle ==2then accumulator [element .pointer]=string [element .list]count = count +  function .count;else accumulator [element .pointer]=string [element .list]count = count +  function .count;end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 11i <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for result =, 4d, 7i do if 12b ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local handle;for result = 0, 6 do if 2 >=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 1 >result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer][element .list]=accumulator [element .array]count = count +  function .count;elseif result > =-3then repeat if 1 <result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer]=memory [element .list]count = count +  function .count;break;endhandle = element .dt .handle =, accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;until true;else accumulator [element .pointer]=memory [element .list]count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif result > =5
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if result >= 3then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     for array =, 2g, 8d do if result ~=5
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then handle = element .dt .handle (object (accumulator, handle + 1, element .list ))break
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     end;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;break;end;else handle =, element .dt .handle (object (accumulator, handle + 1, element .list ))end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif result ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer]=string [element .list]count = count +   handle =, 0, 1 do if -3 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle ~=0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if (accumulator [element .pointer]~ =accumulator [element .array])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = count + 1;else count = element .list;end;break;end;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;until true;elseif (accumulator [element .pointer]~ =accumulator [element .array])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = count + 1;else count = element .list;end;end end break;end;else for handle =, 0, 1 do if -3 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle ~=0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if (accumulator [element .pointer]~ =accumulator [element .array])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = count + 1;else count = element .list;end;break;end;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;until true;elseif (accumulator [element .pointer]~ =accumulator [element .array])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = count + 1;else count = element .list;end;end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 11g <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for function =, 1h, 9c do if 11i >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local pointer = element .pointer;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local handle = accumulator [pointer + 2];
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local function = accumulator .pointer + handle;accumulator .pointer = function;if (handle > 0 )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if (function <= accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     accumulator [pointer + 3]=function;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif (function >=accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = element .list;accumulator [pointer + 3]=function;end break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local element = element .pointer;do return, object (accumulator, element, buffer
-- PHASE_BOUNDARY:VM_3D_BOUNDARY end;break;end;else local pointer = element .pointer;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local handle = accumulator [pointer + 2];
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local function = accumulator .pointer + handle;accumulator .pointer = function;if (handle > 0 )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if (function <= accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     accumulator [pointer + 3]=function;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif (function >=accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = element .list;accumulator [pointer + 3]=function;end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 11b >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 10h <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 10i
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle >= 10hthen
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     repeat if 10j <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then accumulator [element .pointer][element .list]= accumulator [element .array]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         break;end;for handle =, 0, 1 do if handle > =-3then for result = 2d, 5g do if handle hen accumulator [element .pointer]=memory [element .list]count = count +  function .count;break;end;if accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then count = count + 1;else count = element .list;end;break;end;elseif accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then count = count + 1;else count = element .list;end;end end until true;else accumulator [element .pointer][element .list]=accumulator [element .array];end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else string [element .list]=accumulator [element .pointer];end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 10fthen for result =, 4f, 8f do if handle ~=10g
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for handle = 0, 6 do if 2 >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 0 >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer]= {} count = count +  function .count;elseif handle ~= -1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for result =, 4b, 7f do if 2 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;break;end;else accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 4 >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 0 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 4 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then, accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;until true;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 2 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle ~=6
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list );until true;else accumulator (element .pointer, element .list );end end end end break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local handle;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .counthandle = element .dt .handle = accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;accumulator [element .pointer]=accumulator [element .list];break;end;else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local, handle;accumulator (element .pointer, element .list )count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY element = function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .counthandle = element .dt .handle = accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;accumulator [element .pointer]=accumulator [element .list];end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 11d <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 11e <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if =handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory [element .list]=accumulator [element .pointer];else accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]( )count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;accumulator [element .pointer]( )count = count +  function .count;do return end;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else for handle =, 0, 6 do if 3 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if -2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     for result = 4i, 5e do if 2 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then memory [element .list]=accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         count = count +  function .count;break;end;accumulator [element .pointer]=memory [element .list]count = count +  function .count;break;end;else memory [element .list]=accumulator [element .pointer]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 5 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 2then repeat if handle hen accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;break;end;memory [element .list]=accumulator [element .pointer]count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 6 ==handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory [element .list]=accumulator [element .pointer];else accumulator [element .pointer]= (element .list ~=0 )count = count +  function .count;end end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 11c >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer]( );elseif 10j <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for result =, 1h, 8i do if handle > 11cthen local element = element .pointer;do return object (accumulator, element, buffer
-- PHASE_BOUNDARY:VM_3D_BOUNDARY end;break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local object, char, array, string, buffer, user, handle, resulthandle = 0;while handle > -1do if 4 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 5 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 6
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY accumulator .user = buffer
-- PHASE_BOUNDARY:VM_3D_BOUNDARY end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen buffer = string [object .array];else user = object .char;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle ~= -2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 2 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string = accumulator;break;endarray = list;until true;else array = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen object = element;else char = pointer;end end end handle = handle + 1 end count = count +   element =, element .pointer, element .ldo ;end;break;end;else local object, user, result, buffer, char, string, handle, arrayhandle = 0;while handle > -1do if 4 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 5 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 6
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY accumulator .string = char
-- PHASE_BOUNDARY:VM_3D_BOUNDARY end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen char = buffer [object .result];else string = object .user;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle ~= -2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 2 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then buffer = accumulator;break;endresult = list;until true;else result = list;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen object = element;else user = pointer;end end end handle = handle + 1 end count = count +   element =, element .pointer, element .ldo ;end;end end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 9e >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle >= 9athen if handle <= 9bthen if 8i <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 9b >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local handle;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]count = count +  function .counthandle = element .dt .handle = accumulator .handle (accumulator [handle + 1])count = count +  function .count;accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]count = count +  function .count;do return end;break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local result;for handle =, 0, 6 do if handle < 3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if 1 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then accumulator [element .pointer]= accumulator [element .list]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     count = count +  function .count;elseif -1 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then repeat if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then, accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;until true;else accumulator (element .pointer, element .list )count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 4then if 0 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for result = 4e, 6g do if handle hen accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 5 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then result = element .dt .result = accumulator .result (object (accumulator, result + 1, element .list ))else accumulator (element .pointer, element .list )count = count +  function .count;end end end end until true;else local handle;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]count = count +  function .counthandle = element .dt .handle = accumulator .handle (accumulator [handle + 1])count = count +  function .count;accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]count = count +  function .count;do return end;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 9c >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local, result, handle;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]+ accumulator [element .array]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list] % element .arraycount = count +  function .count;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .countresult = element .listhandle = accumulator .rfor element = result +, 1, element .ado handle = handle .accumulator .element;end;accumulator [element .pointer]=handle;elseif handle == 9d
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local, handle, result, object;for array = 0, 2 do if array <= 0then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY accumulator [element .pointer]= #accumulator [element .list]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY count = count +  function .count;elseif array hen, accumulator (element .pointer, element .list )count = count +  function .count;else handle = element .pointerresult = accumulator .ho = accumulator [handle + 2];if (object > 0 )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if (result >accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else accumulator [handle + 3]=result;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif (result <accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = element .list;else accumulator [handle + 3]=result;end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else local element = element .pointer;;for, count = element, buffer do local element = string.sub [count -element];accumulator .count = element;end;end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 8g <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 8h >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local handle;for result = 0, 3 do if 2 >result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if result ~=0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif result > 0
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY repeat if 3 >result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     handle = element .dt .handle =, accumulator .handle (object (accumulator, handle + 1, element .list ))count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     element = function .count;break;end;if not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = count + 1;else count = element .list;end;until true;elseif not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = count + 1;else count = element .list;end;end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 8gthen repeat if handle > 8ithen if accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = count + 1;else count = element .list;end;break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local count = element .dt .count = accumulator .count (object (accumulator, count + 1, element .list ))until true;else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else count = element .list;end;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 8e <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for result = 2a, 6e do if handle > 8f
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local handle, string.sub, user, key, string, handle, handle, result, zone, buffer, char, memory, positan;for handle = 0, 4 do if 2 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then if handle > =-1then repeat if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then positan = element .dt .positan = accumulator .positan (object (accumulator, positan + 1, element .list ))count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     element = function .count;break;end;if (accumulator [element .pointer]= =element .array
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else count = element .list;end;until true;elseif (accumulator [element .pointer]= =element .array )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else count = element .list;end;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else handle = 0;while handle > -1do if 3 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle >= 5then if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element =, 4a, 7i do if handle ~=5
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then break;end;accumulator (memory, char );break;end;else accumulator (memory, char );end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 2e, 9b do if handle hen char = result .buffer;break;endmemory = result .zone;break;end;else char = result .buffer;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen result = element;elseif handle > 1then buffer = list;else zone = pointer;end end end handle = handle + 1 end count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > -2then repeat if 0 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then handle = 0;while handle > -1do if handle > 2then if handle >= 5then if 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 3d, 7i do if 5 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then break;end;accumulator (memory, char );break;end;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > -1then repeat if handle hen char = result .buffer;break;endmemory = result .zone;until true;else char = result .buffer;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen result = element;elseif handle >= 0then repeat if 2 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then zone = pointer;break;endbuffer = list;until true;else buffer = list;end end end handle = handle + 1 end count = count +  function .count;break;endhandle = 0;while handle > -1do if handle <= 3then if handle hen if handle > 0then string.sub = pointer;else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then user = list;else key = accumulator;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle >= 1then for element = 4c, 6e do if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory = result .string.sub;break;endstring = key [result .user];break;end;else string = key [result .user];end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle ~=3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 6 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then break;end;accumulator .memory = string;until true;else accumulator .memory = string;end end end handle = handle + 1 end count = count +  function .count;until true;else handle = 0;while handle > -1do if handle <= 3then if handle hen if handle > 0then string.sub = pointer;else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then user = list;else key = accumulator;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle >= 1then for element = 4c, 6e do if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory = result .string.sub;break;endstring = key [result .user];break;end;else string = key [result .user];end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle ~=3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 6 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then break;end;accumulator .memory = string;until true;else accumulator .memory = string;end end end handle = handle + 1 end count = count +  function .count;end end end break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local pointer = element .pointer;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local function = accumulator .d
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local  handle = accumulator [pointer + 2];if (handle > 0 )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if (function >accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else accumulator [pointer + 3]=function;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif (function <accumulator [pointer + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = element .list;else accumulator [pointer + 3]= handle = 0, 4 do if 2 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 2 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > =-1then repeat if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then positan = element .dt .positan = accumulator .positan (object (accumulator, positan + 1, element .list ))count = count +  function .count;break;end;if (accumulator [element .pointer]= =element .array
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else count = element .list;end;until true;elseif (accumulator [element .pointer]= =element .array
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY count = count + 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else count = element .list;end;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else handle = 0;while handle > -1do if 3 <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > =5
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     for element =, 4a, 7i do if handle ~=5
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then reak;end;accumulator (memory, char );break;end;else accumulator (memory, char );end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     elseif 1 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then for element = 2e, 9b do if handle hen char = result .buffer;break;endmemory = result .string.sub;break;end;else char = result .buffer;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen result = element;elseif handle > 1then buffer = list;else string.sub = pointer;end end end handle = handle + 1 end count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > -2then repeat if 0 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then handle = 0;while handle > -1do if handle > 2then if handle >= 5then if 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then for element = 3d, 7i do if 5 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then break;end;accumulator (memory, char );break;end;else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > -1then repeat if handle hen char = result .buffer;break;endmemory = result .string.sub;until true;else char = result .buffer;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle hen result = element;elseif handle >= 0then repeat if 2 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then string.sub = pointer;break;endbuffer = list;until true;else buffer = list;end end end handle = handle + 1 end count = count +  function .count;break;endhandle = 0;while handle > -1do if handle <= 3then if handle hen if handle > 0then zone = pointer;else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then key = list;else user = accumulator;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle >= 1then for element = 4c, 6e do if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory = result .zone;break;endstring = user [result .key];break;end;else string = user [result .key];end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle ~=3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 6 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then break;end;accumulator .memory = string;until true;else accumulator .memory = string;end end end handle = handle + 1 end count = count +  function .count;until true;else handle = 0;while handle > -1do if handle <= 3then if handle hen if handle > 0then zone = pointer;else result = element;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 3 ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then key = list;else user = accumulator;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 6 >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle >= 1then for element = 4c, 6e do if handle ~=4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then memory = result .zone;break;endstring = user [result .key];break;end;else string = user [result .key];end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle ~=3
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if 6 <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then break;end;accumulator .memory = string;until true;else accumulator .memory = string;end end end handle = handle + 1 end count = count +  function .count;end end end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle <= 9jthen if 9g >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 9ethen repeat if handle ~=9g
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local handle, memory;for result = 0, 5 do if 3 >result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 1 <=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if result > =-3then repeat if 2 ~=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else handle = element .pointermemory = accumulator [element .list];accumulator [handle + 1]=memory;accumulator .handle = memory [element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif result < 4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY handle = element .dt .handle =, accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if 5 ~= result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list]+ accumulator [element .array];end end end end break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     local count = element .pointer;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     local pointer = accumulator .count;for element = count +, 1, element .ldo result .CkEVrajh (pointer, accumulator .element
-- PHASE_BOUNDARY:VM_3D_BOUNDARY end;until true;else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local handle, memory;for result = 0, 5 do if 3 >result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 1 <=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if result > =-3then repeat if 2 ~=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else handle = element .pointermemory = accumulator [element .list];accumulator [handle + 1]=memory;accumulator .handle = memory [element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif result < 4
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY handle = element .dt .handle =, accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if 5 ~= result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list]+ accumulator [element .array];end end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle >= 9ithen if handle >= 9hthen repeat if handle ~=9i
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = element .list;break;end;string [element .list]=accumulator [element .pointer];until true;else string [element .list]=accumulator [element .pointer];end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else local element = element .dt .element = accumulator .element ()end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 10c >=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if 10b >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local, handle, resulthandle = element .pointerresult = accumulator [element .list];accumulator [handle + 1]=result;accumulator .handle = result [element .array]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]count = count +  function .counthandle = element .dt .handle =, accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;accumulator [element .pointer]=accumulator [element .list]* element .array;else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if handle ~= 9i
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then for result =, 4e, 9d do if 10b <handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then local handle, object, memory
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     for result = 0, 4 do if result < 2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         if -3 ~=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             for handle = 3f, 8e do if result hen accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY                 count = count + , function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             elseif result > 2then if result ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             then for array = 1h, 7c do if result > 3then handle = element .pointerobject = accumulator .hm = accumulator [handle + 2];if (memory > 0 )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             if (object >accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY                 then count = element .list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             else accumulator [handle + 3]=object;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         elseif (object <accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then count = element .list;else accumulator [handle + 3]=object;end, break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else accumulator [element .pointer]= accumulator [element .list]count = count +   result = 0, 4 do if result < 2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     if -3 ~=result
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         for handle = 3f, 8e do if result hen accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]]
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             count = count + , function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         elseif result > 2then if result ~=1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then for array = 1h, 7c do if result > 3then handle = element .pointerobject = accumulator .hm = accumulator [handle + 2];if (memory > 0 )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         if (object >accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY             then count = element .list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         else accumulator [handle + 3]=object;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     elseif (object <accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = element .list;else accumulator [handle + 3]=object;end, break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else accumulator [element .pointer]= accumulator [element .list]count = count +  function .count;end end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 10e <=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle >= 10bthen repeat if 10f ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then local element = element .dt .element =, accumulator .element (object (accumulator, element + 1, buffer ))break;end;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local buffer = zone [element .list];
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local object;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local handle = {} object = result .MAXDHtYc (, {} }, {__index = function (count, element ) local element = handle .element;return element [1][element [2]] end, __newindex = function (accumulator, element, count ) local element = handle .ee [1][element [2]] =count;end;} ) for pointer =, 1, element .ado count = count + 1;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY local element = function .count;if element ._ ==4i
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY handle [pointer -1]= {accumulator, element .list} else handle [pointer -1]= {string, element .list} ;end;char [#char + 1]=handle;end;accumulator [element .pointer]=key (buffer, object, memory );until true;else local element = element .dt .element = accumulator .element (object (accumulator, element + 1, buffer ))end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else local  handle, result, array;for object = 0, 2 do if object < 1
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY accumulator [element .pointer]= accumulator [element .list]count = count +  function .count;else
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if object ~= -2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then repeat if object hen, accumulator (element .pointer, element .list )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     count = count +  function .count;break;endhandle = element .pointerresult = accumulator .ha = accumulator [handle + 2];if (array > 0 )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     if (result >accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY         then count = element .list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     else accumulator [handle + 3]=result;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif (result <accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = element .list;else accumulator [handle + 3]=result;end until true;else handle = element .pointerresult = accumulator .ha = accumulator [handle + 2];if (array > 0 )
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if (result >accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else accumulator [handle + 3]=result;end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif (result <accumulator [handle + 1])
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then count = element .list;else accumulator [handle + 3]=result;end end end end end end end end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif handle > 14ithen if 16a >handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then if handle > 15dthen if handle then if handle >= 15fthen if 15e ~=handle
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then repeat if handle > 15fthen local, object, handle, result, key, buffer, string, memory, char, user;
-- PHASE_BOUNDARY:VM_3D_BOUNDARY ;while function > -1do if function > 2
-- PHASE_BOUNDARY:VM_3D_BOUNDARY then
-- PHASE_BOUNDARY:VM_3D_BOUNDARY if function >= 5then if 6 ~=function
-- PHASE_BOUNDARY:VM_3D_BOUNDARY     then count = user
-- PHASE_BOUNDARY:VM_3D_BOUNDARY else end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif function ==3then memory = object .keychar = object .buffer;else user = memory == char and handle .sor 1 + result;end end
-- PHASE_BOUNDARY:VM_3D_BOUNDARY elseif 0 <function
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if function > =-2then for accumulator = , 7b do if 1 <function
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then key = handle .pointerbuffer = handle .arraystring = list;break;endhandle = elementresult = count;break;end;else handle = elementresult = count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else object = accumulator;end end function = function + 1 end break;end;accumulator [element .pointer]=string [element .list];until true;else local, object, handle, result, memory, string, buffer, char, key, user;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY ;while function > -1do if function > 2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if function >= 5then if 6 ~=function
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then count = user
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif function ==3then char = object .memorykey = object .string;else user = char == key and handle .bor 1 + result;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 0 <function
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if function > =-2then for accumulator = , 7b do if 1 <function
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then memory = handle .pointerstring = handle .arraybuffer = list;break;endhandle = elementresult = count;break;end;else handle = elementresult = count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else object = accumulator;end end function = function + 1 end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else accumulator [element .pointer]= {} count = count +  function .count;accumulator [element .pointer]= {} count = count +  function .count;accumulator [element .pointer]= {} count = count + , function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list )count = count +  function .count;accumulator (element .pointer, element .list );end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 15i >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then local pointer = element .pointer;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local count = accumulator [element .list];accumulator [pointer + 1]=count;accumulator .pointer = count [element .array];else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if handle ~= 15e
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then for result =, 4e, 9i do if 15j ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then local result, user, object, char, buffer, handle, string, key, zone
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]= {} count = count +  function .counthandle = 0;while handle > -1do if handle > 2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if 5 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         if handle ~= -1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then for element =, 3a, 7h do if 4 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then char = result .object
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             break;endbuffer = result .user;break;end;else buffer = result .user;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         elseif 6 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then accumulator (buffer, char );else end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif handle >= 1then if handle > 0then repeat if 2 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then user = pointer;break;endobject = list;until true;else object = list;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if 3 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 1 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then result = element;elseif handle ~=1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then object = list;else user = pointer;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle >= 5then if handle > 1then repeat if handle ~=6
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator (buffer, char );break;end;until true;else end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 2 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 3 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then buffer = result .user;break;endchar = result .object;until true;else char = result .object;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if 3 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 1 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 0 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element = 3j, 8d do if handle hen user = pointer;break;endobject = list;break;end;else object = list;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else result = element;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle >= 5then if 5 ==handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator (buffer, char );else end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle ~=3
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then buffer = result .user;else char = result .object;end end end handle = handle + 1 end count = count +  function .countstring = element .pointerkey = accumulator .sz = accumulator [string + 2];if (zone > 0 )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if (key >accumulator [string + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else accumulator [string + 3]=key;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif (key <accumulator [string + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then count = element .list;else accumulator [string + 3]=key;end break;end;accumulator [element .pointer]= {} ;break;end;else local, result, user, object, buffer, char, handle, string, key, zone;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]= {} count = count +  function .counthandle = 0;while handle > -1do if handle > 2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if 5 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if handle ~= -1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then for element =, 3a, 7h do if 4 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then buffer = result .object
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         break;endchar = result .user;break;end;else char = result .user;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif 6 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then accumulator (char, buffer );else end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle >= 1then if handle > 0then repeat if 2 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then user = pointer;break;endobject = list;until true;else object = list;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if 3 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 1 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then result = element;elseif handle ~=1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then object = list;else user = pointer;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle >= 5then if handle > 1then repeat if handle ~=6
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator (char, buffer );break;end;until true;else end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 2 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 3 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then char = result .user;break;endbuffer = result .object;until true;else buffer = result .object;end end end handle = handle + 1 end count = count +  function .counthandle = 0;while handle > -1do if 3 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 1 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 0 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element = 3j, 8d do if handle hen user = pointer;break;endobject = list;break;end;else object = list;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else result = element;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle >= 5then if 5 ==handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator (char, buffer );else end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle ~=3
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then char = result .user;else buffer = result .object;end end end handle = handle + 1 end count = count +  function .countstring = element .pointerkey = accumulator .sz = accumulator [string + 2];if (zone > 0 )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if (key >accumulator [string + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then count = element .list
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else accumulator [string + 3]=key;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif (key <accumulator [string + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then count = element .list;else accumulator [string + 3]=key;end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 15b <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 15c >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then do return end;elseif 14j <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for function =, 1e, 9f do if 15c ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array];break;end;if (accumulator [element .pointer]= =element .array
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY count = count + 1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else count = element .list;end;break;end;elseif (accumulator [element .pointer]= =element .array )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY count = count + 1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else count = element .list;end;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle ==14jthen local, handle, array, string, resulthandle = element .dt .handle = accumulator .handle (accumulator [handle + 1])count = count +   element = handle, buffer do result = result + 1;accumulator .element = array .result;endcount = count +  function .counthandle = element .dt .handle = accumulator .handle (object (accumulator, handle + 1, buffer ))else local element = element .dt .element = accumulator .element ()end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 16e >=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 16c <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle < =16c
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY for handle = 0, 6 do if handle > 2then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if handle hen if 3 ~= handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then accumulator [element .pointer]=string [element .list]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         count = count +  function .count;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif 6 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;else accumulator [element .pointer]= {} ;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 1 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=memory [element .list]count = count +  function .count;elseif handle ~=2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=string [element .list]count = count +  function .count;else accumulator [element .pointer]=string [element .list]count = count +  function .count;end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 16d ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then local result;for handle =, 0, 5 do if 3 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 1 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 2 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;else result = element .dt .result = accumulator .result (accumulator [result + 1])count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 3 >=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]count = count +  function .count;elseif 4 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array];else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else do return end;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 15j <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for result =, 3a, 7f do if 16b ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then local list, array, object, handle, memory, result;for string = 0, 1 do if string ~= -2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for buffer = 4c, 6c do if 0 ~=string
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then list = element .pointerarray = {} ;for element =, 1, } #char do object = char .element;for element = 0, #object do handle = object .elementmemory = handle [1]result = handle [2];if memory ==accumulator and result >=list
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then array .result = memory .result;handle [1]=array;end;end;end;break;endlist = element .dt .list (accumulator [list + 1])count = count +  function .count;break;end;else list = element .dt .list (accumulator [list + 1])count = count +  function .count;end end break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local count =, element .dt .count (object (accumulator, count + 1, element .list ))break;end;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local list, array, object, result, memory, handle;for string = 0, 1 do if string ~= -2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for buffer = 4c, 6c do if 0 ~=string
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then list = element .pointer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY array = {} ;for element =, 1, } #char do object = char .element;for element = 0, #object do result = object .elementmemory = result [1]handle = result [2];if memory ==accumulator and handle >=list
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then array .handle = memory .handle;result [1]=array;end;end;end;break;endlist = element .dt .list (accumulator [list + 1])count = count +  function .count;break;end;else list = element .dt .list (accumulator [list + 1])count = count +  function .count;end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 16h <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle > =16j
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if 16i <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     for count =, 1j, 6c do if 16j ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then local count = element .d
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         local pointer = user (accumulator .count (object (accumulator, element = count + 1, nil = element .list )) )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         for count = count, buffer do element = element + 1;accumulator .count = pointer .element;end;break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             local element = element .pointer;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             local count = accumulator .element;for element = element + 1, buffer do result .CkEVrajh (count, accumulator .element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         end;break;end;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         local count = element .d )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         local pointer = user (accumulator .count (object (accumulator, element = count + 1, nil = element .list )) )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         for count = count, buffer do element = element + 1;accumulator .count = pointer .element;end;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         elseif (element .pointer <accumulator [element .array])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then count = element .list;else count = count + 1;end;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif 16g <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then if handle > =16c
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     for result = 4c, 9i do if handle then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         local handle, memory;for result = 0, 6 do if 3 <=result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then if result < =4
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         if 0 <=result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then repeat if 3 ~=result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             count = count +  function .count;break;endhandle = element .dt .handle =, accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;until true;else accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         elseif 3 <result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then for object =, 4b, 5d do if 6 ~=result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then handle = element .pointermemory = accumulator [element .list];accumulator [handle + 1]=memory;accumulator .handle = memory [element .array]count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list];break;end;else handle = element .pointermemory = accumulator [element .list];accumulator [handle + 1]=memory;accumulator .handle = memory [element .array]count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif 1 >result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then handle = element .pointermemory = accumulator [element .list];accumulator [handle + 1]=memory;accumulator .handle = memory [element .array]count = count +  function .count;elseif result > 0then repeat if 1 <result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;end end end end break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     local count =, element .dt .count (object (accumulator, count + 1, element .list ))break;end;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     local handle, memory;for result = 0, 6 do if 3 <=result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then if result < =4
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if 0 <=result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then repeat if 3 ~=result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         count = count +  function .count;break;endhandle = element .dt .handle =, accumulator .handle (object (accumulator, handle + 1, element .list ))count = count +  function .count;until true;else accumulator [element .pointer][accumulator [element .list]] =accumulator [element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif 3 <result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then for object =, 4b, 5d do if 6 ~=result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then handle = element .pointermemory = accumulator [element .list];accumulator [handle + 1]=memory;accumulator .handle = memory [element .array]count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list];break;end;else handle = element .pointermemory = accumulator [element .list];accumulator [handle + 1]=memory;accumulator .handle = memory [element .array]count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 1 >result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then handle = element .pointermemory = accumulator [element .list];accumulator [handle + 1]=memory;accumulator .handle = memory [element .array]count = count +  function .count;elseif result > 0then repeat if 1 <result
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;end end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else local, result, string, memory, object, char, handle, array, buffer, user;for handle = 0, 2 do if handle < 1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY accumulator [element .pointer]= accumulator [element .list]count = count +  function .count;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if -3 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then repeat if handle > 1then array = element .pointer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     buffer = accumulator .au = accumulator [array + 2];if (user > 0 )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if (buffer >accumulator [array + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then count = element .list
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     else accumulator [array + 3]=buffer;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif (buffer <accumulator [array + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then count = element .list;else accumulator [array + 3]=buffer;end break;endhandle = 0;while handle > -1do if handle > 2then if handle hen if 0 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element =, 1e, 9b do if handle > 3then char = result .string;break;endobject = result .memory;break;end;else object = result .memory;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 5 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then else accumulator (char, object );end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if -2 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element = 4h, 6b do if handle hen string = pointer;break;endmemory = list;break;end;else string = pointer;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;until true;else handle = 0;while handle > -1do if handle > 2then if handle hen if 0 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element = 1e, 9b do if handle > 3then char = result .string;break;endobject = result .memory;break;end;else object = result .memory;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 5 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then else accumulator (char, object );end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if -2 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element = 4h, 6b do if handle hen string = pointer;break;endmemory = list;break;end;else string = pointer;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;end end end end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle then if 13c >=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle then if handle > 12ethen repeat if 12i <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]-accumulator [element .array];break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local, result, string, buffer, memory, array, handle, object, char, user;for handle = 0, 2 do if handle > 0
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if 1 ~= handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then object = element .pointer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     char = accumulator .ou = accumulator [object + 2];if (user > 0 )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if (char >accumulator [object + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then count = element .list
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     else accumulator [object + 3]=char;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif (char <accumulator [object + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then count = element .list;else accumulator [object + 3]=char;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else handle = 0;while handle > -1do if 3 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 5 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 2 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element =, 2i, 6a do if 4 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then memory = result .buffer;break;endarray = result .string;break;end;else array = result .string;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > 2then for element = 1i, 7d do if 5 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then break;end;accumulator (array, memory );break;end;else accumulator (array, memory );end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 0 >=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then result = element;elseif -2 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 1 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then buffer = list;break;endstring = pointer;until true;else string = pointer;end end end handle = handle + 1 end count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else handle = 0;while handle > -1do if handle > 2then if 5 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle ~= -1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 4 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then memory = result .buffer;break;endarray = result .string;until true;else memory = result .buffer;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 1 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element = 1e, 7j do if handle hen accumulator (array, memory );break;end;break;end;else accumulator (array, memory );end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > 0then if handle ==2then buffer = list;else string = pointer;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else result = element;end end handle = handle + 1 end count = count +   handle = 0, 2 do if handle > 0
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if 1 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     object = element .pointer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     char = accumulator .ou = accumulator [object + 2];if (user > 0 )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if (char >accumulator [object + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then count = element .list
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     else accumulator [object + 3]=char;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif (char <accumulator [object + 1])
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then count = element .list;else accumulator [object + 3]=char;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else handle = 0;while handle > -1do if 3 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 5 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 2 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element =, 2i, 6a do if 4 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then memory = result .buffer;break;endarray = result .string;break;end;else array = result .string;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > 2then for element = 1i, 7d do if 5 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then break;end;accumulator (array, memory );break;end;else accumulator (array, memory );end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 0 >=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then result = element;elseif -2 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 1 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then buffer = list;break;endstring = pointer;until true;else string = pointer;end end end handle = handle + 1 end count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else handle = 0;while handle > -1do if handle > 2then if 5 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle ~= -1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 4 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then memory = result .buffer;break;endarray = result .string;until true;else memory = result .buffer;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 1 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element = 1e, 7j do if handle hen accumulator (array, memory );break;end;break;end;else accumulator (array, memory );end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > 0then if handle ==2then buffer = list;else string = pointer;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else result = element;end end handle = handle + 1 end count = count +  function .count;end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle <= 13athen local element = element .dt .element (accumulator [element + 1])elseif 12h <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if handle > 13b
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY accumulator [element .pointer]=accumulator [element .list] % accumulator [element .array];break;end;accumulator [element .pointer][element .list]=accumulator [element .array];until true;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY accumulator [element .pointer][element .list]= accumulator [element .array]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 13f <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle then local result;for handle =, 0, 6 do if 3 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle > 0
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if -3 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     repeat if handle hen accumulator [element .pointer]= string [element .list]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         count = count +  function .count;break;end;accumulator [element .pointer]=string [element .list]count = count +  function .count;until true;else accumulator [element .pointer]=string [element .list]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     else accumulator [element .pointer]=string [element .list]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > 4then if handle ~=6
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;else result = element .dt .result =, accumulator .result (object (accumulator, result + 1, element .list ))end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle ~=1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 3 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 13e <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 13h ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then local handlehandle = element .dt .handle (accumulator [handle + 1])count = count +  function .count;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]=memory [element .list];break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local, handle, array
-- PHASE_BOUNDARY:VM_2C_BOUNDARY function, result, object;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     ;while count > -1do if count > =3
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if count >= 5then if count ~=5
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then lse accumulator (object, result );end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif count > 2then for element = 3g, 5j do if 3 <count
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then object = handle .array;break;endresult = handle .function;break;end;else result = handle .function;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 1 <=count
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if -2 ~=count
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for element = 3b, 7j do if count hen array = pointer;break;endfunctan = list;break;end;else function = list;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else handle = element;end end count = count + 1 end until true;else local handlehandle = element .dt .handle (accumulator [handle + 1])count = count +  function .count;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]=memory [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]=memory [element .list];end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > =13b
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY repeat if 13d ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     accumulator [element .pointer]= accumulator [element .list]+ accumulator [element .array]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     local result;for handle =, 0, 6 do if 3 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if 1 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then accumulator (element .pointer, element .list )count = count + 1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         element = function .count;elseif handle > =-2then repeat if handle < 2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;until true;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         accumulator (element .pointer, element .list )count = count + 1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         element = function .count;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif handle > 4then if handle >= 4then repeat if handle ~=5
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] break;endresult = element .dt .result =, accumulator .result (object (accumulator, result + 1, element .list ))count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 3 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then, accumulator (element .pointer, element .list )count = count +   handle = 0, 6 do if 3 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 1 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator (element .pointer, element .list )count = count +  function .count;elseif handle > =-2then repeat if handle < 2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;until true;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY accumulator (element .pointer, element .list )count = count + 1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY element = function .count;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > 4then if handle >= 4then repeat if handle ~=5
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] break;endresult = element .dt .result =, accumulator .result (object (accumulator, result + 1, element .list ))count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 3 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then, accumulator (element .pointer, element .list )count = count +  function .count;else accumulator (element .pointer, element .list )count = count +  function .count;end end end end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle >= 14dthen if 14g >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 14d <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 14b <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 14e <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then count = count + 1;else count = element .list;end;break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local count = element .dt .count = accumulator .count (object (accumulator, count + 1, element .list ))until true;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then count = count + 1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else count = element .list;end;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else local element = element .d
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local pointer = user (accumulator .element (accumulator [element + 1]) ) ;for element = element, count = buffer do count = count + 1;accumulator .element = pointer .count;end;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > 14g
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if handle > 14gthen for result = 4i, 8g do if handle ~=14h
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then for handle = 0, 6 do if 2 >=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then if 0 >=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then accumulator [element .pointer]=accumulator [element .list]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     count = count +  function .count;elseif handle > =-2then for result =, 4h, 7e do if 2 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then accumulator [element .pointer]=accumulator [element .list]count = count + , function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;break;end;else accumulator (element .pointer, element .list )count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle hen if 0 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if 4 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator (element .pointer, element .list )count = count +  function .count;break;end;accumulator (element .pointer, element .list )count = count +  function .count;until true;else accumulator (element .pointer, element .list )count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle ~=5
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator (element .pointer, element .list );else accumulator (element .pointer, element .list )count = count +  function .count;end end end end break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local object, result;for handle = 0, 6 do if 3 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if 5 <= handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then if handle ~=5
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then accumulator [element .pointer]=accumulator [element .list]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > =2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY repeat if 3 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     object = element .pointer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     result = accumulator [element .list];accumulator [object + 1]=result;accumulator .object = result [element .array]count = count +  function .count;break;end;accumulator [element .pointer]=string [element .list]count = count +  function .count;until true;else object = element .pointerresult = accumulator [element .list];accumulator [object + 1]=result;accumulator .object = result [element .array]count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle > -3then repeat if 1 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]+ element .arraycount = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list] % accumulator [element .array]count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list] % accumulator [element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else accumulator [element .pointer]= accumulator [element .list]count = count +   handle = 0, 6 do if 3 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if 5 <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle ~=5
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list];else accumulator [element .pointer]=accumulator [element .list]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > =2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY repeat if 3 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     result = element .pointer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     object = accumulator [element .list];accumulator [result + 1]=object;accumulator .result = object [element .array]count = count +  function .count;break;end;accumulator [element .pointer]=string [element .list]count = count +  function .count;until true;else result = element .pointerobject = accumulator [element .list];accumulator [result + 1]=object;accumulator .result = object [element .array]count = count +  function .count;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 0 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle > -3then repeat if 1 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]+ element .arraycount = count +  function .count;break;end;accumulator [element .pointer]=accumulator [element .list] % accumulator [element .array]count = count +  function .count;until true;else accumulator [element .pointer]=accumulator [element .list] % accumulator [element .array]count = count +  function .count;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else accumulator [element .pointer]= accumulator [element .list]count = count +  function .count;end end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else local count = element .pointer;do return, accumulator .count (object (accumulator, count + 1, element .list ))end;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif handle > =14a
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if handle >= 14bthen
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if 14b ~= handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then local result, memory, string, buffer, char, object, handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         accumulator [element .pointer]=accumulator [element .list][element .array]count = count +  function .count;accumulator [element .pointer]( )count = count +  function .counthandle = 0;while handle > -1do if 4 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then if handle < 2
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         if handle > -2then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             repeat if 1 >handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY                 then result = element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY                 break;endmemory = pointer;until true;else result = element;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             elseif -2 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then for element =, 3c, 6e do if 2 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then buffer = accumulator;break;endstring = list;break;end;else string = list;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         elseif 5 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then if 6 ==handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then accumulator .object = char;else end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif 2 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then repeat if 5 ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then char = buffer [result .string];break;endobject = result .memory;until true;else object = result .memory;end end end handle = handle + 1 end count = count +   handle = 0, 2 do if 0 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then if handle == 1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     array = element .dt .array = accumulator .array (object (accumulator, array + 1, element .list ))count = count +  function .count;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     array = element .pointer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     key = accumulator .array;for element = array + 1, element .ldo result .CkEVrajh (key, accumulator .element )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY end;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY handle = 0
-- PHASE_BOUNDARY:VM_2C_BOUNDARY while handle > -1do if handle hen if 0 >=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then memory = element;elseif 1 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then buffer = list;else char = pointer;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 4 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then if handle >= 2then for element = 1g, 7i do if handle > 5then break;end;accumulator (user, string );break;end;else end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 4 ==handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then user = memory .char;else string = memory .buffer;end end end handle = handle + 1 end count = count +  function .count;end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY else for handle = 0, 1 do if -3 <handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then repeat if handle hen accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;break;end;if not accumulator [element .pointer]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then count = count + 1;else count = element .list;end;until true;else accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .count;end end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY elseif 13f <=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then for result =, 4i, 6g do if 13i ~=handle
-- PHASE_BOUNDARY:VM_2C_BOUNDARY then accumulator [element .pointer]=accumulator [element .list]* element .array;break;end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local handle;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .counthandle = element .pointer;do return, accumulator .handle (object (accumulator, handle + 1, element .list ))endcount = count +  function .counthandle = element .pointer;do return object (accumulator, handle, buffer )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY endcount = count +  function .count;do return end;break;end;else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local handle;accumulator [element .pointer]= string [element .list]
-- PHASE_BOUNDARY:VM_2C_BOUNDARY count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=string [element .list]count = count +  function .count;accumulator [element .pointer]=accumulator [element .list][accumulator [element .array]] count = count +  function .counthandle = element .pointer;do return, accumulator .handle (object (accumulator, handle + 1, element .list ))endcount = count +  function .counthandle = element .pointer;do return object (accumulator, handle, buffer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY endcount = count +  function .count;do return end;end end end end end end end count = 1 + count;end;end;return te end;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY xff;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local array = {} ;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY ;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local pointer = ''; (function (count
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local accumulator = count
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local  function = 0x0a x0a
-- PHASE_BOUNDARY:VM_2C_BOUNDARY local  accumulator = {
-- PHASE_BOUNDARY:VM_2C_BOUNDARY                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         (function (handle )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if function > 0xcf
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     return handle end function = function + 1 element =(element +  -handle ) %  return (element  %  0x0d == 0xc and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if not count .tthen element = element + 0x0b count .accumulator =(0x4a )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY return true end )"Sygbo"and accumulator [0xd]( + handle ))or (element  %  0x0d == 0xb and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY if not count .tthen
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     element = element + 0x0b count .accumulator =( )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     pointer ='\3h'list = {function ( . )list ()en, d} } pointer = pointer . \10a\4d';end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     return true end )"virqv"and accumulator [0xc](handle + 0x15f ))or (element  %  0x0d == 0xa and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if not count .tthen
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         element = element + 0x0b count .accumulator =( )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     return true end )"AzKgP"and accumulator [0xb](handle +  ))or handle end ), (function (object )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if function > 
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         return object end function = function + 1 element =(element + 0xb6e -object ) % 0x2f return (element  %  0x0d == 0xa and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         if not count .tthen element = element + 0x0b count .accumulator =(0xcf )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     return true end )"LWiGL"and accumulator [0xb]( + object ))or (element  %  0x0d == 0xb and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if not count .tthen
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         element = element + 0x0b count .accumulator =( )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     return true end )"laIFn"and accumulator [0xc](object + 0x3ef ))or (element  %  0x0d == 0xc and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if not count .tthen element = element + 0x0b count .accumulator =(0xdf );
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         local pointer = {pointer . \5i a', pointer} ;array .handle = de () handle = handle + ( (not result .angJHMZC
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         and 1 or 0 );pointer [1]= \5i' .pointer [1];list [2]=0xff;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         return true end )"eJIri"and accumulator [0xd](object +  ))or objec, t, } end ), (function (result )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         if function > 0xbe
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             return result end function = function + 1 element =(element +  -result ) %  return (element  %  0x0d == 0xc and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             if not count .tthen element = element + 0x0b count .accumulator =(0x3e )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         return true end )"xMnUw"and accumulator [0xb](0x17e + result ))or (element  %  0x0d == 0xa and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         if not count .tthen
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             element = element + 0x0b count .accumulator =(0xce )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             list [2]= (list [2]* (te (function ( . )array ()end, object (pointer )) -te (list [1], object (pointer )) ))1;array .handle = {} list = list [2]handle = handle + list;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             return true end )"WhcCE"and accumulator [0xd](result + 0x36d ))or (element  %  0x0d == 0xb and (function (accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             if not count .tthen
-- PHASE_BOUNDARY:VM_2C_BOUNDARY                 element = element + 0x0b count .accumulator =(0xdd )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY                 array .handle = le () handle = handle + list;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY                 return true end )"jCLPm"and accumulator [0xc](result + 0x2ae ))or result end, ) } }accumulator [0xb](0x10ca
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             end ) {} ;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             local element = key (object (array )) array [2]= {} ;array [1]=element (array [1])LYxYTVvyVxDWXQP = nilelement = key (object (array ))return element ( . );end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             return te ((function ( . )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             local count = {} local  element = 0x0b;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             local accumulator;if result .angJHMZC
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             accumulator = result .angJHMZC (te
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         else accumulator =''end i, f, } result .LPTRooEy (accumulator, result .YDJSIPFi )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then element = element + 0
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     else element = element + 1;end count .element = 0x0c;count [count .element + 0x0b]=0x0d;return, count;end )( ))end )( (function (element, count, accumulator, list, pointer
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     function
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         local function;if element < =3
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         if element >= 2then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             if -1 ~= element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY                 then repeat if 2 ~=element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY                 then do return count (1 ), count (4, pointer, list, accumulator, count ), count (5, pointer, list, accumulator
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         break;end;do return  25g end;until true;else do return  25g end;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif -2 <=element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then for function = 3i, 8g do if element > 0then do return function (accumulator, element, count )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if count
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         local element = (accumulator / 2 ^ (element -1 )) % 2 ^ ( (count -1 )- (element -1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         1 )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         return element -element  %  1;else  ^ (element -1 );return (accumulator  %  (element + element )> =element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         and 1 or 0;end;end;end;break;end;do return count (1 ), count (4, pointer, list, accumulator, count ), count (5, pointer, list, accumulator
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     end;break;end;else do return function (accumulator, element, count )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if count
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         local element = (accumulator / 2 ^ (element -1 )) % 2 ^ ( (count -1 )- (element -1
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         1 )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         return element -element  %  1;else  ^ (element -1 );return (accumulator  %  (element + element )> =element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         and 1 or 0;end;end;end;end end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     elseif element < 6
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     then
-- PHASE_BOUNDARY:VM_2C_BOUNDARY     if 4 ~= element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         then local element = list
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         do return function ( . )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             local count = count (accumulator, element (element, element ), element (element, element )) element (1 );return count;end;end;else local element = list;
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             local function = pointer (2 );do return function ( . ), pointer = nil, list = nil
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             local count = count (accumulator, handle = element (element, accumulator = element ), result = element (element, nil = element )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             3 );element (4 );return (result * function )+ (accumulator * pointer )+ (handle * list )+ count;end;end;end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         else
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         if element hen do return pointer .tend;elseif 8 >element
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             then do return setmetatable ( {}, {['__\9j\9h\10i\10i']=, function (element, pointer, accumulator, list, count ) if count then return element .nelseif list then return element else element .pointer = accumulator end end} )end
-- PHASE_BOUNDARY:VM_2C_BOUNDARY             else do return accumulator (element, nil, accumulator )
-- PHASE_BOUNDARY:VM_2C_BOUNDARY         end end end end end end ))
